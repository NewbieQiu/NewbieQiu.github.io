{"meta":{"title":"菜鸡日志","subtitle":"newbieQiu的小屋","description":"莫听穿林打叶声，何妨吟啸且徐行","author":"newbieQiu","url":"http://newbieqiu.top","root":"/"},"pages":[{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2022-04-22T14:53:55.061Z","comments":true,"path":"about/index.html","permalink":"http://newbieqiu.top/about/index.html","excerpt":"","text":""},{"title":"","date":"2022-04-22T14:53:20.495Z","updated":"2022-04-22T14:53:20.495Z","comments":true,"path":"404/index.html","permalink":"http://newbieqiu.top/404/index.html","excerpt":"","text":"​—title: 404date: 2018-09-30 17:25:30type: “404”layout: “404”description: “Oops～，我崩溃了！找不到你想要的页面 :(“​—"},{"title":"contact","date":"2018-09-30T09:25:30.000Z","updated":"2022-04-22T14:54:54.207Z","comments":true,"path":"contact/index.html","permalink":"http://newbieqiu.top/contact/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-09-30T09:25:30.000Z","updated":"2022-04-22T14:51:55.135Z","comments":true,"path":"categories/index.html","permalink":"http://newbieqiu.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2022-04-22T14:54:13.190Z","updated":"2022-04-22T14:54:13.190Z","comments":true,"path":"tags/index.html","permalink":"http://newbieqiu.top/tags/index.html","excerpt":"","text":"​—title: tagsdate: 2018-09-30 18:23:38type: “tags”layout: “tags”​—"},{"title":"","date":"2022-04-22T14:54:33.157Z","updated":"2022-04-22T14:54:33.157Z","comments":true,"path":"friends/index.html","permalink":"http://newbieqiu.top/friends/index.html","excerpt":"","text":"title: friendsdate: 2018-12-12 21:25:30type: “friends”layout: “friends”"}],"posts":[{"title":"最短路算法之bellman-ford-算法","slug":"最短路算法之bellman-ford-算法","date":"2022-04-27T11:55:00.000Z","updated":"2022-04-27T11:57:03.983Z","comments":true,"path":"2022/04/27/最短路算法之bellman-ford-算法/","link":"","permalink":"http://newbieqiu.top/2022/04/27/%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95%E4%B9%8Bbellman-ford-%E7%AE%97%E6%B3%95/","excerpt":"","text":"最短路算法之 bellman_ford算法bellman_ford 算法的时间复杂度为o（n*m），一般用在存在负权边的情况。存在负权边的情况bellman_ford 算法和 SPFA算法都可以使用 ，但SPFA算法会优于改算法，但有一种情况下不能代替。即题目中出现有边数限制的最短路。模板题思路 代码#include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; const int N = 510, M = 10010; struct Edge { int a; int b; int w; } e[M];//把每个边保存下来即可 int dist[N]; int back[N];//备份数组防止串联 int n, m, k;//k代表最短路径最多包涵k条边 int bellman_ford() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i &lt; k; i++) {//k次循环 memcpy(back, dist, sizeof dist); for (int j = 0; j &lt; m; j++) {//遍历所有边 int a = e[j].a, b = e[j].b, w = e[j].w; dist[b] = min(dist[b], back[a] + w); //使用backup:避免给a更新后立马更新b, 这样b一次性最短路径就多了两条边出来 } } if (dist[n] &gt; 0x3f3f3f3f / 2) return -1; else return dist[n]; } int main() { scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for (int i = 0; i &lt; m; i++) { int a, b, w; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;w); e[i] = {a, b, w}; } int res = bellman_ford(); if (res == -1) puts(\"impossible\"); else cout &lt;&lt; res; return 0; } 一些小细节为什么是dist[n]&gt;0x3f3f3f3f/2， 而不是dist[n]==0x3f3f3f3f5号节点距离起点的距离是无穷大，利用5号节点更新n号节点距离起点的距离，将得到109−2109−2, 虽然小于109109, 但并不存在最短路，(在边数限制在k条的条件下)。 为什么需要back[a]数组为了避免如下的串联情况， 在边数限制为一条的情况下，节点3的距离应该是3，但是由于串联情况，利用本轮更新的节点2更新了节点3的距离，所以现在节点3的距离是2。 正确做法是用上轮节点2更新的距离–无穷大，来更新节点3， 再取最小值，所以节点3离起点的距离是3。","categories":[],"tags":[]},{"title":"最短路算法之 bellman_ford 算法","slug":"最短路算法之-bellman-ford-算法","date":"2022-04-27T11:22:17.000Z","updated":"2022-04-27T12:00:38.500Z","comments":true,"path":"2022/04/27/最短路算法之-bellman-ford-算法/","link":"","permalink":"http://newbieqiu.top/2022/04/27/%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95%E4%B9%8B-bellman-ford-%E7%AE%97%E6%B3%95/","excerpt":"","text":"最短路算法之 bellman_ford算法bellman_ford 算法的时间复杂度为o（n*m），一般用在存在负权边的情况。存在负权边的情况bellman_ford 算法和 SPFA算法都可以使用 ，但SPFA算法会优于改算法，但有一种情况下不能代替。即题目中出现有边数限制的最短路。模板题思路 代码#include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; const int N = 510, M = 10010; struct Edge { int a; int b; int w; } e[M];//把每个边保存下来即可 int dist[N]; int back[N];//备份数组防止串联 int n, m, k;//k代表最短路径最多包涵k条边 int bellman_ford() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i &lt; k; i++) {//k次循环 memcpy(back, dist, sizeof dist); for (int j = 0; j &lt; m; j++) {//遍历所有边 int a = e[j].a, b = e[j].b, w = e[j].w; dist[b] = min(dist[b], back[a] + w); //使用backup:避免给a更新后立马更新b, 这样b一次性最短路径就多了两条边出来 } } if (dist[n] &gt; 0x3f3f3f3f / 2) return -1; else return dist[n]; } int main() { scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for (int i = 0; i &lt; m; i++) { int a, b, w; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;w); e[i] = {a, b, w}; } int res = bellman_ford(); if (res == -1) puts(\"impossible\"); else cout &lt;&lt; res; return 0; } 一些小细节为什么是dist[n]&gt;0x3f3f3f3f/2， 而不是dist[n]==0x3f3f3f3f5号节点距离起点的距离是无穷大，利用5号节点更新n号节点距离起点的距离，将得到109−2109−2, 虽然小于109109, 但并不存在最短路，(在边数限制在k条的条件下)。 为什么需要back[a]数组为了避免如下的串联情况， 在边数限制为一条的情况下，节点3的距离应该是3，但是由于串联情况，利用本轮更新的节点2更新了节点3的距离，所以现在节点3的距离是2。 正确做法是用上轮节点2更新的距离–无穷大，来更新节点3， 再取最小值，所以节点3离起点的距离是3。","categories":[{"name":"算法","slug":"算法","permalink":"http://newbieqiu.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"最短路","slug":"算法/最短路","permalink":"http://newbieqiu.top/categories/%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}],"tags":[]},{"title":"最短路之 Dijkstra 算法","slug":"最短路之-Dijstra-算法","date":"2022-04-26T04:02:29.000Z","updated":"2022-04-26T07:54:48.756Z","comments":true,"path":"2022/04/26/最短路之-Dijstra-算法/","link":"","permalink":"http://newbieqiu.top/2022/04/26/%E6%9C%80%E7%9F%AD%E8%B7%AF%E4%B9%8B-Dijstra-%E7%AE%97%E6%B3%95/","excerpt":"","text":"最短路之 Dijkstra 算法（朴素做法）时间复杂度 O(n2)没什么好说的先上模板题Dijkstra算法(用于稀疏图) 总结来说就是以下的几步：1.初始化距离 dist[1]=0 dist[i] =无穷大2. for( i=1 到 n)2.1 找t不在s中的距离最近的点2.2 讲 t加入到 s中2.3 用t更新到其他点的距离#include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; const int N=510; int g[N][N]; //为稠密阵所以用邻接矩阵存储 int dist[N]; //用于记录每一个点距离第一个点的距离 bool st[N]; //用于记录该点的最短距离是否已经确定 int n,m; int Dijkstra() { memset(dist, 0x3f,sizeof dist); //初始化距离 0x3f代表无限大 dist[1]=0; //第一个点到自身的距离为0 for(int i=0;i&lt;n;i++) //有n个点所以要进行n次 迭代 { int t=-1; //t存储当前访问的点 for(int j=1;j&lt;=n;j++) //这里的j代表的是从1号点开始 if(!st[j]&amp;&amp;(t==-1|| dist[t]&gt;dist[j]) ) t=j; st[t]=true; for(int j=1;j&lt;=n;j++) //依次更新每个点所到相邻的点路径值 dist[j]=min(dist[j],dist[t]+g[t][j]); //这里可能有同学要问j如果从1开始的话 会不会影响之前已经确定的点的最小距离 //但其实是不会 因为按照我们的Dijkstra算法的操作顺序 先确定最短距离的点的距离已经比后确定的要小 所以不会影响 //当然你也可以在循环判断条件里加上if(!st[i]) //这里j从1开始只是为了代码的简洁 } if(dist[n]==0x3f3f3f3f) return -1; //如果第n个点路径为无穷大即不存在最低路径 return dist[n]; } int main() { cin&gt;&gt;n&gt;&gt;m; memset(g,0x3f,sizeof g); //初始化图 因为是求最短路径 //所以每个点初始为无限大 while(m--) { int x,y,z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; g[x][y]=min(g[x][y],z); //如果发生重边的情况则保留最短的一条边 } cout&lt;&lt;Dijkstra()&lt;&lt;endl; return 0; } Dijkstra算法（堆优化版）用于稠密图，时间复杂度O(mlog(n)) m为变数n为点数模板题：堆优化版模板题 思路1.一号点的距离初始化为零，其他点初始化成无穷大。2.将一号点放入堆中。3.不断循环，直到堆空。每一次循环中执行的操作为：弹出堆顶（与朴素版diijkstra找到S外距离最短的点相同，并标记该点的最短路径已经确定）。用该点更新临界点的距离，若更新成功就加入到堆中。for(i:1 ~ n)//n次 { t &lt;- 没有确定最短路径的节点中距离源点最近的点;//每次遍一遍历dist数组，n次的复杂度是O(n^2) state[t] = 1; 更新 dist;//每次遍历一个节点的出边，n次遍历了所有节点的边，复杂度为O(e) } #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; typedef pair&lt;int, int&gt; PII; const int N = 100010; // 把N改为150010就能ac // 稀疏图用邻接表来存 int h[N], e[N], ne[N], idx; int w[N]; // 用来存权重 int dist[N]; bool st[N]; // 如果为true说明这个点的最短路径已经确定 int n, m; void add(int x, int y, int c) { w[idx] = c; // 有重边也不要紧，假设1-&gt;2有权重为2和3的边，再遍历到点1的时候2号点的距离会更新两次放入堆中 e[idx] = y; // 这样堆中会有很多冗余的点，但是在弹出的时候还是会弹出最小值2+x（x为之前确定的最短路径），并 ne[idx] = h[x]; // 标记st为true，所以下一次弹出3+x会continue不会向下执行。 h[x] = idx++; } int dijkstra() { memset(dist, 0x3f, sizeof(dist)); dist[1] = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; // 定义一个小根堆 // 这里heap中为什么要存pair呢，首先小根堆是根据距离来排的，所以有一个变量要是距离，其次在从堆中拿出来的时 // 候要知道知道这个点是哪个点，不然怎么更新邻接点呢？所以第二个变量要存点。 heap.push({ 0, 1 }); // 这个顺序不能倒，pair排序时是先根据first，再根据second，这里显然要根据距离排序 while(heap.size()) { PII k = heap.top(); // 取不在集合S中距离最短的点 heap.pop(); int ver = k.second, distance = k.first; if(st[ver]) continue; st[ver] = true; for(int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; // i只是个下标，e中在存的是i这个下标对应的点。 if(dist[j] &gt; distance + w[i]) { dist[j] = distance + w[i]; heap.push({ dist[j], j }); } } } if(dist[n] == 0x3f3f3f3f) return -1; else return dist[n]; } int main() { memset(h, -1, sizeof(h)); scanf(\"%d%d\", &amp;n, &amp;m); while (m--) { int x, y, c; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;c); add(x, y, c); } cout &lt;&lt; dijkstra() &lt;&lt; endl; return 0; } ps：不用continue不会影响后面的取值，因为有dis[j]&gt;distance+w[i]的判断，一定会更新成最小的那个，只不过就是把这个点的邻接点又加进去判断了而已，多了几次for循环，加上continue会减少这个判断，不加continue会超时，不会答案错误。","categories":[{"name":"算法","slug":"算法","permalink":"http://newbieqiu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://newbieqiu.top/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"算法","slug":"算法","permalink":"http://newbieqiu.top/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Mybatis Plus笔记(1)","slug":"Mybatis-Plus笔记-1","date":"2022-04-25T09:56:51.000Z","updated":"2022-04-25T10:47:10.065Z","comments":true,"path":"2022/04/25/Mybatis-Plus笔记-1/","link":"","permalink":"http://newbieqiu.top/2022/04/25/Mybatis-Plus%E7%AC%94%E8%AE%B0-1/","excerpt":"","text":"初始化引入依赖(Springboot方式启动)&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 配置yml文件spring: # 配置数据源信息 datasource: # 配置数据源类型 type: com.zaxxer.hikari.HikariDataSource # 配置连接数据库信息 driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false username: root password: 123456 8.0加上这句在问号后面加上 serverTimezone=GMT%2B8&amp; 启动类在Spring Boot启动类中添加@MapperScan注解，扫描mapper包日志添加# 配置MyBatis日志 mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl 基本的CRUD操作批量删除@Test public void testDeleteBatchIds(){ //通过多个id批量删除 //DELETE FROM user WHERE id IN ( ? , ? , ? ) List&lt;Long&gt; idList = Arrays.asList(1L, 2L, 3L); int result = userMapper.deleteBatchIds(idList); System.out.println(\"受影响行数：\"+result); } 通过Map删除@Test public void testDeleteByMap(){ //根据map集合中所设置的条件删除记录 //DELETE FROM user WHERE name = ? AND age = ? Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"age\", 23); map.put(\"name\", \"张三\"); int result = userMapper.deleteByMap(map); System.out.println(\"受影响行数：\"+result); } 查询的map和批量查大同小异，这里不再一一赘述 。最后不要忘了 Mapper接口继承 BaseMapper 哦！！自定义接口在不改yaml文件的情况下默认把xml文件放在Mapper包下或者其子包下（或者可以在yaml文件下设置mapper-locations: classpath:/mapper/Usermapper.xml 记得在主加载类上加@Mapperscan 扫描 ！！！","categories":[],"tags":[{"name":"mybatisPlus","slug":"mybatisPlus","permalink":"http://newbieqiu.top/tags/mybatisPlus/"}]},{"title":"Mybatis 复习(一对多多对一)","slug":"Mybatis-复习-一对多多对一","date":"2022-04-24T09:44:33.000Z","updated":"2022-04-24T09:50:34.967Z","comments":true,"path":"2022/04/24/Mybatis-复习-一对多多对一/","link":"","permalink":"http://newbieqiu.top/2022/04/24/Mybatis-%E5%A4%8D%E4%B9%A0-%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%A4%9A%E5%AF%B9%E4%B8%80/","excerpt":"","text":"自定义映射resultMapresultMap处理字段和属性的映射关系 resultMap：设置自定义映射 属性： id：表示自定义映射的唯一标识，不能重复 type：查询的数据要映射的实体类的类型 子标签： id：设置主键的映射关系 result：设置普通字段的映射关系 子标签属性： property：设置映射关系中实体类中的属性名 column：设置映射关系中表中的字段名 若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射，即使字段名和属性名一致的属性也要映射，也就是全部属性都要列出来 &lt;resultMap id=\"empResultMap\" type=\"Emp\"&gt; &lt;id property=\"eid\" column=\"eid\"&gt;&lt;/id&gt; &lt;result property=\"empName\" column=\"emp_name\"&gt;&lt;/result&gt; &lt;result property=\"age\" column=\"age\"&gt;&lt;/result&gt; &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"email\" column=\"email\"&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;!--List&lt;Emp&gt; getAllEmp();--&gt; &lt;select id=\"getAllEmp\" resultMap=\"empResultMap\"&gt; select * from t_emp &lt;/select&gt; 若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用_），实体类中的属性名符合Java的规则（使用驼峰）。此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系 可以通过为字段起别名的方式，保证和实体类中的属性名保持一致 &lt;!--List&lt;Emp&gt; getAllEmp();--&gt; &lt;select id=\"getAllEmp\" resultType=\"Emp\"&gt; select eid,emp_name empName,age,sex,email from t_emp &lt;/select&gt; 可以在MyBatis的核心配置文件中的setting标签中，设置一个全局配置信息mapUnderscoreToCamelCase，可以在查询表中数据时，自动将_类型的字段名转换为驼峰，例如：字段名user_name，设置了mapUnderscoreToCamelCase，此时字段名就会转换为userName。核心配置文件详解 &lt;settings&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;/settings&gt; 多对一映射处理 查询员工信息以及员工所对应的部门信息 public class Emp { private Integer eid; private String empName; private Integer age; private String sex; private String email; private Dept dept; //...构造器、get、set方法等 } 级联方式处理映射关系&lt;resultMap id=\"empAndDeptResultMapOne\" type=\"Emp\"&gt; &lt;id property=\"eid\" column=\"eid\"&gt;&lt;/id&gt; &lt;result property=\"empName\" column=\"emp_name\"&gt;&lt;/result&gt; &lt;result property=\"age\" column=\"age\"&gt;&lt;/result&gt; &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"email\" column=\"email\"&gt;&lt;/result&gt; &lt;result property=\"dept.did\" column=\"did\"&gt;&lt;/result&gt; &lt;result property=\"dept.deptName\" column=\"dept_name\"&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;!--Emp getEmpAndDept(@Param(\"eid\")Integer eid);--&gt; &lt;select id=\"getEmpAndDept\" resultMap=\"empAndDeptResultMapOne\"&gt; select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #{eid} &lt;/select&gt; 使用association处理映射关系 association：处理多对一的映射关系 property：需要处理多对的映射关系的属性名 javaType：该属性的类型 &lt;resultMap id=\"empAndDeptResultMapTwo\" type=\"Emp\"&gt; &lt;id property=\"eid\" column=\"eid\"&gt;&lt;/id&gt; &lt;result property=\"empName\" column=\"emp_name\"&gt;&lt;/result&gt; &lt;result property=\"age\" column=\"age\"&gt;&lt;/result&gt; &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"email\" column=\"email\"&gt;&lt;/result&gt; &lt;association property=\"dept\" javaType=\"Dept\"&gt; &lt;id property=\"did\" column=\"did\"&gt;&lt;/id&gt; &lt;result property=\"deptName\" column=\"dept_name\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;!--Emp getEmpAndDept(@Param(\"eid\")Integer eid);--&gt; &lt;select id=\"getEmpAndDept\" resultMap=\"empAndDeptResultMapTwo\"&gt; select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #{eid} &lt;/select&gt; 分步查询1. 查询员工信息 select：设置分布查询的sql的唯一标识（namespace.SQLId或mapper接口的全类名.方法名） column：设置分步查询的条件 //EmpMapper里的方法 /** * 通过分步查询，员工及所对应的部门信息 * 分步查询第一步：查询员工信息 * @param * @return com.atguigu.mybatis.pojo.Emp * @date 2022/2/27 20:17 */ Emp getEmpAndDeptByStepOne(@Param(\"eid\") Integer eid); &lt;resultMap id=\"empAndDeptByStepResultMap\" type=\"Emp\"&gt; &lt;id property=\"eid\" column=\"eid\"&gt;&lt;/id&gt; &lt;result property=\"empName\" column=\"emp_name\"&gt;&lt;/result&gt; &lt;result property=\"age\" column=\"age\"&gt;&lt;/result&gt; &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"email\" column=\"email\"&gt;&lt;/result&gt; &lt;association property=\"dept\" select=\"com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo\" column=\"did\"&gt;&lt;/association&gt; &lt;/resultMap&gt; &lt;!--Emp getEmpAndDeptByStepOne(@Param(\"eid\") Integer eid);--&gt; &lt;select id=\"getEmpAndDeptByStepOne\" resultMap=\"empAndDeptByStepResultMap\"&gt; select * from t_emp where eid = #{eid} &lt;/select&gt; 2. 查询部门信息//DeptMapper里的方法 /** * 通过分步查询，员工及所对应的部门信息 * 分步查询第二步：通过did查询员工对应的部门信息 * @param * @return com.atguigu.mybatis.pojo.Emp * @date 2022/2/27 20:23 */ Dept getEmpAndDeptByStepTwo(@Param(\"did\") Integer did); &lt;!--此处的resultMap仅是处理字段和属性的映射关系--&gt; &lt;resultMap id=\"EmpAndDeptByStepTwoResultMap\" type=\"Dept\"&gt; &lt;id property=\"did\" column=\"did\"&gt;&lt;/id&gt; &lt;result property=\"deptName\" column=\"dept_name\"&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;!--Dept getEmpAndDeptByStepTwo(@Param(\"did\") Integer did);--&gt; &lt;select id=\"getEmpAndDeptByStepTwo\" resultMap=\"EmpAndDeptByStepTwoResultMap\"&gt; select * from t_dept where did = #{did} &lt;/select&gt; 一对多映射处理public class Dept { private Integer did; private String deptName; private List&lt;Emp&gt; emps; //...构造器、get、set方法等 } collection collection：用来处理一对多的映射关系 ofType：表示该属性对饮的集合中存储的数据的类型 &lt;resultMap id=\"DeptAndEmpResultMap\" type=\"Dept\"&gt; &lt;id property=\"did\" column=\"did\"&gt;&lt;/id&gt; &lt;result property=\"deptName\" column=\"dept_name\"&gt;&lt;/result&gt; &lt;collection property=\"emps\" ofType=\"Emp\"&gt; &lt;id property=\"eid\" column=\"eid\"&gt;&lt;/id&gt; &lt;result property=\"empName\" column=\"emp_name\"&gt;&lt;/result&gt; &lt;result property=\"age\" column=\"age\"&gt;&lt;/result&gt; &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"email\" column=\"email\"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!--Dept getDeptAndEmp(@Param(\"did\") Integer did);--&gt; &lt;select id=\"getDeptAndEmp\" resultMap=\"DeptAndEmpResultMap\"&gt; select * from t_dept left join t_emp on t_dept.did = t_emp.did where t_dept.did = #{did} &lt;/select&gt; 分步查询1. 查询部门信息/** * 通过分步查询，查询部门及对应的所有员工信息 * 分步查询第一步：查询部门信息 * @param did * @return com.atguigu.mybatis.pojo.Dept * @date 2022/2/27 22:04 */ Dept getDeptAndEmpByStepOne(@Param(\"did\") Integer did); &lt;resultMap id=\"DeptAndEmpByStepOneResultMap\" type=\"Dept\"&gt; &lt;id property=\"did\" column=\"did\"&gt;&lt;/id&gt; &lt;result property=\"deptName\" column=\"dept_name\"&gt;&lt;/result&gt; &lt;collection property=\"emps\" select=\"com.atguigu.mybatis.mapper.EmpMapper.getDeptAndEmpByStepTwo\" column=\"did\"&gt;&lt;/collection&gt; &lt;/resultMap&gt; &lt;!--Dept getDeptAndEmpByStepOne(@Param(\"did\") Integer did);--&gt; &lt;select id=\"getDeptAndEmpByStepOne\" resultMap=\"DeptAndEmpByStepOneResultMap\"&gt; select * from t_dept where did = #{did} &lt;/select&gt; 2. 根据部门id查询部门中的所有员工/** * 通过分步查询，查询部门及对应的所有员工信息 * 分步查询第二步：根据部门id查询部门中的所有员工 * @param did * @return java.util.List&lt;com.atguigu.mybatis.pojo.Emp&gt; * @date 2022/2/27 22:10 */ List&lt;Emp&gt; getDeptAndEmpByStepTwo(@Param(\"did\") Integer did); &lt;!--List&lt;Emp&gt; getDeptAndEmpByStepTwo(@Param(\"did\") Integer did);--&gt; &lt;select id=\"getDeptAndEmpByStepTwo\" resultType=\"Emp\"&gt; select * from t_emp where did = #{did} &lt;/select&gt;","categories":[],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://newbieqiu.top/tags/Mybatis/"}]},{"title":"Mybatis 笔记","slug":"Mybatis-笔记","date":"2022-04-24T07:11:32.000Z","updated":"2022-04-24T07:15:32.967Z","comments":true,"path":"2022/04/24/Mybatis-笔记/","link":"","permalink":"http://newbieqiu.top/2022/04/24/Mybatis-%E7%AC%94%E8%AE%B0/","excerpt":"","text":"MyBatis 笔记（基础配置）环境初始化依赖坐标 打包方式： jar &lt;dependencies&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.18&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; jdbc.propertiesdriver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/mybatis?userSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8 username=root password=1234 log4j.propertieslog4j.rootLogger=DEBUG,A1 log4j.appender.A1=org.apache.log4j.ConsoleAppender log4j.appender.A1.layout=org.apache.log4j.PatternLayout log4j.appender.A1.layout.ConversionPattern=[%t] [%c]-[%p] %m%n Mapper.xml 文件&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;!-- namespace:名称空间, 对应接口的全类名 --&gt; &lt;mapper namespace=\"org.hong.mapper.UserMapper\"&gt; &lt;!-- select: 配置查询 id: 唯一标识, 对应接口中的方法名 resultType: 返回值类型, 类的全类名, 如果返回值是集合写集合中泛型的类型 --&gt; &lt;select id=\"getAll\" resultType=\"org.hong.pojo.User\"&gt; select * from user &lt;/select&gt; &lt;/mapper&gt; mybatis 核心配置文件习惯上命名为mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。将来整合Spring之后，这个配置文件可以省略核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息核心配置文件存放的位置是src/main/resources目录下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//MyBatis.org//DTD Config 3.0//EN\" \"http://MyBatis.org/dtd/MyBatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;!--引入properties文件，此时就可以${属性名}的方式访问属性值--&gt; &lt;properties resource=\"jdbc.properties\"&gt;&lt;/properties&gt; &lt;settings&gt; &lt;!--将表中字段的下划线自动转换为驼峰--&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;!--开启延迟加载--&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;!-- typeAlias：设置某个具体的类型的别名 属性： type：需要设置别名的类型的全类名 alias：设置此类型的别名，且别名不区分大小写。若不设置此属性，该类型拥有默认的别名，即类名 --&gt; &lt;!--&lt;typeAlias type=\"com.atguigu.mybatis.bean.User\"&gt;&lt;/typeAlias&gt;--&gt; &lt;!--&lt;typeAlias type=\"com.atguigu.mybatis.bean.User\" alias=\"user\"&gt; &lt;/typeAlias&gt;--&gt; &lt;!--以包为单位，设置改包下所有的类型都拥有默认的别名，即类名且不区分大小写--&gt; &lt;package name=\"com.atguigu.mybatis.bean\"/&gt; &lt;/typeAliases&gt; &lt;!-- environments：设置多个连接数据库的环境 属性： default：设置默认使用的环境的id --&gt; &lt;environments default=\"mysql_test\"&gt; &lt;!-- environment：设置具体的连接数据库的环境信息 属性： id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境的id，表示默认使用的环境 --&gt; &lt;environment id=\"mysql_test\"&gt; &lt;!-- transactionManager：设置事务管理方式 属性： type：设置事务管理方式，type=\"JDBC|MANAGED\" type=\"JDBC\"：设置当前环境的事务管理都必须手动处理 type=\"MANAGED\"：设置事务被管理，例如spring中的AOP --&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!-- dataSource：设置数据源 属性： type：设置数据源的类型，type=\"POOLED|UNPOOLED|JNDI\" type=\"POOLED\"：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从缓存中直接获取，不需要重新创建 type=\"UNPOOLED\"：不使用数据库连接池，即每次使用连接都需要重新创建 type=\"JNDI\"：调用上下文中的数据源 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!--设置驱动类的全类名--&gt; &lt;property name=\"driver\" value=\"${jdbc.driver}\"/&gt; &lt;!--设置连接数据库的连接地址--&gt; &lt;property name=\"url\" value=\"${jdbc.url}\"/&gt; &lt;!--设置连接数据库的用户名--&gt; &lt;property name=\"username\" value=\"${jdbc.username}\"/&gt; &lt;!--设置连接数据库的密码--&gt; &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--引入映射文件--&gt; &lt;mappers&gt; &lt;!-- &lt;mapper resource=\"UserMapper.xml\"/&gt; --&gt; &lt;!-- 以包为单位，将包下所有的映射文件引入核心配置文件 注意： 1. 此方式必须保证mapper接口和mapper映射文件必须在相同的包下 2. mapper接口要和mapper映射文件的名字一致 --&gt; &lt;package name=\"Mappers.UserMapper\"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 把getSQLSession封装成工具类package org.hong.util; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; public class MyBatisUtil { private static SqlSessionFactory sqlSessionFactory; static { try { // 获取sqlSessionFactory对象 String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } // 既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。 // SqlSession 提供了在数据库执行 SQL 命令所需的所有方法 public static SqlSession getSqlSession(){ // openSession(): 此方式打开SQL会话, 事务是开启状态 // openSession(true): 此方式打开SQL会话, 事务是关闭状态 return sqlSessionFactory.openSession(); } public static SqlSessionFactory getSqlSessionFactory() { return sqlSessionFactory; } } 普通的CRUD创建mapper接口 MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要提供实现类 package Mappers; public interface UserMapper { int insertUser(); } 创建MyBatis的映射文件 对象：Java的实体类对象 关系：关系型数据库 映射：二者之间的对应关系 Java概念 数据库概念 类 表 属性 字段/列 对象 记录/行 映射文件的命名规则 表所对应的实体类的类名+Mapper.xml 例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml 因此一个映射文件对应一个实体类，对应一张表的操作 MyBatis映射文件用于编写SQL，访问以及操作表中的数据 MyBatis映射文件存放的位置是src/main/resources/mappers目录下 MyBatis中可以面向接口操作数据，要保证两个一致 mapper接口的全类名和映射文件的命名空间（namespace）保持一致 mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"zjiet.mapper.UserMapper\"&gt; &lt;!--int insertUser();--&gt; &lt;insert id=\"insertUser\"&gt; insert into user values (20, '张三', null , 2, , '176@qq.com') &lt;/insert&gt; &lt;/mapper&gt; 注意接口在java包里，xml在resources里面 且resources里的结构要与java里的结构保持一致.（即Mapper文件的相对位置） Test方法 public void test001(){ // 1.获取sqlSession对象 SqlSession sqlSession = MyBatisUtil.getSqlSession(); // 2.获取需要的mapper接口的代理对象 UserMapper mapper = sqlSession.getMapper(UserMapper.class); // 3.调用对应的方法执行操作 int save = mapper.insertUser(); System.out.println(save); // 4.提交事务 sqlSession.commit(); // 5.关闭sqlSession sqlSession.close(); }","categories":[],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://newbieqiu.top/tags/Mybatis/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-04-22T09:50:46.644Z","updated":"2022-04-23T01:20:09.890Z","comments":true,"path":"2022/04/22/hello-world/","link":"","permalink":"http://newbieqiu.top/2022/04/22/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"算法","slug":"算法","permalink":"http://newbieqiu.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"最短路","slug":"算法/最短路","permalink":"http://newbieqiu.top/categories/%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://newbieqiu.top/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"算法","slug":"算法","permalink":"http://newbieqiu.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"mybatisPlus","slug":"mybatisPlus","permalink":"http://newbieqiu.top/tags/mybatisPlus/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://newbieqiu.top/tags/Mybatis/"}]}