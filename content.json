{"meta":{"title":"菜鸡日志","subtitle":"newbieQiu的小屋","description":"莫听穿林打叶声，何妨吟啸且徐行","author":"newbieQiu","url":"http://newbieqiu.top","root":"/"},"pages":[{"title":"","date":"2022-04-22T14:53:20.495Z","updated":"2022-04-22T14:53:20.495Z","comments":true,"path":"404/index.html","permalink":"http://newbieqiu.top/404/index.html","excerpt":"","text":"​—title: 404date: 2018-09-30 17:25:30type: “404”layout: “404”description: “Oops～，我崩溃了！找不到你想要的页面 :(“​—"},{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2022-04-22T14:53:55.061Z","comments":true,"path":"about/index.html","permalink":"http://newbieqiu.top/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-09-30T09:25:30.000Z","updated":"2022-04-22T14:51:55.135Z","comments":true,"path":"categories/index.html","permalink":"http://newbieqiu.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2022-04-22T14:54:33.157Z","updated":"2022-04-22T14:54:33.157Z","comments":true,"path":"friends/index.html","permalink":"http://newbieqiu.top/friends/index.html","excerpt":"","text":"title: friendsdate: 2018-12-12 21:25:30type: “friends”layout: “friends”"},{"title":"contact","date":"2018-09-30T09:25:30.000Z","updated":"2022-04-22T14:54:54.207Z","comments":true,"path":"contact/index.html","permalink":"http://newbieqiu.top/contact/index.html","excerpt":"","text":""},{"title":"","date":"2022-04-22T14:54:13.190Z","updated":"2022-04-22T14:54:13.190Z","comments":true,"path":"tags/index.html","permalink":"http://newbieqiu.top/tags/index.html","excerpt":"","text":"​—title: tagsdate: 2018-09-30 18:23:38type: “tags”layout: “tags”​—"}],"posts":[{"title":"Spring源码——Spring模块梳理","slug":"Spring源码——Spring模块梳理","date":"2022-06-28T01:21:41.000Z","updated":"2022-06-28T01:40:39.995Z","comments":true,"path":"2022/06/28/Spring源码——Spring模块梳理/","link":"","permalink":"http://newbieqiu.top/2022/06/28/Spring%E6%BA%90%E7%A0%81%E2%80%94%E2%80%94Spring%E6%A8%A1%E5%9D%97%E6%A2%B3%E7%90%86/","excerpt":"","text":"Spring源码——Spring 模块梳理Spring基础架构图) 重点是“Core Container”中的Beans，Core，Context以及AOP Spring架构 Spring-core IOC&amp;DI(依赖注入) 包含框架的核心工具类，其它组件都要使用到这个包里的类 定义并提供资源的访问方式 Spring-beans：Spring主要面向Bean编程（BOP） *主要注意BeanFacyory这个接口* Bean的定义 Bean的解析 Bean的创建 Spring-context 是bean之间关系的集合 核心接口：ApplicationContext 是BeanFactory的超类 为Spring提供运行时环境，保存对象的状态 **扩展了BeanFactory ** Spring-aop：最小化的动态代理实现，只使用aspectj里的注解功能 JDK动态代理模式：基于接口实现的 Cglib：基于类实现的 共同点：只能运行时织入，仅支持方法级编织，仅支持方法执行切入点 模块之间的依赖可以通过源码里的gradle文件进行查看 spring-aspectj +spring-instrument：Full AspectJ ) weaving 指织入","categories":[{"name":"Spring源码","slug":"Spring源码","permalink":"http://newbieqiu.top/categories/Spring%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"Spring源码","slug":"Spring源码","permalink":"http://newbieqiu.top/tags/Spring%E6%BA%90%E7%A0%81/"}]},{"title":"java8 stream().map().collect()的用法","slug":"java8-stream-map-collect-的用法","date":"2022-06-17T06:21:01.000Z","updated":"2022-06-17T06:29:05.242Z","comments":true,"path":"2022/06/17/java8-stream-map-collect-的用法/","link":"","permalink":"http://newbieqiu.top/2022/06/17/java8-stream-map-collect-%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"java8 中stream().map().collect()的用法List&lt;UserFollowing&gt; fanList = userFollowingDao.getUserFans(userId); Set&lt;Long&gt; fanIdSet = fanList.stream().map(UserFollowing::getUserId).collect(Collectors.toSet()); 有一个集合 fanList 现在想获取User的Id；在后续的逻辑处理中要用； 常用的方法我们大家都知道，用for循环， List id=new ArrayList();//定义一个集合来装 for(int i=0;i&lt;UserFollowing.size();i++){ id.add(UserFollowing.get(i).getUserId()); } 这种方法要写好几行代码，有没有简单点的，如下 Set fanIdSet = fanList.stream().map(UserFollowing::getUserId).collect(Collectors.toSet()); 解释下一这行代码： fanList：一个实体类的集合，类型为ListUserFollowing：实体类getUserId：实体类中的get方法，为获取User的id stream()优点 无存储。stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。为函数式编程而生。对stream的任何修改都不会修改背后的数据源，比如对stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新stream。惰式执行。stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。可消费性。stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。stream().map()方法的使用示例: 再看几个例子：数组字母小写变大写List list= Arrays.asList(“a”, “b”, “c”, “d”); List collect =list.stream().map(String::toUpperCase).collect(Collectors.toList());System.out.println(collect); //[A, B, C, D] 数组所有元素，按某种规律计算：List num = Arrays.asList(1,2,3,4,5);List collect1 = num.stream().map(n -&gt; n * 2).collect(Collectors.toList());System.out.println(collect1); //[2, 4, 6, 8, 10]","categories":[{"name":"java基础","slug":"java基础","permalink":"http://newbieqiu.top/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://newbieqiu.top/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"Springboot集成ElasticSearch入门","slug":"Springboot集成ElasticSearch入门","date":"2022-06-14T07:17:42.000Z","updated":"2022-06-14T07:17:42.045Z","comments":true,"path":"2022/06/14/Springboot集成ElasticSearch入门/","link":"","permalink":"http://newbieqiu.top/2022/06/14/Springboot%E9%9B%86%E6%88%90ElasticSearch%E5%85%A5%E9%97%A8/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"axios使用篇(入门）","slug":"axios使用篇-入门）","date":"2022-06-07T08:38:40.000Z","updated":"2022-06-07T08:56:37.511Z","comments":true,"path":"2022/06/07/axios使用篇-入门）/","link":"","permalink":"http://newbieqiu.top/2022/06/07/axios%E4%BD%BF%E7%94%A8%E7%AF%87-%E5%85%A5%E9%97%A8%EF%BC%89/","excerpt":"","text":"axios的使用（入门篇） 别问，问就是前端代码看不懂来补课了 QAQ 一、axios的特点 在浏览器和node中都可以使用 支持 Promise API 可以拦截请求、响应 转换请求数据、响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 二、使用方法在项目中安装： $ npm install axios ​ 1. 默认配置​ 我们可以给axios设置一个默认的基本配置，里面包括 url、method 等，设置好之后就不用每次添加了。（只有 url 是必需的，如果没有指定 method，请求将默认使用 get 方法。） axios.defaults.baseURL = 'https://api.example.com'; axios.defaults.headers.common['Authorization'] = AUTH_TOKEN; axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 2. 自定义全局配置// 设置配置对象 const configOptions={ baseURL: 'https://api.example.com', timeout:30000, // 超时取消请求 withCredentials: true, // 表示跨域请求时是否需要使用凭证，默认false } //创建实例时，传入配置 const instance = axios.create(configOptions); // 实例创建后更改默认值 axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 注意：配置是有优先级的，这个顺序是：在 lib/defaults.js 找到的库的默认值 &lt; 是实例的 defaults 属性 &lt; 请求的 config 参数。后者将优先于前者。 3. 请求配置{ // `url` 是用于请求的服务器 URL url: '/user', // `method` 是创建请求时使用的方法 method: 'get', // default // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: 'https://some-domain.com/api/', /* `transformRequest`：向服务器发送前，修改请求数据; 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法； 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream */ transformRequest: [function (data, headers) { // 对 data 进行任意转换处理 return data; }], // `transformResponse` 在传递给 then/catch 前，修改响应数据 transformResponse: [function (data) { // 对 data 进行任意转换处理 return data; }], } 官方为了方便起见，给axios的常用方法专门起了别名，可以直接像这样使用：axios.get()，axios.post()，axois.put()等等。请求方法的别名为方便起见，为所有支持的请求方法提供了别名 axios.request(config)axios.get(url[, config])axios.delete(url[, config])axios.head(url[, config])axios.options(url[, config])axios.post(url[, data[, config]])axios.put(url[, data[, config]])axios.patch(url[, data[, config]])注意在使用别名方法时， url、method、data 这些属性都不必在配置中指定。 4.发送get请求get 请求传参可以直接加在地址后，或写在params对象中。 const axios = require('axios').default; // 第一种：直接加在地址后，用问号？传参 axios.get('/user?ID=12345') .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }) .then(function () { // always executed }); // 第二种：在花括号中用params对象传参 axios.get('/user', { params: { ID: 12345 } }) // Want to use async/await? Add the `async` keyword to your outer function/method. async function getUser() { try { const response = await axios.get('/user?ID=12345'); console.log(response); } catch (error) { console.error(error); } } 5.发送post请求axios.post('/user', { firstName: 'Fred', lastName: 'Flintstone' }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); });","categories":[{"name":"前端","slug":"前端","permalink":"http://newbieqiu.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"axios","slug":"前端/axios","permalink":"http://newbieqiu.top/categories/%E5%89%8D%E7%AB%AF/axios/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://newbieqiu.top/tags/%E5%89%8D%E7%AB%AF/"},{"name":"axios","slug":"axios","permalink":"http://newbieqiu.top/tags/axios/"}]},{"title":"SpringCloud入门(Eureka)","slug":"SpringCloud入门-Eureka","date":"2022-06-06T12:16:24.000Z","updated":"2022-06-06T13:24:34.306Z","comments":true,"path":"2022/06/06/SpringCloud入门-Eureka/","link":"","permalink":"http://newbieqiu.top/2022/06/06/SpringCloud%E5%85%A5%E9%97%A8-Eureka/","excerpt":"","text":"SpringCloud入门(Eureka)Spring 概述Spring Cloud是一套组件，如服务治理和发现、配置中心、消息总线、负载均衡、断路器和数据监控等 服务治理和发现：在Spring Cloud中使用Eureka实现服务治理1.先创建一个项目当作Eureka的服务端，并引入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.7&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring.cloud.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 2.在其yaml文件中配置相关的属性 #应用名称 spring.application.name=eureka server #启动端口 server.port=15006 #是否注册到注册中心 eureka.client.register-with-eureka=false #是否检索服务 eureka.client.fetch-registry=false #实例host名称 eureka.instance.hostname=localhost #治理客户端服务域 eureka.client.service-url.defaultZone=http://localhost:15006/eureka/ server说明是服务端 3.在主类上加上注释 @EnableEurekaServer 4.在要注册的项目的pom文件中加入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 注意：若有 mahout依赖会发生包冲突，要除去一些包&lt;!--引入推荐引擎mahout，注意要先全部引入，再使用exclusion标签--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.mahout&lt;/groupId&gt; &lt;artifactId&gt;mahout-mr&lt;/artifactId&gt; &lt;version&gt;0.12.2&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-jcl&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-analyzers-common&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;jersey-client&lt;/artifactId&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;jersey-core&lt;/artifactId&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;jersey-apache-client4&lt;/artifactId&gt; &lt;groupId&gt;com.sun.jersey.contribs&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 在yaml中配置相关信息 spring.application.name=imooc-bilibili-api eureka.client.service-url.defaultZone=http://localhost:15006/eureka/ 6.最后访问上面配置的地址就OK了（服务端的地址）","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://newbieqiu.top/categories/SpringCloud/"},{"name":"Eureka","slug":"SpringCloud/Eureka","permalink":"http://newbieqiu.top/categories/SpringCloud/Eureka/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://newbieqiu.top/tags/SpringCloud/"},{"name":"Eureka","slug":"Eureka","permalink":"http://newbieqiu.top/tags/Eureka/"}]},{"title":"从零开始的Vue生活01(复习)","slug":"从零开始的Vue生活01-复习","date":"2022-05-25T10:56:41.000Z","updated":"2022-05-25T12:18:30.845Z","comments":true,"path":"2022/05/25/从零开始的Vue生活01-复习/","link":"","permalink":"http://newbieqiu.top/2022/05/25/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Vue%E7%94%9F%E6%B4%BB01-%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"开发TodoList&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"inputValue\"&gt; &lt;button v-on:click=\"handleBtnClick\"&gt;提交&lt;/button&gt; &lt;ul&gt; &lt;!-- &lt;li v-for =\"item in list\"&gt;{{item}}&lt;/li&gt; --&gt; &lt;todo-item :content=\"item\" :index =\"index\" v-for=\"(item,index) in list\" v-on:delete=\"handleItemDelete\" &gt;&lt;/todo-item&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var TodoItem ={ props:['content','index'], template:\"&lt;li @click='handleItemClick'&gt;{{content}}&lt;/li&gt;\", methods:{ handleItemClick:function(){ this.$emit(\"delete\",this.index) } } } // Vue.component(\"TodoItem\",{ // props:['content'], // template:\"&lt;li&gt;{{content}}&lt;/li&gt;\" // }) var app =new Vue({ el:\"#app\", components:{TodoItem:TodoItem } , data:{ list:['第一个内容','第二课内容'], inputValue:'' }, methods:{ handleBtnClick: function(){ this.list.push(this.inputValue) this.inputValue='' }, handleItemDelete:function(index){ this.list.splice(index,1) } } }) &lt;/script&gt; &lt;/body&gt; 1.配置对象el挂载点。el为属性，属性值为字符串。表示接管哪一片区域 例如：el: ‘#app’ data—–&gt;实例具体数据data用于创建Vue实例的实例属性。data为方法（常用），也可以为属性（不常用）。 当data为方法时，此方法中必须有返回值，返回值为对象，对象中写属性，属性名即为VM实例的属性名。 methods—–&gt;放置JS方法 2.指令v-for用于遍历数组和对象。item代表每一项。item表示的是列表中的数据， list是data中的列表 例如： v-on为元素绑定事件，简写为 @，与配置对象中的methods配合使用。 在methods配置对象中写的方法，将作为VM实例的方法。 dom元素绑定事件，方法定义在methods 格式： 简写：&lt;button @click=”handler”&gt;单击我加上 v-model用于实现数据的双向绑定，标签类型只能是表单元素（input）。input内容变化，Vue实例里data里的变量值也会跟着改变 Vue底层相当于用value属性实现的。格式： MVP模式（传统）和MVVM模式 M数据层 V视图 P控制器 Presenter是View和Model的中转站 编码的重点在Presenter 其中大部分都是在做dom操作 导致会有很多代码在p层，而mvvm则会自动渲染 mvvm模式： M层数据变化，V层会自动跟着变化。 VM可以监听到M层数据变化去改变V层的数 VM可以监听V层事件触发，调用逻辑代码去改变M层数据，在M层数据变化后又会去把改变的数据映射到V层 MVVM的核心层是M层，VM是Vue写好的不需要关注，V层的变化会根据M层数据的变化而变化。 Vue的生命周期函数1.概念生命周期函数就是Vue实例在某一个时间点会自动执行的函数。共11个函数（常用8个）。 vue的生命周期：创建=&gt;挂载=&gt;更新=&gt;销毁。 注意：Vue的生命周期函数不放在methods方法中，而是直接定义在Vue实例中。 2.所有生命周期函数（1）实例未完全实例化（beforeCreate）此函数是所有生命周期函数中最先执行的，并且只执行一次。在这个钩子函数中，实例并没有完全实例化。 因此响应式数据（写在data里面的属性），在beforeCreate中获取不到，通过this不能访问。并且不能调用methods中的方法。 （2）实例完全实例化（created）此函数只执行一次，在这里可以获取到响应式的数据，因为VM实例完全实例化了。 注意：发送AJAX请求、设置定时器等一次性任务，created速度更快。 （3）实例挂载之前（beforeMount）此函数只执行一次，因为实例还没挂载（渲染），因此不能获取真实DOM节点。 （4）实例挂载完毕（mounted）【重要】此函数只执行一次，这里可以获取到真实的DOM节点（页面渲染完成）。 以后使用AJAX去拉去服务器数据，都是在这里发请求。 （5）响应式数据更新之前（beforeUpdate）当响应式的数据（data里面的）发生变化的时候，会立即执行一次。 （6）响应式数据更新完毕（updated）只要响应式的数据（data里面的）发生变化的时候，就会立即执行一次。 在界面更新之后调用，此时可以访问最新的界面。 如：在浏览器中修改某条数据，也就是重新渲染数据，beforeUpdate和updated都会执行。 （7）销毁之前（beforeDestroy）实例销毁之前调用，此时实例仍然可以正常工作。 使用场景：取消AJAX请求，清除定时器、解绑监听等。 （8）全部销毁（destroyed）实例销毁后调用，实例已经无法正常工作了。 注意：刷新页面并不会触发此生命周期函数，只有关闭页面时才会。 不常用：（9）activated（激活的）每次缓存组件被激活时就会调用。通常与keep-alive结合使用。 （10）deactivated（失活的）缓存的组件停用时调用，可替代destroyed。通常与keep-alive结合使用。 （11）errorCaptured（捕获到错误）Vue的模板语法vue模版语法1、插值表达式：2、v-text：就是innertext，实际上跟插值表达式是一样的3、v-html：就是innerhtml，输出带样式效果4、v-text会进行一次转义，会将标签一起输出，但v-html不会进行转义，只能将内容输出5、：v-指令后面的值为js表达式，除了写js表达式还可以在后面加上字符串 例如： &lt;div v-html=\"name + 'Lee'\"&gt;&lt;/div&gt; Vue的计算属性，方法和侦听器computed：计算属性，有缓存。如果其依赖的数据项没有发生改变就不会重新计算，否则如果其依赖的数据项发生了改变就会触发里面的方法，与其无关的数据变化不会触发计算属性。 methods：方法， 没有缓存，使用时要加上()实现方法的调用，只要数据发生变化就会触发，不管数据就没有关系。（因为是函数的调用，又没有缓存，每调用一次就重新执行一次） watch：监听器，有缓存。功能与computed相似，但是代码复杂。 如果同一个功能，上述三个都可以实现，那么推荐computed，结构简单，性能好。 &lt;body&gt; &lt;div id=\"app\"&gt; {{fullName}} {{age}} &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: \"#app\", data: { firstName: \"Dell\", lastName: \"Lee\", fullName: \"Dell Lee\", age: 28 }, watch: { firstName: function() { console.log(\"计算了一次\"); this.fullName = this.firstName + \" \" + this.lastName; }, lastName: function() { console.log(\"计算了一次\"); this.fullName = this.firstName + \" \" + this.lastName; } } // 方法 // methods: { // fullName: function() { // console.log(\"计算了一次\"); // return this.firstName + \" \" + this.lastName; // } // } // 计算属性 // computed: { // fullName: function() { // console.log(\"计算了一次\"); // return this.firstName + \" \" + this.lastName // } // } }) &lt;/script&gt; &lt;/body&gt; 计算属性的getter和setter方法1.概念getter方法：读取此新属性时，此方法会被执行。setter方法：修改此新属性的属性值，会触发setter方法，参数value即为此属性的属性值。2.基本案例&lt;div id=\"app\"&gt; {{fullName}} &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: \"#app\", data: { firstName: \"Dell\", lastName: \"Lee\" }, computed: { fullName: { get: function () { return this.firstName + \" \" + this.lastName }, // 注意：如果不添加setter方法时，是无法直接修改计算属性的值的。需要通过computed里面的setter方法去修改。 set: function (value) { console.log(value); // 你好 世界 var arr = value.split(\" \"); this.firstName = arr[0]; this.lastName = arr[1]; } } } }) &lt;/script&gt; Vue中的样式绑定1.简介v-bind可以让HTML标签属性的属性值变为动态（响应式的）。 简写为冒号（:）注意：是属性值变成动态，而不是属性名变成动态。 如果是原生语法，其属性值为固定的字符串，而无法改变。 例如：我是一个p标签 格式：我是动态属性值 简写：我是动态属性值 2.案例&lt;style&gt; .activated { color: red } &lt;/style&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 属性值可以写成对象的形式 --&gt; &lt;div @click=\"handleDivClick\" :class=\"{activated : isActivated}\"&gt; Hello world &lt;/div&gt; &lt;!-- 属性值可以直接写变量名的形式 --&gt; &lt;div @click=\"handleDivClick\" :class=\"activated\"&gt; Hello world1 &lt;/div&gt; &lt;!-- 属性值可以写成数组的形式 --&gt; &lt;!-- 实际显示：class=\"iactivated activatedOne\" --&gt; &lt;div @click=\"handleDivClick\" :class=\"[activated , activatedOne]\"&gt; Hello world2 &lt;/div&gt; &lt;!-- 实际显示：style=\"color: black; font-size: 20px;\" --&gt; &lt;div :style=\"[styleObj, {fontSize: '20px'}]\" @click=\"handleDivClick\"&gt; Hello world3 &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: \"#app\", data: { styleObj: { color: \"black\" }, isActivated: false, activated: \"iactivated\", activatedOne: \"activatedOne\" }, methods: { handleDivClick: function () { this.styleObj.color = this.styleObj.color === \"black\" ? \"red\" : \"black\"; this.isActivated = !this.isActivated this.activated = this.activated === \"activated\" ? \"\" : \"activated\" } } }) Vue中的条件渲染v-if = 'show' 如果为false会移除dom结构 为真重新渲染dom结构 v-show='show' //其实相当于display:none和block切换经常切换使用 v-show 效率更高v-if 后边还可以接着写v-else-if v-else，但中间不需要有其他代码，必须紧挨着vue会尽量复用dom结构，如果需要每次都重新渲染 可以给一样的dom标签加上一个不同的key值，这样vue发现key值不一样就会重新渲染dom结果 Vue中的列表循环v-for=”(item.text,index) in list” :key=”item.id” 不建议用index作为key值 可以使用后端返回数据中的id值 传递key值的作用是增强性能 （key值最好是唯一 且不使用index 索引） 操作数据的方式(vue提供可以动态添加数据的方法）改变数据 页面实时响应 1.数组提供的方法pop() 删除数组最后一个元素 push() 可向数组的末尾添加一个或多个元素，并返回新的长度 unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度 shirt() 删除并返回数组的第一个元素 splice() 从数组中添加/删除项目，然后返回被删除的项目，该方法会改变原始数组 sort() 用于对数组的元素进行排序 reverse() 翻转数组 2.更改引用（数组是一个引用类型 更改数组的引用 也可以使数据发生改变）list=[] 将list引用给一个另外的数组 Vue事件处理事件修饰符@click.prevent 阻止事件的默认行为@click.stop 阻止事件冒泡@click.self 点击本身dom才会触发事件 （.self要求，click事件只有在e.target=e.currentTarget的时候才会执行）@click.once 事件只会执行一次，再点击解绑@click.captrue 按照捕获的顺序执行按键修饰符@keydown.enter/tab/esc(按键名） 按键之后才会触发 系统修饰符@keydown.ctrl/shift/meta 按住ctrl等系统修饰符,当按住了@keydown才会执行鼠标修饰符@click.right/left/middle 如：.right鼠标右键点击的时候才会执行 &lt;body&gt; &lt;div id=\"app\"&gt; &lt;div @click.right=\"handleClick\"&gt;click&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: \"#app\", methods: { handleClick: function(e) { console.log(\"right\"); } } }) &lt;/script&gt; &lt;/body&gt; Vue表单绑定通过v-model实现vue表单的双向绑定。1.input 2.textarea 3.checkbox checkbox（复选框true，false） 4.radio radio（单选框，需要给value值，选中则显示） 5.select v-model在select中 如果有value的值指向value的值 =‘1’ 如果没有value指向对应的inner-text = A v-model修饰符v-model.lazy，鼠标失焦（离开input表单）时才改变value v-model.number, 如果输入内容能转换成数字类型，就自动转换 v-model.trim, 去除首尾空格再存入value watch API 与选项式 API this.$watch (以及相应的 watch 选项) 完全等效。watch 需要侦听特定的数据源，并在单独的回调函数中执行副作用。默认情况下，它也是惰性的——即回调仅在侦听源发生变化时被调用。","categories":[{"name":"前端","slug":"前端","permalink":"http://newbieqiu.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"前端/Vue","permalink":"http://newbieqiu.top/categories/%E5%89%8D%E7%AB%AF/Vue/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://newbieqiu.top/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://newbieqiu.top/tags/Vue/"}]},{"title":"RocketMQ 基础篇","slug":"RocketMQ-基础篇","date":"2022-05-17T10:42:23.000Z","updated":"2022-05-17T10:42:23.570Z","comments":true,"path":"2022/05/17/RocketMQ-基础篇/","link":"","permalink":"http://newbieqiu.top/2022/05/17/RocketMQ-%E5%9F%BA%E7%A1%80%E7%AF%87/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"记一次项目所学(中间件等）-动态提醒功能","slug":"记一次项目所学-中间件等）","date":"2022-05-05T04:49:17.000Z","updated":"2022-05-05T14:31:21.111Z","comments":true,"path":"2022/05/05/记一次项目所学-中间件等）/","link":"","permalink":"http://newbieqiu.top/2022/05/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%A1%B9%E7%9B%AE%E6%89%80%E5%AD%A6-%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%AD%89%EF%BC%89/","excerpt":"","text":"记一次项目所学(中间件等）–动态提醒功能订阅发布模式与观察者模式 RocketMQ：纯java编写的开源消息中间件Redis : 高性能缓存工具，数据存储在内存中，读写速度非常快RocketMQ相关工具类及配置实现","categories":[{"name":"springboot","slug":"springboot","permalink":"http://newbieqiu.top/categories/springboot/"},{"name":"项目实战","slug":"springboot/项目实战","permalink":"http://newbieqiu.top/categories/springboot/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://newbieqiu.top/tags/springboot/"},{"name":"项目实战","slug":"项目实战","permalink":"http://newbieqiu.top/tags/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"}]},{"title":"记一次实战项目所学（通用接口篇）","slug":"记一次实战项目所学（通用接口篇）","date":"2022-05-04T11:53:23.000Z","updated":"2022-06-16T06:04:40.109Z","comments":true,"path":"2022/05/04/记一次实战项目所学（通用接口篇）/","link":"","permalink":"http://newbieqiu.top/2022/05/04/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E6%89%80%E5%AD%A6%EF%BC%88%E9%80%9A%E7%94%A8%E6%8E%A5%E5%8F%A3%E7%AF%87%EF%BC%89/","excerpt":"","text":"记一次实战项目所学（通用接口篇）1.加解密工具（AES，RSA，MD5） 账号登录时可用a.引依赖&lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.14&lt;/version&gt; &lt;/dependency&gt; b. AES加密 import org.apache.tomcat.util.codec.binary.Base64; import javax.crypto.Cipher; import javax.crypto.KeyGenerator; import javax.crypto.SecretKey; import java.nio.charset.StandardCharsets; import java.security.SecureRandom; /** * AES: Advanced Encryption Standard 高级加密标准 * 最常见的对称加密算法，即加密和解密使用同样的密钥，加密结果可逆 * 特点：加密速度非常快，适合经常发送数据的场合 * */ public class AESUtil { private static final String KEY_ALGORITHM = \"AES\"; private static final char[] HEX_CHAR = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }; private final Cipher decryptCipher; private final Cipher encryptCipher; private final String seed; public AESUtil(String seed) throws Exception { this.seed = seed; decryptCipher = Cipher.getInstance(KEY_ALGORITHM); encryptCipher = Cipher.getInstance(KEY_ALGORITHM); decryptCipher.init(Cipher.DECRYPT_MODE, this.getSecretKey()); encryptCipher.init(Cipher.ENCRYPT_MODE, this.getSecretKey()); } public String decrypt(String content) throws Exception { byte[] bytes = Base64.decodeBase64(content); byte[] result = decryptCipher.doFinal(bytes); return new String(result, StandardCharsets.UTF_8); } public String encrypt(String content) throws Exception { byte[] result = encryptCipher.doFinal(content.getBytes(StandardCharsets.UTF_8)); return Base64.encodeBase64String(result); } public SecretKey getSecretKey() throws Exception { SecureRandom random = SecureRandom.getInstance(\"SHA1PRNG\"); random.setSeed(seed.getBytes()); KeyGenerator kg = KeyGenerator.getInstance(KEY_ALGORITHM); kg.init(128, random); return kg.generateKey(); } } encrypt 方法用于加密 decrypt 方法用于解密 c. RSA加密import org.apache.commons.codec.binary.Base64; import javax.crypto.Cipher; import java.nio.charset.StandardCharsets; import java.security.*; import java.security.interfaces.RSAPrivateKey; import java.security.interfaces.RSAPublicKey; import java.security.spec.PKCS8EncodedKeySpec; import java.security.spec.X509EncodedKeySpec; /** * RSA加密 * 非对称加密，有公钥和私钥之分，公钥用于数据加密，私钥用于数据解密。加密结果可逆 * 公钥一般提供给外部进行使用，私钥需要放置在服务器端保证安全性。 * 特点：加密安全性很高，但是加密速度较慢 * 用于用户登录场景 */ public class RSAUtil { private static final String PUBLIC_KEY = \"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCQk33iNdA8Iey7J6XrBsidqn6u8EDLWPHsfEUgLQ3qiTikhPKDTzZkpAfU/O0x6NvSKa7Dp0+uqWT3vnW1De0+3u8mCYdVfOdH94VG4xg5U5UrRJei8HhPiXuvKQ+6NBtebCCW5adZ4pBgOiU14cJLhVmm+dYiLo3IDD5LqrlomQIDAQAB\"; private static final String PRIVATE_KEY = \"MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAJCTfeI10Dwh7LsnpesGyJ2qfq7wQMtY8ex8RSAtDeqJOKSE8oNPNmSkB9T87THo29IprsOnT66pZPe+dbUN7T7e7yYJh1V850f3hUbjGDlTlStEl6LweE+Je68pD7o0G15sIJblp1nikGA6JTXhwkuFWab51iIujcgMPkuquWiZAgMBAAECgYA1UT9mciQWWQh9yNRmhXzssFjB2TZ8B5RIe1fe0t7D9NEf0yvAgzDzEo8U3CX5dv/CVL7vxr8bEbt7phCwsa8hJiLEOr7hLZaJzXVTbvfqb91oCZGNkqDQ3NJfGBMVgUmltEYF2Bbk3U0NDyat+Gu54tRd2OH+adJYKsD0XYeDBQJBAN5FE8E04A4FA1q8mQbVTSVJDYIEJwOrdC0r3iZ7za5CyXGk+br8pFalRePFaksRGdN32+mYhDKVNrNHspAObVMCQQCmhBsD+xiWrmpnrzeIfCW1cX8qRC3/RMkq0ACw3l6YedNFdN2Tb5WsRHmcbCI9y8mfLHiG/X1R+zHZKG67EKjjAkAmvAkGSY2mQ89i160fWLq5/bIh71FRPWbgnF15fWfJr4/lgyeWI4MMKn80g2nTrSZACQpE+jRHkGNY+OywWCNLAkEAli5nvztkfeJpDYK2b16pE/B9ZL2BTs3XMcnQFbU5VAPsTKSOgz8MmwZXOIE+kMWP3wPY4McXlC0eVGFnHUh1SQJAeAl3RPk+XbZDMYfPkStRJwocG9Ap+88mwTgR1I7uPzZ1aM84/WsQskiVMXv2SZLmMWvYtnhIKosL6IACp2AcDA==\"; public static void main(String[] args) throws Exception{ String str = RSAUtil.encrypt(\"123456\"); System.out.println(str); } public static String getPublicKeyStr(){ return PUBLIC_KEY; } public static RSAPublicKey getPublicKey() throws Exception { byte[] decoded = Base64.decodeBase64(PUBLIC_KEY); return (RSAPublicKey) KeyFactory.getInstance(\"RSA\") .generatePublic(new X509EncodedKeySpec(decoded)); } public static RSAPrivateKey getPrivateKey() throws Exception { byte[] decoded = Base64.decodeBase64(PRIVATE_KEY); return (RSAPrivateKey) KeyFactory.getInstance(\"RSA\") .generatePrivate(new PKCS8EncodedKeySpec(decoded)); } //获得公钥和私钥 public static RSAKey generateKeyPair() throws NoSuchAlgorithmException { KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(\"RSA\"); keyPairGen.initialize(1024, new SecureRandom()); KeyPair keyPair = keyPairGen.generateKeyPair(); RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate(); RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic(); String publicKeyString = new String(Base64.encodeBase64(publicKey.getEncoded())); String privateKeyString = new String(Base64.encodeBase64(privateKey.getEncoded())); return new RSAKey(privateKey, privateKeyString, publicKey, publicKeyString); } public static String encrypt(String source) throws Exception { byte[] decoded = Base64.decodeBase64(PUBLIC_KEY); RSAPublicKey rsaPublicKey = (RSAPublicKey) KeyFactory.getInstance(\"RSA\") .generatePublic(new X509EncodedKeySpec(decoded)); Cipher cipher = Cipher.getInstance(\"RSA\"); cipher.init(1, rsaPublicKey); return Base64.encodeBase64String(cipher.doFinal(source.getBytes(StandardCharsets.UTF_8))); } public static Cipher getCipher() throws Exception { byte[] decoded = Base64.decodeBase64(PRIVATE_KEY); RSAPrivateKey rsaPrivateKey = (RSAPrivateKey) KeyFactory.getInstance(\"RSA\") .generatePrivate(new PKCS8EncodedKeySpec(decoded)); Cipher cipher = Cipher.getInstance(\"RSA\"); cipher.init(2, rsaPrivateKey); return cipher; } public static String decrypt(String text) throws Exception { Cipher cipher = getCipher(); byte[] inputByte = Base64.decodeBase64(text.getBytes(StandardCharsets.UTF_8)); return new String(cipher.doFinal(inputByte)); } public static class RSAKey { private RSAPrivateKey privateKey; private String privateKeyString; private RSAPublicKey publicKey; public String publicKeyString; public RSAKey(RSAPrivateKey privateKey, String privateKeyString, RSAPublicKey publicKey, String publicKeyString) { this.privateKey = privateKey; this.privateKeyString = privateKeyString; this.publicKey = publicKey; this.publicKeyString = publicKeyString; } public RSAPrivateKey getPrivateKey() { return this.privateKey; } public void setPrivateKey(RSAPrivateKey privateKey) { this.privateKey = privateKey; } public String getPrivateKeyString() { return this.privateKeyString; } public void setPrivateKeyString(String privateKeyString) { this.privateKeyString = privateKeyString; } public RSAPublicKey getPublicKey() { return this.publicKey; } public void setPublicKey(RSAPublicKey publicKey) { this.publicKey = publicKey; } public String getPublicKeyString() { return this.publicKeyString; } public void setPublicKeyString(String publicKeyString) { this.publicKeyString = publicKeyString; } } } 把公钥返回前端，用公钥把前端输入密码进行加密，将暗文返回后端 generateKeyPair用于生成公钥和私钥 encrypt 方法用于加密 （根据公钥） decrypt 方法用于解密 MD5加密 import org.apache.commons.codec.digest.DigestUtils; import java.io.UnsupportedEncodingException; /** * MD5加密 * 单向加密算法 * 特点：加密速度快，不需要秘钥，但是安全性不高，需要搭配随机盐值使用 * */ public class MD5Util { public static String sign(String content, String salt, String charset) { content = content + salt; return DigestUtils.md5Hex(getContentBytes(content, charset)); } public static boolean verify(String content, String sign, String salt, String charset) { content = content + salt; String mysign = DigestUtils.md5Hex(getContentBytes(content, charset)); return mysign.equals(sign); } private static byte[] getContentBytes(String content, String charset) { if (!\"\".equals(charset)) { try { return content.getBytes(charset); } catch (UnsupportedEncodingException var3) { throw new RuntimeException(\"MD5签名过程中出现错误,指定的编码集错误\"); } } else { return content.getBytes(); } } } sign用于加密 （内容，加密盐，编码） verify用于解密 2. Json返回数据类public class JsonResponse&lt;T&gt; { private String code; private String msg; private T data; public String getCode() { return code; } public void setCode(String code) { this.code = code; } public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; } public T getData() { return data; } public void setData(T data) { this.data = data; } public JsonResponse(String code, String msg) { this.code = code; this.msg = msg; } public JsonResponse(T data) { this.data = data; msg=\"成功\"; code=\"0\"; } //不需要返回前端但请求成功 public static JsonResponse&lt;String&gt; success(){ return new JsonResponse&lt;&gt;(null); } public static JsonResponse&lt;String&gt; success(String data){ return new JsonResponse&lt;&gt;(data); } public static JsonResponse&lt;String&gt; fail(){ return new JsonResponse&lt;&gt;(\"1\",\"失败\"); } public static JsonResponse&lt;String&gt; fail(String code ,String msg){ return new JsonResponse&lt;&gt;(code,msg); } } 将 状态码和状态与数据封装 3.Json转化配置（将返回的json搞成看得懂的）引入依赖&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.78&lt;/version&gt; &lt;/dependency&gt; import com.alibaba.fastjson.JSONObject; import com.alibaba.fastjson.serializer.SerializerFeature; import com.alibaba.fastjson.support.config.FastJsonConfig; import com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter; import org.springframework.boot.autoconfigure.http.HttpMessageConverters; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Primary; import java.util.ArrayList; import java.util.List; @Configuration public class JsonHttpMsgConvertConfig { @Bean @Primary public HttpMessageConverters fastJsonHttpMessageConvertes(){ //json转化 FastJsonHttpMessageConverter fastConverter=new FastJsonHttpMessageConverter(); FastJsonConfig fastJsonConfig=new FastJsonConfig(); fastJsonConfig.setDateFormat(\"yyyy-MM-dd HH:mm:ss\"); fastJsonConfig.setSerializerFeatures( SerializerFeature.PrettyFormat, //格式化输出 SerializerFeature.WriteNullStringAsEmpty, //把null值的属性转化为空字符串 SerializerFeature.WriteNullListAsEmpty, //同上 SerializerFeature.WriteMapNullValue, //同上 SerializerFeature.MapSortField, SerializerFeature.DisableCircularReferenceDetect); //禁用循环引用 fastConverter.setFastJsonConfig(fastJsonConfig); return new HttpMessageConverters(fastConverter); } } 4.全局异常处理import com.imooc.bilibili.domain.JsonResponse; import com.imooc.bilibili.domain.except.ConditionException; import org.springframework.core.Ordered; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.ControllerAdvice; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.ResponseBody; import javax.servlet.http.HttpServletRequest; @ControllerAdvice //@ControllerAdvice，是Spring3.2提供的新注解,它是一个Controller增强器,可对controller中被 @RequestMapping注解的方法加一些逻辑处理。最常用的就是异常处理 @Order(Ordered.HIGHEST_PRECEDENCE) public class CommonGlobalExceptionHandler { @ExceptionHandler(value = Exception.class) @ResponseBody //返回参数是responsebody public JsonResponse&lt;String&gt; commonExceptionHandler(HttpServletRequest httpServletRequest,Exception e){ String errorMsg =e.getMessage(); //如果e是condiException类型的话就会有个code状态码 if(e instanceof ConditionException){ String errorCode=((ConditionException)e).getCode(); return new JsonResponse&lt;&gt;(errorCode,errorMsg); }else { return new JsonResponse&lt;&gt;(\"500\",errorMsg); } } } 如果exception是conditionException的话，可以获得一个状态码，再用Json返回数据类返回，用于主动抛出异常，如密码错误等 配置分情况处理异常（ConditionException）补充runtimeException里没有的东西，多了一个code返回值表示状态码。 public class ConditionException extends RuntimeException { private static final long serialVersionUID =1L; //序列版本号 private String code; public ConditionException(String code,String name){ super(name); this.code=code; } public ConditionException(String name){ super(name); code=\"500\"; } public String getCode() { return code; } public void setCode(String code) { this.code = code; } } 5. 登录验证功能先获取公钥准备将前端输入的进行加密 //获得公钥 @GetMapping(\"/rsa-pks\") public JsonResponse&lt;String&gt; getRsaPublicKey(){ String publicKeyStr = RSAUtil.getPublicKeyStr(); return new JsonResponse&lt;&gt;(publicKeyStr); } 新建（注册）一个user（controller层） //新建一个用户 @PostMapping(\"/users\") //@RequestBody 把User 封装成json数据返回 public JsonResponse&lt;String&gt;addUser(@RequestBody User user){ userService.addUser(user); return JsonResponse.success(); } ​ （Service层） @Service public class UserService { @Autowired private UserDao userDao; public void addUser(User user) { String phone = user.getPhone(); if (StringUtils.isNullOrEmpty(phone)) { throw new ConditionException(\"手机号不能为空！\"); } User dbUser = this.getUserByPhone(phone); if (dbUser != null) { throw new ConditionException(\"该手机号已经被注册\"); } //加密需要 Date now = new Date(); //md5需要加密 String salt = String.valueOf(now.getTime()); String password = user.getPassword(); String rawPassword; try { rawPassword = RSAUtil.decrypt(password);//该密码已经通过前端获取的公钥加密 } catch (Exception e) { throw new ConditionException(\"解密失败\"); } String md5Password = MD5Util.sign(rawPassword, salt, \"UTF-8\"); user.setSalt(salt); user.setPassword(md5Password); user.setCreateTime(now); userDao.addUser(user); //添加用户信息(这里有两张表user和userinfo ) UserInfo userInfo = new UserInfo(); userInfo.setUserId(user.getId()); userInfo.setNick(UserConstant.DEFAULT_NICK); userInfo.setBirth(UserConstant.DEFAULT_BIRTH); userInfo.setGender(UserConstant.GENDER_FEMALE); userInfo.setCreateTime(now); userDao.addUserInfo(userInfo); } public User getUserByPhone(String phone) { return userDao.getUserByPhone(phone); } dao层为数据操作不再贴代码啦 用户登录controller //用户登录 @PostMapping(\"/user-tokens\") public JsonResponse&lt;String&gt; login(@RequestBody User user) throws Exception{ String token=userService.login(user); return new JsonResponse&lt;&gt;(token); } service public String login(User user) throws Exception { String phone = user.getPhone(); if (StringUtils.isNullOrEmpty(phone)) { throw new ConditionException(\"手机号不能为空！\");} User dbUser = this.getUserByPhone(phone); if (dbUser == null) { throw new ConditionException(\"当前用户不存在\"); } String password = user.getPassword(); String rowpassword; try { rowpassword = RSAUtil.decrypt(password); } catch (Exception e) { throw new ConditionException(\"密码解密失败\"); } String salt = dbUser.getSalt(); String md5Password = MD5Util.sign(rowpassword, salt, \"UTF-8\"); if (!md5Password.equals(dbUser.getPassword())) { throw new ConditionException(\"密码错误！\"); } return TokenUtil.generateToken(dbUser.getId()); } 前端加密不安全，数据库存入的密码应该是不可逆的，每次认证时候前端传入密码加密后跟后端数据库里密码比对，如果一样密码正确，如果不一样密码不正确，前端加密后传输是怕传输过程被拦截获取到明文密码 因为id是唯一的所以id可以作为token 5.5 基于JWT的用户的token验证 依赖 &lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.18.2&lt;/version&gt; &lt;/dependency&gt; util.token import com.auth0.jwt.JWT; import com.auth0.jwt.JWTVerifier; import com.auth0.jwt.algorithms.Algorithm; import com.auth0.jwt.exceptions.TokenExpiredException; import com.auth0.jwt.interfaces.DecodedJWT; import com.imooc.bilibili.domain.except.ConditionException; import java.util.Calendar; import java.util.Date; public class TokenUtil { private static final String ISSUER=\"签发者\"; //签发者是谁，随意填 public static String generateToken(Long userId) throws Exception{ Algorithm algorithm = Algorithm.RSA256(RSAUtil.getPublicKey(),RSAUtil.getPrivateKey()); Calendar calendar =Calendar.getInstance(); //用于实现过期时间 calendar.setTime(new Date()); calendar.add(Calendar.SECOND,30); //30s过期 return JWT.create().withKeyId(String.valueOf(userId)) .withIssuer(ISSUER) .withExpiresAt(calendar.getTime()) .sign(algorithm); } //解密 public static Long verifyToken(String token) { try{ Algorithm algorithm =Algorithm.RSA256(RSAUtil.getPublicKey(),RSAUtil.getPrivateKey()); JWTVerifier verifier =JWT.require(algorithm).build(); DecodedJWT jwt= verifier.verify(token); String keyId = jwt.getKeyId(); return Long.valueOf(keyId); }catch (TokenExpiredException e){ throw new ConditionException(\"555\",\"token过期！\"); }catch (Exception e){ throw new ConditionException(\"非法用户token\"); } } } 需要一个通用方法，获取token里的userid（一般放在请求头里） import com.imooc.bilibili.domain.except.ConditionException; import com.imooc.bilibili.service.Util.TokenUtil; import org.springframework.stereotype.Component; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes; import javax.servlet.ServletRequest; @Component public class UserSupport { public Long getCurrentUserId(){ //抓取请求上下文,获取token(在请求头中)+ ServletRequestAttributes requestAttributes =(ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); String token =requestAttributes.getRequest().getHeader(\"token\"); Long userId= TokenUtil.verifyToken(token); if(userId&lt;0){ throw new ConditionException(\"非法用户！\"); } return userId; } }","categories":[{"name":"后端项目实战","slug":"后端项目实战","permalink":"http://newbieqiu.top/categories/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"name":"springboot","slug":"后端项目实战/springboot","permalink":"http://newbieqiu.top/categories/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://newbieqiu.top/tags/springboot/"},{"name":"后端项目实战","slug":"后端项目实战","permalink":"http://newbieqiu.top/tags/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"}]},{"title":"从0开始的dp生活——线性dp","slug":"从0开始的dp生活——线性dp","date":"2022-05-03T13:51:08.000Z","updated":"2022-05-04T14:13:48.873Z","comments":true,"path":"2022/05/03/从0开始的dp生活——线性dp/","link":"","permalink":"http://newbieqiu.top/2022/05/03/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84dp%E7%94%9F%E6%B4%BB%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7dp/","excerpt":"","text":"数字三角形模型 #include&lt;iostream&gt; using namespace std; int a[510][510], f[510][510]; //a储存数字三角形，f为从起点到任意点(i,j)的最大路径 int INF = 1e9; int main() { for (int i = 0; i &lt; 510; i++) for (int j = 0; j &lt; 510; j++) f[i][j] = -INF; //a数组中有负数，处理三角形边界时需要使用f的初始值做比较 int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= i; j++) //等边三角形映射为等腰直角三角形后，录入数字三角形数据 cin &gt;&gt; a[i][j]; f[1][1] = a[1][1]; //起点到起点的最短距离为a[1][1]，其他f默认值为-INF，必须手动设置f[1][1] for (int i = 2; i &lt;= n; i++) for (int j = 1; j &lt;= i; j++) f[i][j] = max(f[i - 1][j - 1], f[i - 1][j]) + a[i][j]; //dynamic programming for (int i = 2; i &lt;= n; i++) f[n][1] = max(f[n][1], f[n][i]); //起点到最后一排的各点值的最大值中，选取最大值的最大值 cout &lt;&lt; f[n][1]; } 题目描述给定一个 n×m 的矩阵，起点位置在 (1,1)，终点位置是 (n,m)接着给定该矩阵上，每个位置(x,y)上的物品的价值w现需要我们制定一个方案： 从起点出发，只能向右或向下走，如何走到终点，才能使经过的所有格子的物品总价值最大 题解这题是一道标准的动态规划问题，模型是数字三角形 我们先来分析一下 如果要进行动态规划，则用来表示当前状态的参数有哪些？ 当前走到第i行当前走到第j列于是乎，我们可以开二维数组f(i,j) 来存储当前在i行j列的状态 而f[i,j]的值，就是表示从起点走到该点经过的所有格子的价值总和的最大值 则最终答案的状态就是f(n,m) 然后再考虑状态转移方程 因为限制了只能向右或向下走，因此当前状态f(i,j)只能由f(i-1,j)或f[(i,j-1)(只能向右或向下走)转移过来 闫氏DP分析法状态表示f(i,j) 属性:从起点出发，走到第i行第j列的所有方案 集合:方案中的路线经过的所有物品的总价值最大Max状态转移 f(i,j)=max{f(i−1,j),f(i,j−1)}+w(i,j) #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; const int N =110; int dp[N][N]; int map[N][N]; int main(){ int t; cin&gt;&gt;t ; while(t--){ int m,n; cin&gt;&gt;m&gt;&gt;n; for(int i=1;i&lt;=m;i++){ for(int j=1;j&lt;=n;j++){ cin&gt;&gt;map[i][j]; } } for(int i=1;i&lt;=m;i++){ for(int j=1;j&lt;=n;j++){ dp[i][j]=max(dp[i-1][j],dp[i][j-1])+map[i][j]; } } cout&lt;&lt;dp[m][n]&lt;&lt;endl; } return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"http://newbieqiu.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"http://newbieqiu.top/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://newbieqiu.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://newbieqiu.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"从0开始的英语生活——词根","slug":"从0开始的英语生活——词根","date":"2022-05-03T13:29:55.000Z","updated":"2022-05-03T13:48:38.415Z","comments":true,"path":"2022/05/03/从0开始的英语生活——词根/","link":"","permalink":"http://newbieqiu.top/2022/05/03/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E8%8B%B1%E8%AF%AD%E7%94%9F%E6%B4%BB%E2%80%94%E2%80%94%E8%AF%8D%E6%A0%B9/","excerpt":"","text":"词根篇前缀定方向，后缀定词性，词根定词义1. ced/cess =go 行走precede v先于 precedent 先例 unprecedentedly 史无前例的 recede 后退v recession 经济衰退 intercede 调停v exceed 超过 excess excessive 过分的 access 2.-cid，cis =cut ,kill 切，杀decide concise 简洁的 precise 精确的 ~to be more precise 更精确地说 suicide 自杀 pesticide 杀虫剂 3. claim=cry，shout 喊叫exclaim proclaim 宣告公布v declaim 演讲v reclaim v.收回开拓 acclaim v 称赞 4. clud，clus =close 关闭seclude v使隔绝 conclude 5. dec/dect = lead 引导conduct 指挥 seduce 勾引 6.fer =bring 拿ferry 轮渡，渡 differ differentiate 7.ject，jet =throw 投掷subject 主题话题 / 受影响的 project v抛出 8.migr =move 迁移emigrate 移居国外 immigrate 移居国内 9.pend/pens花费penny 美分 pension 退休金 compensate 赔偿 expenditure 花费n 10.pos=putexpose compose dispose 布置，处理（dis不同方向） propose 提议，求婚 impose 强加 11.rupt =break 破bankrupt 破产 disrupt 使混乱 corrupt 腐败 12. spect =look看prospect 前景 suspect spectator 观众 13.tract =draw 拉，引tractor 拖拉机 contract 合同契约 extract 提取 14.vert/vers =turn 转动reserve extrovert 外向的人 introvert 内向的人 15.vis/vid =see(visit)revise previse 预知 supervise 监督 evident 16.viv =live 活，生命revive vivid 生动的 vital 重要的","categories":[{"name":"英语","slug":"英语","permalink":"http://newbieqiu.top/categories/%E8%8B%B1%E8%AF%AD/"},{"name":"构词法","slug":"英语/构词法","permalink":"http://newbieqiu.top/categories/%E8%8B%B1%E8%AF%AD/%E6%9E%84%E8%AF%8D%E6%B3%95/"}],"tags":[{"name":"英语","slug":"英语","permalink":"http://newbieqiu.top/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"构词法","slug":"构词法","permalink":"http://newbieqiu.top/tags/%E6%9E%84%E8%AF%8D%E6%B3%95/"}]},{"title":"从0开始的英语学习——后缀","slug":"从0开始的英语生活——后缀篇","date":"2022-05-03T12:59:02.000Z","updated":"2022-05-03T13:29:16.830Z","comments":true,"path":"2022/05/03/从0开始的英语生活——后缀篇/","link":"","permalink":"http://newbieqiu.top/2022/05/03/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E8%8B%B1%E8%AF%AD%E7%94%9F%E6%B4%BB%E2%80%94%E2%80%94%E5%90%8E%E7%BC%80%E7%AF%87/","excerpt":"","text":"后缀篇前缀定方向，后缀定词性，词根定词义1.-able 能的，具有…性质的 adjadaptable 可适应的 2.-al 具有..性质的，属性…的regional 地区的 2.-al 名词后缀 ，“人”refusal criminal 3. -ate 做，造成generate v.造成 （gene 基因） activate v.激活 dictate v.口述 accelerate v. 加速 （acc强调，ele速度） differentiate v.区分 demonstrate v演示，证明（demon小样） 3. ate后缀 …的人candidate advocate electorate n.全体选民 3. -ate 形容词后缀 …的fortunate innate adj.天生的 moderate adj.适度的，中等的 legitimate adj.合法的 4. -ed 已….的，被…的extended 延伸的 married 已婚的 5. -en v.后缀 使…变成shorten threaten enlighten 启蒙 6. ence 抽象名词confidence dependence 7. -ful 富有，具有…性质的useful powerful 强大的 8. -ify -fy 使变成purity v净化 identify v.确认 personify v.拟人 modify v.调整 9. -ic …的historic adj. systematic 系统的 historic 历史上著名的 historical 历史的classic 经典的 classical 古文化的，古典的可见 -al 强调时间 -ic 强调意义10.-ion 抽象名词discussion n讨论 11. -ism ..主义，流派，特性individualism 个人主义 capitalism 资本主义 modernism 现代主义 humanism 人道主义 Marxism 马克思主义 12. -ist …人communist 共产主义者 hobbyist业余爱好者 13 -ive 具有..性质的innovative 革新的 （no -new) 14. -ize 化centralize romanticize 浪漫化 15. -less 无..的hopeless 16. -ment 物attachment n附件 basement 地下室n 17. -ness 抽象名词darkness 18. -ship情况.关系hardship 艰难 18. -ship 身份kingship 王权 membership 会员 ownership 所有权 co-authorship 合作者身份 19. -ward 向…的，朝download 20. -y 多的wordy 冗长的 icy 冰冷的 20.-y抽象名词injury 伤 jealousy 嫉妒 mastery 精通","categories":[{"name":"构词法","slug":"构词法","permalink":"http://newbieqiu.top/categories/%E6%9E%84%E8%AF%8D%E6%B3%95/"},{"name":"英语","slug":"构词法/英语","permalink":"http://newbieqiu.top/categories/%E6%9E%84%E8%AF%8D%E6%B3%95/%E8%8B%B1%E8%AF%AD/"}],"tags":[{"name":"英语","slug":"英语","permalink":"http://newbieqiu.top/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"构词法","slug":"构词法","permalink":"http://newbieqiu.top/tags/%E6%9E%84%E8%AF%8D%E6%B3%95/"}]},{"title":"从0开始的英语生活——前缀篇","slug":"从0开始的英语生活——前缀篇","date":"2022-04-28T08:20:10.000Z","updated":"2022-04-28T09:05:33.510Z","comments":true,"path":"2022/04/28/从0开始的英语生活——前缀篇/","link":"","permalink":"http://newbieqiu.top/2022/04/28/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E8%8B%B1%E8%AF%AD%E7%94%9F%E6%B4%BB%E2%80%94%E2%80%94%E5%89%8D%E7%BC%80%E7%AF%87/","excerpt":"","text":"前缀篇前缀定方向，后缀定词性，词根定词义1. ab - 离去，想法，不（消极意思）abnormal 反常的，变态的 adj abuse 滥用，虐待 n/v 2.anti - 反对，相反antiwar 反战的 antiaging 防衰老的 antiforeign 排外的 antinoise 抗噪音的 antibiotics 抗生素 n（biotic像biology） antitrust 反垄断的 （trust为托拉斯，垄断组织） 3.a+双写首字母 - 加强，强调作用account 账目，存款 n attract 吸引（tract的词根意为拉） assimilate 同化 v affluent 富裕的 adj（强调富得流油） 4. co-/col-/con/com- 一起cooperation collaboration 合作（labor为劳动，一起劳动） contribute 贡献（bute为贡品）v 5. counter - 反对，相反counterattack 反击n/v countereffect 反效果n counterpart 相对应的n counterfeit 仿制（feit，fict，fact词根为制造） 6.de- 否定，除去，向下denationlize 非国有化v decompose 分解v（com一起，pose放置） deforest 砍伐树林 devastating 毁灭性的（vast巨大的，巨大的东西掉下来了） deception 欺骗（cep词根 来） derive 起源 7. dis- 否定，除去，分开discover 发现 disease 疾病 disorder 无秩序n distract 分心 dismiss (解雇，清除)不再miss她 disposal 清理 pos词根为放置 8.ex- 外，前任的export 出口v,n ex-boyfriend expression 表情表达（向外压） 9. fore 前，先，预先forehead 前额（头的前面） forefather 祖先 foresee 预知 forerunner 先驱 10. in,im- 向里，否定，加强indoor adj室内的 inbreathe 吸入 incorrect intense（加强，延伸） 热情的 immerge 浸入v impose 强加，征税（放） impluse 冲动（加强，推） 11. mis- 错误，坏mismanagement 管理不当n misfortune 不幸 12.out- 超过，外outlet 出口 outperform v表现得更好 13.over- 过度overstatement 夸大n overemphasize 过分强调n 14.post- 后postwar 战后的 postpone 推后（pon为放） postgraduate 研究生n post-disaster 灾后生活 15. pre -前（时间上的前）prehistory 史前的 precondition 前提条件 precedent 先例 n（ced 超过) 16. pro - 空间上的前progress （gress为go）进步 n prolong 延长v propel 推进，促使v（pel-推） propose 提议，求婚（pose 拿put） 17. re- 向后，再一次return recall 召回，记得 regress 倒退v 18. sub- 下，下级subaverage 低于平均值v suburb 郊区 subconsciously =without knowing it (不易察觉的) –意识向下 19. trans - 转移（from A to B)transform transplant 移植 20. mono 一monotone 单调 monodrama 独角戏 monologue 独白 bi- 二bicycle （两个轮子） bilateral 双边的adj di- 二dioxide divorce tri - 三triangle trike 三轮车 hemi - 半hemisphere 半球 hemicycle 半圆形 semi- 半（抽象）semifinal 半决赛 poly- multi- 多monopoly 垄断（1个有多个） polytechnic 理工学院 multi-media","categories":[{"name":"英语","slug":"英语","permalink":"http://newbieqiu.top/categories/%E8%8B%B1%E8%AF%AD/"}],"tags":[{"name":"英语","slug":"英语","permalink":"http://newbieqiu.top/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"构词法","slug":"构词法","permalink":"http://newbieqiu.top/tags/%E6%9E%84%E8%AF%8D%E6%B3%95/"}]},{"title":"最短路算法之 bellman_ford 算法","slug":"最短路算法之-bellman-ford-算法","date":"2022-04-27T11:22:17.000Z","updated":"2022-04-27T12:00:38.500Z","comments":true,"path":"2022/04/27/最短路算法之-bellman-ford-算法/","link":"","permalink":"http://newbieqiu.top/2022/04/27/%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95%E4%B9%8B-bellman-ford-%E7%AE%97%E6%B3%95/","excerpt":"","text":"最短路算法之 bellman_ford算法bellman_ford 算法的时间复杂度为o（n*m），一般用在存在负权边的情况。存在负权边的情况bellman_ford 算法和 SPFA算法都可以使用 ，但SPFA算法会优于改算法，但有一种情况下不能代替。即题目中出现有边数限制的最短路。模板题思路 代码#include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; const int N = 510, M = 10010; struct Edge { int a; int b; int w; } e[M];//把每个边保存下来即可 int dist[N]; int back[N];//备份数组防止串联 int n, m, k;//k代表最短路径最多包涵k条边 int bellman_ford() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i &lt; k; i++) {//k次循环 memcpy(back, dist, sizeof dist); for (int j = 0; j &lt; m; j++) {//遍历所有边 int a = e[j].a, b = e[j].b, w = e[j].w; dist[b] = min(dist[b], back[a] + w); //使用backup:避免给a更新后立马更新b, 这样b一次性最短路径就多了两条边出来 } } if (dist[n] &gt; 0x3f3f3f3f / 2) return -1; else return dist[n]; } int main() { scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for (int i = 0; i &lt; m; i++) { int a, b, w; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;w); e[i] = {a, b, w}; } int res = bellman_ford(); if (res == -1) puts(\"impossible\"); else cout &lt;&lt; res; return 0; } 一些小细节为什么是dist[n]&gt;0x3f3f3f3f/2， 而不是dist[n]==0x3f3f3f3f5号节点距离起点的距离是无穷大，利用5号节点更新n号节点距离起点的距离，将得到109−2109−2, 虽然小于109109, 但并不存在最短路，(在边数限制在k条的条件下)。 为什么需要back[a]数组为了避免如下的串联情况， 在边数限制为一条的情况下，节点3的距离应该是3，但是由于串联情况，利用本轮更新的节点2更新了节点3的距离，所以现在节点3的距离是2。 正确做法是用上轮节点2更新的距离–无穷大，来更新节点3， 再取最小值，所以节点3离起点的距离是3。","categories":[{"name":"算法","slug":"算法","permalink":"http://newbieqiu.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"最短路","slug":"算法/最短路","permalink":"http://newbieqiu.top/categories/%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}],"tags":[]},{"title":"最短路之 Dijkstra 算法","slug":"最短路之-Dijstra-算法","date":"2022-04-26T04:02:29.000Z","updated":"2022-04-26T07:54:48.756Z","comments":true,"path":"2022/04/26/最短路之-Dijstra-算法/","link":"","permalink":"http://newbieqiu.top/2022/04/26/%E6%9C%80%E7%9F%AD%E8%B7%AF%E4%B9%8B-Dijstra-%E7%AE%97%E6%B3%95/","excerpt":"","text":"最短路之 Dijkstra 算法（朴素做法）时间复杂度 O(n2)没什么好说的先上模板题Dijkstra算法(用于稀疏图) 总结来说就是以下的几步：1.初始化距离 dist[1]=0 dist[i] =无穷大2. for( i=1 到 n)2.1 找t不在s中的距离最近的点2.2 讲 t加入到 s中2.3 用t更新到其他点的距离#include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; const int N=510; int g[N][N]; //为稠密阵所以用邻接矩阵存储 int dist[N]; //用于记录每一个点距离第一个点的距离 bool st[N]; //用于记录该点的最短距离是否已经确定 int n,m; int Dijkstra() { memset(dist, 0x3f,sizeof dist); //初始化距离 0x3f代表无限大 dist[1]=0; //第一个点到自身的距离为0 for(int i=0;i&lt;n;i++) //有n个点所以要进行n次 迭代 { int t=-1; //t存储当前访问的点 for(int j=1;j&lt;=n;j++) //这里的j代表的是从1号点开始 if(!st[j]&amp;&amp;(t==-1|| dist[t]&gt;dist[j]) ) t=j; st[t]=true; for(int j=1;j&lt;=n;j++) //依次更新每个点所到相邻的点路径值 dist[j]=min(dist[j],dist[t]+g[t][j]); //这里可能有同学要问j如果从1开始的话 会不会影响之前已经确定的点的最小距离 //但其实是不会 因为按照我们的Dijkstra算法的操作顺序 先确定最短距离的点的距离已经比后确定的要小 所以不会影响 //当然你也可以在循环判断条件里加上if(!st[i]) //这里j从1开始只是为了代码的简洁 } if(dist[n]==0x3f3f3f3f) return -1; //如果第n个点路径为无穷大即不存在最低路径 return dist[n]; } int main() { cin&gt;&gt;n&gt;&gt;m; memset(g,0x3f,sizeof g); //初始化图 因为是求最短路径 //所以每个点初始为无限大 while(m--) { int x,y,z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; g[x][y]=min(g[x][y],z); //如果发生重边的情况则保留最短的一条边 } cout&lt;&lt;Dijkstra()&lt;&lt;endl; return 0; } Dijkstra算法（堆优化版）用于稠密图，时间复杂度O(mlog(n)) m为变数n为点数模板题：堆优化版模板题 思路1.一号点的距离初始化为零，其他点初始化成无穷大。2.将一号点放入堆中。3.不断循环，直到堆空。每一次循环中执行的操作为：弹出堆顶（与朴素版diijkstra找到S外距离最短的点相同，并标记该点的最短路径已经确定）。用该点更新临界点的距离，若更新成功就加入到堆中。for(i:1 ~ n)//n次 { t &lt;- 没有确定最短路径的节点中距离源点最近的点;//每次遍一遍历dist数组，n次的复杂度是O(n^2) state[t] = 1; 更新 dist;//每次遍历一个节点的出边，n次遍历了所有节点的边，复杂度为O(e) } #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; typedef pair&lt;int, int&gt; PII; const int N = 100010; // 把N改为150010就能ac // 稀疏图用邻接表来存 int h[N], e[N], ne[N], idx; int w[N]; // 用来存权重 int dist[N]; bool st[N]; // 如果为true说明这个点的最短路径已经确定 int n, m; void add(int x, int y, int c) { w[idx] = c; // 有重边也不要紧，假设1-&gt;2有权重为2和3的边，再遍历到点1的时候2号点的距离会更新两次放入堆中 e[idx] = y; // 这样堆中会有很多冗余的点，但是在弹出的时候还是会弹出最小值2+x（x为之前确定的最短路径），并 ne[idx] = h[x]; // 标记st为true，所以下一次弹出3+x会continue不会向下执行。 h[x] = idx++; } int dijkstra() { memset(dist, 0x3f, sizeof(dist)); dist[1] = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; // 定义一个小根堆 // 这里heap中为什么要存pair呢，首先小根堆是根据距离来排的，所以有一个变量要是距离，其次在从堆中拿出来的时 // 候要知道知道这个点是哪个点，不然怎么更新邻接点呢？所以第二个变量要存点。 heap.push({ 0, 1 }); // 这个顺序不能倒，pair排序时是先根据first，再根据second，这里显然要根据距离排序 while(heap.size()) { PII k = heap.top(); // 取不在集合S中距离最短的点 heap.pop(); int ver = k.second, distance = k.first; if(st[ver]) continue; st[ver] = true; for(int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; // i只是个下标，e中在存的是i这个下标对应的点。 if(dist[j] &gt; distance + w[i]) { dist[j] = distance + w[i]; heap.push({ dist[j], j }); } } } if(dist[n] == 0x3f3f3f3f) return -1; else return dist[n]; } int main() { memset(h, -1, sizeof(h)); scanf(\"%d%d\", &amp;n, &amp;m); while (m--) { int x, y, c; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;c); add(x, y, c); } cout &lt;&lt; dijkstra() &lt;&lt; endl; return 0; } ps：不用continue不会影响后面的取值，因为有dis[j]&gt;distance+w[i]的判断，一定会更新成最小的那个，只不过就是把这个点的邻接点又加进去判断了而已，多了几次for循环，加上continue会减少这个判断，不加continue会超时，不会答案错误。","categories":[{"name":"算法","slug":"算法","permalink":"http://newbieqiu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://newbieqiu.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://newbieqiu.top/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"Mybatis Plus笔记(1)","slug":"Mybatis-Plus笔记-1","date":"2022-04-25T09:56:51.000Z","updated":"2022-04-25T10:47:10.065Z","comments":true,"path":"2022/04/25/Mybatis-Plus笔记-1/","link":"","permalink":"http://newbieqiu.top/2022/04/25/Mybatis-Plus%E7%AC%94%E8%AE%B0-1/","excerpt":"","text":"初始化引入依赖(Springboot方式启动)&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 配置yml文件spring: # 配置数据源信息 datasource: # 配置数据源类型 type: com.zaxxer.hikari.HikariDataSource # 配置连接数据库信息 driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false username: root password: 123456 8.0加上这句在问号后面加上 serverTimezone=GMT%2B8&amp; 启动类在Spring Boot启动类中添加@MapperScan注解，扫描mapper包日志添加# 配置MyBatis日志 mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl 基本的CRUD操作批量删除@Test public void testDeleteBatchIds(){ //通过多个id批量删除 //DELETE FROM user WHERE id IN ( ? , ? , ? ) List&lt;Long&gt; idList = Arrays.asList(1L, 2L, 3L); int result = userMapper.deleteBatchIds(idList); System.out.println(\"受影响行数：\"+result); } 通过Map删除@Test public void testDeleteByMap(){ //根据map集合中所设置的条件删除记录 //DELETE FROM user WHERE name = ? AND age = ? Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"age\", 23); map.put(\"name\", \"张三\"); int result = userMapper.deleteByMap(map); System.out.println(\"受影响行数：\"+result); } 查询的map和批量查大同小异，这里不再一一赘述 。最后不要忘了 Mapper接口继承 BaseMapper 哦！！自定义接口在不改yaml文件的情况下默认把xml文件放在Mapper包下或者其子包下（或者可以在yaml文件下设置mapper-locations: classpath:/mapper/Usermapper.xml 记得在主加载类上加@Mapperscan 扫描 ！！！","categories":[],"tags":[{"name":"mybatisPlus","slug":"mybatisPlus","permalink":"http://newbieqiu.top/tags/mybatisPlus/"}]},{"title":"Mybatis 复习(一对多多对一)","slug":"Mybatis-复习-一对多多对一","date":"2022-04-24T09:44:33.000Z","updated":"2022-04-24T09:50:34.967Z","comments":true,"path":"2022/04/24/Mybatis-复习-一对多多对一/","link":"","permalink":"http://newbieqiu.top/2022/04/24/Mybatis-%E5%A4%8D%E4%B9%A0-%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%A4%9A%E5%AF%B9%E4%B8%80/","excerpt":"","text":"自定义映射resultMapresultMap处理字段和属性的映射关系 resultMap：设置自定义映射 属性： id：表示自定义映射的唯一标识，不能重复 type：查询的数据要映射的实体类的类型 子标签： id：设置主键的映射关系 result：设置普通字段的映射关系 子标签属性： property：设置映射关系中实体类中的属性名 column：设置映射关系中表中的字段名 若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射，即使字段名和属性名一致的属性也要映射，也就是全部属性都要列出来 &lt;resultMap id=\"empResultMap\" type=\"Emp\"&gt; &lt;id property=\"eid\" column=\"eid\"&gt;&lt;/id&gt; &lt;result property=\"empName\" column=\"emp_name\"&gt;&lt;/result&gt; &lt;result property=\"age\" column=\"age\"&gt;&lt;/result&gt; &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"email\" column=\"email\"&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;!--List&lt;Emp&gt; getAllEmp();--&gt; &lt;select id=\"getAllEmp\" resultMap=\"empResultMap\"&gt; select * from t_emp &lt;/select&gt; 若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用_），实体类中的属性名符合Java的规则（使用驼峰）。此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系 可以通过为字段起别名的方式，保证和实体类中的属性名保持一致 &lt;!--List&lt;Emp&gt; getAllEmp();--&gt; &lt;select id=\"getAllEmp\" resultType=\"Emp\"&gt; select eid,emp_name empName,age,sex,email from t_emp &lt;/select&gt; 可以在MyBatis的核心配置文件中的setting标签中，设置一个全局配置信息mapUnderscoreToCamelCase，可以在查询表中数据时，自动将_类型的字段名转换为驼峰，例如：字段名user_name，设置了mapUnderscoreToCamelCase，此时字段名就会转换为userName。核心配置文件详解 &lt;settings&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;/settings&gt; 多对一映射处理 查询员工信息以及员工所对应的部门信息 public class Emp { private Integer eid; private String empName; private Integer age; private String sex; private String email; private Dept dept; //...构造器、get、set方法等 } 级联方式处理映射关系&lt;resultMap id=\"empAndDeptResultMapOne\" type=\"Emp\"&gt; &lt;id property=\"eid\" column=\"eid\"&gt;&lt;/id&gt; &lt;result property=\"empName\" column=\"emp_name\"&gt;&lt;/result&gt; &lt;result property=\"age\" column=\"age\"&gt;&lt;/result&gt; &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"email\" column=\"email\"&gt;&lt;/result&gt; &lt;result property=\"dept.did\" column=\"did\"&gt;&lt;/result&gt; &lt;result property=\"dept.deptName\" column=\"dept_name\"&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;!--Emp getEmpAndDept(@Param(\"eid\")Integer eid);--&gt; &lt;select id=\"getEmpAndDept\" resultMap=\"empAndDeptResultMapOne\"&gt; select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #{eid} &lt;/select&gt; 使用association处理映射关系 association：处理多对一的映射关系 property：需要处理多对的映射关系的属性名 javaType：该属性的类型 &lt;resultMap id=\"empAndDeptResultMapTwo\" type=\"Emp\"&gt; &lt;id property=\"eid\" column=\"eid\"&gt;&lt;/id&gt; &lt;result property=\"empName\" column=\"emp_name\"&gt;&lt;/result&gt; &lt;result property=\"age\" column=\"age\"&gt;&lt;/result&gt; &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"email\" column=\"email\"&gt;&lt;/result&gt; &lt;association property=\"dept\" javaType=\"Dept\"&gt; &lt;id property=\"did\" column=\"did\"&gt;&lt;/id&gt; &lt;result property=\"deptName\" column=\"dept_name\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;!--Emp getEmpAndDept(@Param(\"eid\")Integer eid);--&gt; &lt;select id=\"getEmpAndDept\" resultMap=\"empAndDeptResultMapTwo\"&gt; select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #{eid} &lt;/select&gt; 分步查询1. 查询员工信息 select：设置分布查询的sql的唯一标识（namespace.SQLId或mapper接口的全类名.方法名） column：设置分步查询的条件 //EmpMapper里的方法 /** * 通过分步查询，员工及所对应的部门信息 * 分步查询第一步：查询员工信息 * @param * @return com.atguigu.mybatis.pojo.Emp * @date 2022/2/27 20:17 */ Emp getEmpAndDeptByStepOne(@Param(\"eid\") Integer eid); &lt;resultMap id=\"empAndDeptByStepResultMap\" type=\"Emp\"&gt; &lt;id property=\"eid\" column=\"eid\"&gt;&lt;/id&gt; &lt;result property=\"empName\" column=\"emp_name\"&gt;&lt;/result&gt; &lt;result property=\"age\" column=\"age\"&gt;&lt;/result&gt; &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"email\" column=\"email\"&gt;&lt;/result&gt; &lt;association property=\"dept\" select=\"com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo\" column=\"did\"&gt;&lt;/association&gt; &lt;/resultMap&gt; &lt;!--Emp getEmpAndDeptByStepOne(@Param(\"eid\") Integer eid);--&gt; &lt;select id=\"getEmpAndDeptByStepOne\" resultMap=\"empAndDeptByStepResultMap\"&gt; select * from t_emp where eid = #{eid} &lt;/select&gt; 2. 查询部门信息//DeptMapper里的方法 /** * 通过分步查询，员工及所对应的部门信息 * 分步查询第二步：通过did查询员工对应的部门信息 * @param * @return com.atguigu.mybatis.pojo.Emp * @date 2022/2/27 20:23 */ Dept getEmpAndDeptByStepTwo(@Param(\"did\") Integer did); &lt;!--此处的resultMap仅是处理字段和属性的映射关系--&gt; &lt;resultMap id=\"EmpAndDeptByStepTwoResultMap\" type=\"Dept\"&gt; &lt;id property=\"did\" column=\"did\"&gt;&lt;/id&gt; &lt;result property=\"deptName\" column=\"dept_name\"&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;!--Dept getEmpAndDeptByStepTwo(@Param(\"did\") Integer did);--&gt; &lt;select id=\"getEmpAndDeptByStepTwo\" resultMap=\"EmpAndDeptByStepTwoResultMap\"&gt; select * from t_dept where did = #{did} &lt;/select&gt; 一对多映射处理public class Dept { private Integer did; private String deptName; private List&lt;Emp&gt; emps; //...构造器、get、set方法等 } collection collection：用来处理一对多的映射关系 ofType：表示该属性对饮的集合中存储的数据的类型 &lt;resultMap id=\"DeptAndEmpResultMap\" type=\"Dept\"&gt; &lt;id property=\"did\" column=\"did\"&gt;&lt;/id&gt; &lt;result property=\"deptName\" column=\"dept_name\"&gt;&lt;/result&gt; &lt;collection property=\"emps\" ofType=\"Emp\"&gt; &lt;id property=\"eid\" column=\"eid\"&gt;&lt;/id&gt; &lt;result property=\"empName\" column=\"emp_name\"&gt;&lt;/result&gt; &lt;result property=\"age\" column=\"age\"&gt;&lt;/result&gt; &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"email\" column=\"email\"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!--Dept getDeptAndEmp(@Param(\"did\") Integer did);--&gt; &lt;select id=\"getDeptAndEmp\" resultMap=\"DeptAndEmpResultMap\"&gt; select * from t_dept left join t_emp on t_dept.did = t_emp.did where t_dept.did = #{did} &lt;/select&gt; 分步查询1. 查询部门信息/** * 通过分步查询，查询部门及对应的所有员工信息 * 分步查询第一步：查询部门信息 * @param did * @return com.atguigu.mybatis.pojo.Dept * @date 2022/2/27 22:04 */ Dept getDeptAndEmpByStepOne(@Param(\"did\") Integer did); &lt;resultMap id=\"DeptAndEmpByStepOneResultMap\" type=\"Dept\"&gt; &lt;id property=\"did\" column=\"did\"&gt;&lt;/id&gt; &lt;result property=\"deptName\" column=\"dept_name\"&gt;&lt;/result&gt; &lt;collection property=\"emps\" select=\"com.atguigu.mybatis.mapper.EmpMapper.getDeptAndEmpByStepTwo\" column=\"did\"&gt;&lt;/collection&gt; &lt;/resultMap&gt; &lt;!--Dept getDeptAndEmpByStepOne(@Param(\"did\") Integer did);--&gt; &lt;select id=\"getDeptAndEmpByStepOne\" resultMap=\"DeptAndEmpByStepOneResultMap\"&gt; select * from t_dept where did = #{did} &lt;/select&gt; 2. 根据部门id查询部门中的所有员工/** * 通过分步查询，查询部门及对应的所有员工信息 * 分步查询第二步：根据部门id查询部门中的所有员工 * @param did * @return java.util.List&lt;com.atguigu.mybatis.pojo.Emp&gt; * @date 2022/2/27 22:10 */ List&lt;Emp&gt; getDeptAndEmpByStepTwo(@Param(\"did\") Integer did); &lt;!--List&lt;Emp&gt; getDeptAndEmpByStepTwo(@Param(\"did\") Integer did);--&gt; &lt;select id=\"getDeptAndEmpByStepTwo\" resultType=\"Emp\"&gt; select * from t_emp where did = #{did} &lt;/select&gt;","categories":[],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://newbieqiu.top/tags/Mybatis/"}]},{"title":"Mybatis 笔记","slug":"Mybatis-笔记","date":"2022-04-24T07:11:32.000Z","updated":"2022-04-24T07:15:32.967Z","comments":true,"path":"2022/04/24/Mybatis-笔记/","link":"","permalink":"http://newbieqiu.top/2022/04/24/Mybatis-%E7%AC%94%E8%AE%B0/","excerpt":"","text":"MyBatis 笔记（基础配置）环境初始化依赖坐标 打包方式： jar &lt;dependencies&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.18&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; jdbc.propertiesdriver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/mybatis?userSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8 username=root password=1234 log4j.propertieslog4j.rootLogger=DEBUG,A1 log4j.appender.A1=org.apache.log4j.ConsoleAppender log4j.appender.A1.layout=org.apache.log4j.PatternLayout log4j.appender.A1.layout.ConversionPattern=[%t] [%c]-[%p] %m%n Mapper.xml 文件&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;!-- namespace:名称空间, 对应接口的全类名 --&gt; &lt;mapper namespace=\"org.hong.mapper.UserMapper\"&gt; &lt;!-- select: 配置查询 id: 唯一标识, 对应接口中的方法名 resultType: 返回值类型, 类的全类名, 如果返回值是集合写集合中泛型的类型 --&gt; &lt;select id=\"getAll\" resultType=\"org.hong.pojo.User\"&gt; select * from user &lt;/select&gt; &lt;/mapper&gt; mybatis 核心配置文件习惯上命名为mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。将来整合Spring之后，这个配置文件可以省略核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息核心配置文件存放的位置是src/main/resources目录下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//MyBatis.org//DTD Config 3.0//EN\" \"http://MyBatis.org/dtd/MyBatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;!--引入properties文件，此时就可以${属性名}的方式访问属性值--&gt; &lt;properties resource=\"jdbc.properties\"&gt;&lt;/properties&gt; &lt;settings&gt; &lt;!--将表中字段的下划线自动转换为驼峰--&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;!--开启延迟加载--&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;!-- typeAlias：设置某个具体的类型的别名 属性： type：需要设置别名的类型的全类名 alias：设置此类型的别名，且别名不区分大小写。若不设置此属性，该类型拥有默认的别名，即类名 --&gt; &lt;!--&lt;typeAlias type=\"com.atguigu.mybatis.bean.User\"&gt;&lt;/typeAlias&gt;--&gt; &lt;!--&lt;typeAlias type=\"com.atguigu.mybatis.bean.User\" alias=\"user\"&gt; &lt;/typeAlias&gt;--&gt; &lt;!--以包为单位，设置改包下所有的类型都拥有默认的别名，即类名且不区分大小写--&gt; &lt;package name=\"com.atguigu.mybatis.bean\"/&gt; &lt;/typeAliases&gt; &lt;!-- environments：设置多个连接数据库的环境 属性： default：设置默认使用的环境的id --&gt; &lt;environments default=\"mysql_test\"&gt; &lt;!-- environment：设置具体的连接数据库的环境信息 属性： id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境的id，表示默认使用的环境 --&gt; &lt;environment id=\"mysql_test\"&gt; &lt;!-- transactionManager：设置事务管理方式 属性： type：设置事务管理方式，type=\"JDBC|MANAGED\" type=\"JDBC\"：设置当前环境的事务管理都必须手动处理 type=\"MANAGED\"：设置事务被管理，例如spring中的AOP --&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!-- dataSource：设置数据源 属性： type：设置数据源的类型，type=\"POOLED|UNPOOLED|JNDI\" type=\"POOLED\"：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从缓存中直接获取，不需要重新创建 type=\"UNPOOLED\"：不使用数据库连接池，即每次使用连接都需要重新创建 type=\"JNDI\"：调用上下文中的数据源 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!--设置驱动类的全类名--&gt; &lt;property name=\"driver\" value=\"${jdbc.driver}\"/&gt; &lt;!--设置连接数据库的连接地址--&gt; &lt;property name=\"url\" value=\"${jdbc.url}\"/&gt; &lt;!--设置连接数据库的用户名--&gt; &lt;property name=\"username\" value=\"${jdbc.username}\"/&gt; &lt;!--设置连接数据库的密码--&gt; &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--引入映射文件--&gt; &lt;mappers&gt; &lt;!-- &lt;mapper resource=\"UserMapper.xml\"/&gt; --&gt; &lt;!-- 以包为单位，将包下所有的映射文件引入核心配置文件 注意： 1. 此方式必须保证mapper接口和mapper映射文件必须在相同的包下 2. mapper接口要和mapper映射文件的名字一致 --&gt; &lt;package name=\"Mappers.UserMapper\"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 把getSQLSession封装成工具类package org.hong.util; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; public class MyBatisUtil { private static SqlSessionFactory sqlSessionFactory; static { try { // 获取sqlSessionFactory对象 String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } // 既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。 // SqlSession 提供了在数据库执行 SQL 命令所需的所有方法 public static SqlSession getSqlSession(){ // openSession(): 此方式打开SQL会话, 事务是开启状态 // openSession(true): 此方式打开SQL会话, 事务是关闭状态 return sqlSessionFactory.openSession(); } public static SqlSessionFactory getSqlSessionFactory() { return sqlSessionFactory; } } 普通的CRUD创建mapper接口 MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要提供实现类 package Mappers; public interface UserMapper { int insertUser(); } 创建MyBatis的映射文件 对象：Java的实体类对象 关系：关系型数据库 映射：二者之间的对应关系 Java概念 数据库概念 类 表 属性 字段/列 对象 记录/行 映射文件的命名规则 表所对应的实体类的类名+Mapper.xml 例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml 因此一个映射文件对应一个实体类，对应一张表的操作 MyBatis映射文件用于编写SQL，访问以及操作表中的数据 MyBatis映射文件存放的位置是src/main/resources/mappers目录下 MyBatis中可以面向接口操作数据，要保证两个一致 mapper接口的全类名和映射文件的命名空间（namespace）保持一致 mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"zjiet.mapper.UserMapper\"&gt; &lt;!--int insertUser();--&gt; &lt;insert id=\"insertUser\"&gt; insert into user values (20, '张三', null , 2, , '176@qq.com') &lt;/insert&gt; &lt;/mapper&gt; 注意接口在java包里，xml在resources里面 且resources里的结构要与java里的结构保持一致.（即Mapper文件的相对位置） Test方法 public void test001(){ // 1.获取sqlSession对象 SqlSession sqlSession = MyBatisUtil.getSqlSession(); // 2.获取需要的mapper接口的代理对象 UserMapper mapper = sqlSession.getMapper(UserMapper.class); // 3.调用对应的方法执行操作 int save = mapper.insertUser(); System.out.println(save); // 4.提交事务 sqlSession.commit(); // 5.关闭sqlSession sqlSession.close(); }","categories":[],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://newbieqiu.top/tags/Mybatis/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-04-22T09:50:46.644Z","updated":"2022-04-23T01:20:09.890Z","comments":true,"path":"2022/04/22/hello-world/","link":"","permalink":"http://newbieqiu.top/2022/04/22/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"Spring源码","slug":"Spring源码","permalink":"http://newbieqiu.top/categories/Spring%E6%BA%90%E7%A0%81/"},{"name":"java基础","slug":"java基础","permalink":"http://newbieqiu.top/categories/java%E5%9F%BA%E7%A1%80/"},{"name":"前端","slug":"前端","permalink":"http://newbieqiu.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"axios","slug":"前端/axios","permalink":"http://newbieqiu.top/categories/%E5%89%8D%E7%AB%AF/axios/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://newbieqiu.top/categories/SpringCloud/"},{"name":"Eureka","slug":"SpringCloud/Eureka","permalink":"http://newbieqiu.top/categories/SpringCloud/Eureka/"},{"name":"Vue","slug":"前端/Vue","permalink":"http://newbieqiu.top/categories/%E5%89%8D%E7%AB%AF/Vue/"},{"name":"springboot","slug":"springboot","permalink":"http://newbieqiu.top/categories/springboot/"},{"name":"项目实战","slug":"springboot/项目实战","permalink":"http://newbieqiu.top/categories/springboot/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"name":"后端项目实战","slug":"后端项目实战","permalink":"http://newbieqiu.top/categories/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"name":"springboot","slug":"后端项目实战/springboot","permalink":"http://newbieqiu.top/categories/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/springboot/"},{"name":"算法","slug":"算法","permalink":"http://newbieqiu.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"http://newbieqiu.top/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"英语","slug":"英语","permalink":"http://newbieqiu.top/categories/%E8%8B%B1%E8%AF%AD/"},{"name":"构词法","slug":"英语/构词法","permalink":"http://newbieqiu.top/categories/%E8%8B%B1%E8%AF%AD/%E6%9E%84%E8%AF%8D%E6%B3%95/"},{"name":"构词法","slug":"构词法","permalink":"http://newbieqiu.top/categories/%E6%9E%84%E8%AF%8D%E6%B3%95/"},{"name":"英语","slug":"构词法/英语","permalink":"http://newbieqiu.top/categories/%E6%9E%84%E8%AF%8D%E6%B3%95/%E8%8B%B1%E8%AF%AD/"},{"name":"最短路","slug":"算法/最短路","permalink":"http://newbieqiu.top/categories/%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}],"tags":[{"name":"Spring源码","slug":"Spring源码","permalink":"http://newbieqiu.top/tags/Spring%E6%BA%90%E7%A0%81/"},{"name":"java基础","slug":"java基础","permalink":"http://newbieqiu.top/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"前端","slug":"前端","permalink":"http://newbieqiu.top/tags/%E5%89%8D%E7%AB%AF/"},{"name":"axios","slug":"axios","permalink":"http://newbieqiu.top/tags/axios/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://newbieqiu.top/tags/SpringCloud/"},{"name":"Eureka","slug":"Eureka","permalink":"http://newbieqiu.top/tags/Eureka/"},{"name":"Vue","slug":"Vue","permalink":"http://newbieqiu.top/tags/Vue/"},{"name":"springboot","slug":"springboot","permalink":"http://newbieqiu.top/tags/springboot/"},{"name":"项目实战","slug":"项目实战","permalink":"http://newbieqiu.top/tags/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"name":"后端项目实战","slug":"后端项目实战","permalink":"http://newbieqiu.top/tags/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"name":"算法","slug":"算法","permalink":"http://newbieqiu.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://newbieqiu.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"英语","slug":"英语","permalink":"http://newbieqiu.top/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"构词法","slug":"构词法","permalink":"http://newbieqiu.top/tags/%E6%9E%84%E8%AF%8D%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://newbieqiu.top/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"mybatisPlus","slug":"mybatisPlus","permalink":"http://newbieqiu.top/tags/mybatisPlus/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://newbieqiu.top/tags/Mybatis/"}]}