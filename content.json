{"meta":{"title":"菜鸡日志","subtitle":"newbieQiu的小屋","description":"莫听穿林打叶声，何妨吟啸且徐行","author":"newbieQiu","url":"http://newbieqiu.top","root":"/"},"pages":[{"title":"","date":"2022-04-22T14:53:20.495Z","updated":"2022-04-22T14:53:20.495Z","comments":true,"path":"404/index.html","permalink":"http://newbieqiu.top/404/index.html","excerpt":"","text":"​—title: 404date: 2018-09-30 17:25:30type: “404”layout: “404”description: “Oops～，我崩溃了！找不到你想要的页面 :(“​—"},{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2022-04-22T14:53:55.061Z","comments":true,"path":"about/index.html","permalink":"http://newbieqiu.top/about/index.html","excerpt":"","text":""},{"title":"","date":"2022-04-22T14:54:13.190Z","updated":"2022-04-22T14:54:13.190Z","comments":true,"path":"tags/index.html","permalink":"http://newbieqiu.top/tags/index.html","excerpt":"","text":"​—title: tagsdate: 2018-09-30 18:23:38type: “tags”layout: “tags”​—"},{"title":"categories","date":"2018-09-30T09:25:30.000Z","updated":"2022-04-22T14:51:55.135Z","comments":true,"path":"categories/index.html","permalink":"http://newbieqiu.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2022-04-22T14:54:33.157Z","updated":"2022-04-22T14:54:33.157Z","comments":true,"path":"friends/index.html","permalink":"http://newbieqiu.top/friends/index.html","excerpt":"","text":"title: friendsdate: 2018-12-12 21:25:30type: “friends”layout: “friends”"},{"title":"contact","date":"2018-09-30T09:25:30.000Z","updated":"2022-04-22T14:54:54.207Z","comments":true,"path":"contact/index.html","permalink":"http://newbieqiu.top/contact/index.html","excerpt":"","text":""}],"posts":[{"title":"从0开始的dp生活——线性dp","slug":"从0开始的dp生活——线性dp","date":"2022-05-03T13:51:08.000Z","updated":"2022-05-03T14:38:24.127Z","comments":true,"path":"2022/05/03/从0开始的dp生活——线性dp/","link":"","permalink":"http://newbieqiu.top/2022/05/03/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84dp%E7%94%9F%E6%B4%BB%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7dp/","excerpt":"","text":"数字三角形模型 #include&lt;iostream&gt; using namespace std; int a[510][510], f[510][510]; //a储存数字三角形，f为从起点到任意点(i,j)的最大路径 int INF = 1e9; int main() { for (int i = 0; i &lt; 510; i++) for (int j = 0; j &lt; 510; j++) f[i][j] = -INF; //a数组中有负数，处理三角形边界时需要使用f的初始值做比较 int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= i; j++) //等边三角形映射为等腰直角三角形后，录入数字三角形数据 cin &gt;&gt; a[i][j]; f[1][1] = a[1][1]; //起点到起点的最短距离为a[1][1]，其他f默认值为-INF，必须手动设置f[1][1] for (int i = 2; i &lt;= n; i++) for (int j = 1; j &lt;= i; j++) f[i][j] = max(f[i - 1][j - 1], f[i - 1][j]) + a[i][j]; //dynamic programming for (int i = 2; i &lt;= n; i++) f[n][1] = max(f[n][1], f[n][i]); //起点到最后一排的各点值的最大值中，选取最大值的最大值 cout &lt;&lt; f[n][1]; } 题目描述给定一个 n×m 的矩阵，起点位置在 (1,1)，终点位置是 (n,m)接着给定该矩阵上，每个位置(x,y)上的物品的价值w现需要我们制定一个方案： 从起点出发，只能向右或向下走，如何走到终点，才能使经过的所有格子的物品总价值最大 题解这题是一道标准的动态规划问题，模型是数字三角形 我们先来分析一下 如果要进行动态规划，则用来表示当前状态的参数有哪些？ 当前走到第i行当前走到第j列于是乎，我们可以开二维数组f(i,j) 来存储当前在i行j列的状态 而f[i,j]的值，就是表示从起点走到该点经过的所有格子的价值总和的最大值 则最终答案的状态就是f(n,m) 然后再考虑状态转移方程 因为限制了只能向右或向下走，因此当前状态f(i,j)只能由f(i-1,j)或f[(i,j-1)(只能向右或向下走)转移过来 闫氏DP分析法状态表示f(i,j) 属性:从起点出发，走到第i行第j列的所有方案 集合:方案中的路线经过的所有物品的总价值最大Max状态转移 f(i,j)=max{f(i−1,j),f(i,j−1)}+w(i,j) #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; const int N =110; int dp[N][N]; int map[N][N]; int main(){ int t; cin&gt;&gt;t ; while(t--){ int m,n; cin&gt;&gt;m&gt;&gt;n; for(int i=1;i&lt;=m;i++){ for(int j=1;j&lt;=n;j++){ cin&gt;&gt;map[i][j]; } } for(int i=1;i&lt;=m;i++){ for(int j=1;j&lt;=n;j++){ dp[i][j]=max(dp[i-1][j],dp[i][j-1])+map[i][j]; } } cout&lt;&lt;dp[m][n]&lt;&lt;endl; } return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"http://newbieqiu.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"http://newbieqiu.top/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://newbieqiu.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://newbieqiu.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"从0开始的英语生活——词根","slug":"从0开始的英语生活——词根","date":"2022-05-03T13:29:55.000Z","updated":"2022-05-03T13:48:38.415Z","comments":true,"path":"2022/05/03/从0开始的英语生活——词根/","link":"","permalink":"http://newbieqiu.top/2022/05/03/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E8%8B%B1%E8%AF%AD%E7%94%9F%E6%B4%BB%E2%80%94%E2%80%94%E8%AF%8D%E6%A0%B9/","excerpt":"","text":"词根篇前缀定方向，后缀定词性，词根定词义1. ced/cess =go 行走precede v先于 precedent 先例 unprecedentedly 史无前例的 recede 后退v recession 经济衰退 intercede 调停v exceed 超过 excess excessive 过分的 access 2.-cid，cis =cut ,kill 切，杀decide concise 简洁的 precise 精确的 ~to be more precise 更精确地说 suicide 自杀 pesticide 杀虫剂 3. claim=cry，shout 喊叫exclaim proclaim 宣告公布v declaim 演讲v reclaim v.收回开拓 acclaim v 称赞 4. clud，clus =close 关闭seclude v使隔绝 conclude 5. dec/dect = lead 引导conduct 指挥 seduce 勾引 6.fer =bring 拿ferry 轮渡，渡 differ differentiate 7.ject，jet =throw 投掷subject 主题话题 / 受影响的 project v抛出 8.migr =move 迁移emigrate 移居国外 immigrate 移居国内 9.pend/pens花费penny 美分 pension 退休金 compensate 赔偿 expenditure 花费n 10.pos=putexpose compose dispose 布置，处理（dis不同方向） propose 提议，求婚 impose 强加 11.rupt =break 破bankrupt 破产 disrupt 使混乱 corrupt 腐败 12. spect =look看prospect 前景 suspect spectator 观众 13.tract =draw 拉，引tractor 拖拉机 contract 合同契约 extract 提取 14.vert/vers =turn 转动reserve extrovert 外向的人 introvert 内向的人 15.vis/vid =see(visit)revise previse 预知 supervise 监督 evident 16.viv =live 活，生命revive vivid 生动的 vital 重要的","categories":[{"name":"英语","slug":"英语","permalink":"http://newbieqiu.top/categories/%E8%8B%B1%E8%AF%AD/"},{"name":"构词法","slug":"英语/构词法","permalink":"http://newbieqiu.top/categories/%E8%8B%B1%E8%AF%AD/%E6%9E%84%E8%AF%8D%E6%B3%95/"}],"tags":[{"name":"构词法","slug":"构词法","permalink":"http://newbieqiu.top/tags/%E6%9E%84%E8%AF%8D%E6%B3%95/"},{"name":"英语","slug":"英语","permalink":"http://newbieqiu.top/tags/%E8%8B%B1%E8%AF%AD/"}]},{"title":"从0开始的英语学习——后缀","slug":"从0开始的英语生活——后缀篇","date":"2022-05-03T12:59:02.000Z","updated":"2022-05-03T13:29:16.830Z","comments":true,"path":"2022/05/03/从0开始的英语生活——后缀篇/","link":"","permalink":"http://newbieqiu.top/2022/05/03/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E8%8B%B1%E8%AF%AD%E7%94%9F%E6%B4%BB%E2%80%94%E2%80%94%E5%90%8E%E7%BC%80%E7%AF%87/","excerpt":"","text":"后缀篇前缀定方向，后缀定词性，词根定词义1.-able 能的，具有…性质的 adjadaptable 可适应的 2.-al 具有..性质的，属性…的regional 地区的 2.-al 名词后缀 ，“人”refusal criminal 3. -ate 做，造成generate v.造成 （gene 基因） activate v.激活 dictate v.口述 accelerate v. 加速 （acc强调，ele速度） differentiate v.区分 demonstrate v演示，证明（demon小样） 3. ate后缀 …的人candidate advocate electorate n.全体选民 3. -ate 形容词后缀 …的fortunate innate adj.天生的 moderate adj.适度的，中等的 legitimate adj.合法的 4. -ed 已….的，被…的extended 延伸的 married 已婚的 5. -en v.后缀 使…变成shorten threaten enlighten 启蒙 6. ence 抽象名词confidence dependence 7. -ful 富有，具有…性质的useful powerful 强大的 8. -ify -fy 使变成purity v净化 identify v.确认 personify v.拟人 modify v.调整 9. -ic …的historic adj. systematic 系统的 historic 历史上著名的 historical 历史的classic 经典的 classical 古文化的，古典的可见 -al 强调时间 -ic 强调意义10.-ion 抽象名词discussion n讨论 11. -ism ..主义，流派，特性individualism 个人主义 capitalism 资本主义 modernism 现代主义 humanism 人道主义 Marxism 马克思主义 12. -ist …人communist 共产主义者 hobbyist业余爱好者 13 -ive 具有..性质的innovative 革新的 （no -new) 14. -ize 化centralize romanticize 浪漫化 15. -less 无..的hopeless 16. -ment 物attachment n附件 basement 地下室n 17. -ness 抽象名词darkness 18. -ship情况.关系hardship 艰难 18. -ship 身份kingship 王权 membership 会员 ownership 所有权 co-authorship 合作者身份 19. -ward 向…的，朝download 20. -y 多的wordy 冗长的 icy 冰冷的 20.-y抽象名词injury 伤 jealousy 嫉妒 mastery 精通","categories":[{"name":"构词法","slug":"构词法","permalink":"http://newbieqiu.top/categories/%E6%9E%84%E8%AF%8D%E6%B3%95/"},{"name":"英语","slug":"构词法/英语","permalink":"http://newbieqiu.top/categories/%E6%9E%84%E8%AF%8D%E6%B3%95/%E8%8B%B1%E8%AF%AD/"}],"tags":[{"name":"构词法","slug":"构词法","permalink":"http://newbieqiu.top/tags/%E6%9E%84%E8%AF%8D%E6%B3%95/"},{"name":"英语","slug":"英语","permalink":"http://newbieqiu.top/tags/%E8%8B%B1%E8%AF%AD/"}]},{"title":"从0开始的英语生活——前缀篇","slug":"从0开始的英语生活——前缀篇","date":"2022-04-28T08:20:10.000Z","updated":"2022-04-28T09:05:33.510Z","comments":true,"path":"2022/04/28/从0开始的英语生活——前缀篇/","link":"","permalink":"http://newbieqiu.top/2022/04/28/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E8%8B%B1%E8%AF%AD%E7%94%9F%E6%B4%BB%E2%80%94%E2%80%94%E5%89%8D%E7%BC%80%E7%AF%87/","excerpt":"","text":"前缀篇前缀定方向，后缀定词性，词根定词义1. ab - 离去，想法，不（消极意思）abnormal 反常的，变态的 adj abuse 滥用，虐待 n/v 2.anti - 反对，相反antiwar 反战的 antiaging 防衰老的 antiforeign 排外的 antinoise 抗噪音的 antibiotics 抗生素 n（biotic像biology） antitrust 反垄断的 （trust为托拉斯，垄断组织） 3.a+双写首字母 - 加强，强调作用account 账目，存款 n attract 吸引（tract的词根意为拉） assimilate 同化 v affluent 富裕的 adj（强调富得流油） 4. co-/col-/con/com- 一起cooperation collaboration 合作（labor为劳动，一起劳动） contribute 贡献（bute为贡品）v 5. counter - 反对，相反counterattack 反击n/v countereffect 反效果n counterpart 相对应的n counterfeit 仿制（feit，fict，fact词根为制造） 6.de- 否定，除去，向下denationlize 非国有化v decompose 分解v（com一起，pose放置） deforest 砍伐树林 devastating 毁灭性的（vast巨大的，巨大的东西掉下来了） deception 欺骗（cep词根 来） derive 起源 7. dis- 否定，除去，分开discover 发现 disease 疾病 disorder 无秩序n distract 分心 dismiss (解雇，清除)不再miss她 disposal 清理 pos词根为放置 8.ex- 外，前任的export 出口v,n ex-boyfriend expression 表情表达（向外压） 9. fore 前，先，预先forehead 前额（头的前面） forefather 祖先 foresee 预知 forerunner 先驱 10. in,im- 向里，否定，加强indoor adj室内的 inbreathe 吸入 incorrect intense（加强，延伸） 热情的 immerge 浸入v impose 强加，征税（放） impluse 冲动（加强，推） 11. mis- 错误，坏mismanagement 管理不当n misfortune 不幸 12.out- 超过，外outlet 出口 outperform v表现得更好 13.over- 过度overstatement 夸大n overemphasize 过分强调n 14.post- 后postwar 战后的 postpone 推后（pon为放） postgraduate 研究生n post-disaster 灾后生活 15. pre -前（时间上的前）prehistory 史前的 precondition 前提条件 precedent 先例 n（ced 超过) 16. pro - 空间上的前progress （gress为go）进步 n prolong 延长v propel 推进，促使v（pel-推） propose 提议，求婚（pose 拿put） 17. re- 向后，再一次return recall 召回，记得 regress 倒退v 18. sub- 下，下级subaverage 低于平均值v suburb 郊区 subconsciously =without knowing it (不易察觉的) –意识向下 19. trans - 转移（from A to B)transform transplant 移植 20. mono 一monotone 单调 monodrama 独角戏 monologue 独白 bi- 二bicycle （两个轮子） bilateral 双边的adj di- 二dioxide divorce tri - 三triangle trike 三轮车 hemi - 半hemisphere 半球 hemicycle 半圆形 semi- 半（抽象）semifinal 半决赛 poly- multi- 多monopoly 垄断（1个有多个） polytechnic 理工学院 multi-media","categories":[{"name":"英语","slug":"英语","permalink":"http://newbieqiu.top/categories/%E8%8B%B1%E8%AF%AD/"}],"tags":[{"name":"构词法","slug":"构词法","permalink":"http://newbieqiu.top/tags/%E6%9E%84%E8%AF%8D%E6%B3%95/"},{"name":"英语","slug":"英语","permalink":"http://newbieqiu.top/tags/%E8%8B%B1%E8%AF%AD/"}]},{"title":"最短路算法之 bellman_ford 算法","slug":"最短路算法之-bellman-ford-算法","date":"2022-04-27T11:22:17.000Z","updated":"2022-04-27T12:00:38.500Z","comments":true,"path":"2022/04/27/最短路算法之-bellman-ford-算法/","link":"","permalink":"http://newbieqiu.top/2022/04/27/%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95%E4%B9%8B-bellman-ford-%E7%AE%97%E6%B3%95/","excerpt":"","text":"最短路算法之 bellman_ford算法bellman_ford 算法的时间复杂度为o（n*m），一般用在存在负权边的情况。存在负权边的情况bellman_ford 算法和 SPFA算法都可以使用 ，但SPFA算法会优于改算法，但有一种情况下不能代替。即题目中出现有边数限制的最短路。模板题思路 代码#include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; const int N = 510, M = 10010; struct Edge { int a; int b; int w; } e[M];//把每个边保存下来即可 int dist[N]; int back[N];//备份数组防止串联 int n, m, k;//k代表最短路径最多包涵k条边 int bellman_ford() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i &lt; k; i++) {//k次循环 memcpy(back, dist, sizeof dist); for (int j = 0; j &lt; m; j++) {//遍历所有边 int a = e[j].a, b = e[j].b, w = e[j].w; dist[b] = min(dist[b], back[a] + w); //使用backup:避免给a更新后立马更新b, 这样b一次性最短路径就多了两条边出来 } } if (dist[n] &gt; 0x3f3f3f3f / 2) return -1; else return dist[n]; } int main() { scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for (int i = 0; i &lt; m; i++) { int a, b, w; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;w); e[i] = {a, b, w}; } int res = bellman_ford(); if (res == -1) puts(\"impossible\"); else cout &lt;&lt; res; return 0; } 一些小细节为什么是dist[n]&gt;0x3f3f3f3f/2， 而不是dist[n]==0x3f3f3f3f5号节点距离起点的距离是无穷大，利用5号节点更新n号节点距离起点的距离，将得到109−2109−2, 虽然小于109109, 但并不存在最短路，(在边数限制在k条的条件下)。 为什么需要back[a]数组为了避免如下的串联情况， 在边数限制为一条的情况下，节点3的距离应该是3，但是由于串联情况，利用本轮更新的节点2更新了节点3的距离，所以现在节点3的距离是2。 正确做法是用上轮节点2更新的距离–无穷大，来更新节点3， 再取最小值，所以节点3离起点的距离是3。","categories":[{"name":"算法","slug":"算法","permalink":"http://newbieqiu.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"最短路","slug":"算法/最短路","permalink":"http://newbieqiu.top/categories/%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}],"tags":[]},{"title":"最短路之 Dijkstra 算法","slug":"最短路之-Dijstra-算法","date":"2022-04-26T04:02:29.000Z","updated":"2022-04-26T07:54:48.756Z","comments":true,"path":"2022/04/26/最短路之-Dijstra-算法/","link":"","permalink":"http://newbieqiu.top/2022/04/26/%E6%9C%80%E7%9F%AD%E8%B7%AF%E4%B9%8B-Dijstra-%E7%AE%97%E6%B3%95/","excerpt":"","text":"最短路之 Dijkstra 算法（朴素做法）时间复杂度 O(n2)没什么好说的先上模板题Dijkstra算法(用于稀疏图) 总结来说就是以下的几步：1.初始化距离 dist[1]=0 dist[i] =无穷大2. for( i=1 到 n)2.1 找t不在s中的距离最近的点2.2 讲 t加入到 s中2.3 用t更新到其他点的距离#include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; const int N=510; int g[N][N]; //为稠密阵所以用邻接矩阵存储 int dist[N]; //用于记录每一个点距离第一个点的距离 bool st[N]; //用于记录该点的最短距离是否已经确定 int n,m; int Dijkstra() { memset(dist, 0x3f,sizeof dist); //初始化距离 0x3f代表无限大 dist[1]=0; //第一个点到自身的距离为0 for(int i=0;i&lt;n;i++) //有n个点所以要进行n次 迭代 { int t=-1; //t存储当前访问的点 for(int j=1;j&lt;=n;j++) //这里的j代表的是从1号点开始 if(!st[j]&amp;&amp;(t==-1|| dist[t]&gt;dist[j]) ) t=j; st[t]=true; for(int j=1;j&lt;=n;j++) //依次更新每个点所到相邻的点路径值 dist[j]=min(dist[j],dist[t]+g[t][j]); //这里可能有同学要问j如果从1开始的话 会不会影响之前已经确定的点的最小距离 //但其实是不会 因为按照我们的Dijkstra算法的操作顺序 先确定最短距离的点的距离已经比后确定的要小 所以不会影响 //当然你也可以在循环判断条件里加上if(!st[i]) //这里j从1开始只是为了代码的简洁 } if(dist[n]==0x3f3f3f3f) return -1; //如果第n个点路径为无穷大即不存在最低路径 return dist[n]; } int main() { cin&gt;&gt;n&gt;&gt;m; memset(g,0x3f,sizeof g); //初始化图 因为是求最短路径 //所以每个点初始为无限大 while(m--) { int x,y,z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; g[x][y]=min(g[x][y],z); //如果发生重边的情况则保留最短的一条边 } cout&lt;&lt;Dijkstra()&lt;&lt;endl; return 0; } Dijkstra算法（堆优化版）用于稠密图，时间复杂度O(mlog(n)) m为变数n为点数模板题：堆优化版模板题 思路1.一号点的距离初始化为零，其他点初始化成无穷大。2.将一号点放入堆中。3.不断循环，直到堆空。每一次循环中执行的操作为：弹出堆顶（与朴素版diijkstra找到S外距离最短的点相同，并标记该点的最短路径已经确定）。用该点更新临界点的距离，若更新成功就加入到堆中。for(i:1 ~ n)//n次 { t &lt;- 没有确定最短路径的节点中距离源点最近的点;//每次遍一遍历dist数组，n次的复杂度是O(n^2) state[t] = 1; 更新 dist;//每次遍历一个节点的出边，n次遍历了所有节点的边，复杂度为O(e) } #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; typedef pair&lt;int, int&gt; PII; const int N = 100010; // 把N改为150010就能ac // 稀疏图用邻接表来存 int h[N], e[N], ne[N], idx; int w[N]; // 用来存权重 int dist[N]; bool st[N]; // 如果为true说明这个点的最短路径已经确定 int n, m; void add(int x, int y, int c) { w[idx] = c; // 有重边也不要紧，假设1-&gt;2有权重为2和3的边，再遍历到点1的时候2号点的距离会更新两次放入堆中 e[idx] = y; // 这样堆中会有很多冗余的点，但是在弹出的时候还是会弹出最小值2+x（x为之前确定的最短路径），并 ne[idx] = h[x]; // 标记st为true，所以下一次弹出3+x会continue不会向下执行。 h[x] = idx++; } int dijkstra() { memset(dist, 0x3f, sizeof(dist)); dist[1] = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; // 定义一个小根堆 // 这里heap中为什么要存pair呢，首先小根堆是根据距离来排的，所以有一个变量要是距离，其次在从堆中拿出来的时 // 候要知道知道这个点是哪个点，不然怎么更新邻接点呢？所以第二个变量要存点。 heap.push({ 0, 1 }); // 这个顺序不能倒，pair排序时是先根据first，再根据second，这里显然要根据距离排序 while(heap.size()) { PII k = heap.top(); // 取不在集合S中距离最短的点 heap.pop(); int ver = k.second, distance = k.first; if(st[ver]) continue; st[ver] = true; for(int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; // i只是个下标，e中在存的是i这个下标对应的点。 if(dist[j] &gt; distance + w[i]) { dist[j] = distance + w[i]; heap.push({ dist[j], j }); } } } if(dist[n] == 0x3f3f3f3f) return -1; else return dist[n]; } int main() { memset(h, -1, sizeof(h)); scanf(\"%d%d\", &amp;n, &amp;m); while (m--) { int x, y, c; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;c); add(x, y, c); } cout &lt;&lt; dijkstra() &lt;&lt; endl; return 0; } ps：不用continue不会影响后面的取值，因为有dis[j]&gt;distance+w[i]的判断，一定会更新成最小的那个，只不过就是把这个点的邻接点又加进去判断了而已，多了几次for循环，加上continue会减少这个判断，不加continue会超时，不会答案错误。","categories":[{"name":"算法","slug":"算法","permalink":"http://newbieqiu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://newbieqiu.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://newbieqiu.top/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"Mybatis Plus笔记(1)","slug":"Mybatis-Plus笔记-1","date":"2022-04-25T09:56:51.000Z","updated":"2022-04-25T10:47:10.065Z","comments":true,"path":"2022/04/25/Mybatis-Plus笔记-1/","link":"","permalink":"http://newbieqiu.top/2022/04/25/Mybatis-Plus%E7%AC%94%E8%AE%B0-1/","excerpt":"","text":"初始化引入依赖(Springboot方式启动)&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 配置yml文件spring: # 配置数据源信息 datasource: # 配置数据源类型 type: com.zaxxer.hikari.HikariDataSource # 配置连接数据库信息 driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false username: root password: 123456 8.0加上这句在问号后面加上 serverTimezone=GMT%2B8&amp; 启动类在Spring Boot启动类中添加@MapperScan注解，扫描mapper包日志添加# 配置MyBatis日志 mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl 基本的CRUD操作批量删除@Test public void testDeleteBatchIds(){ //通过多个id批量删除 //DELETE FROM user WHERE id IN ( ? , ? , ? ) List&lt;Long&gt; idList = Arrays.asList(1L, 2L, 3L); int result = userMapper.deleteBatchIds(idList); System.out.println(\"受影响行数：\"+result); } 通过Map删除@Test public void testDeleteByMap(){ //根据map集合中所设置的条件删除记录 //DELETE FROM user WHERE name = ? AND age = ? Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"age\", 23); map.put(\"name\", \"张三\"); int result = userMapper.deleteByMap(map); System.out.println(\"受影响行数：\"+result); } 查询的map和批量查大同小异，这里不再一一赘述 。最后不要忘了 Mapper接口继承 BaseMapper 哦！！自定义接口在不改yaml文件的情况下默认把xml文件放在Mapper包下或者其子包下（或者可以在yaml文件下设置mapper-locations: classpath:/mapper/Usermapper.xml 记得在主加载类上加@Mapperscan 扫描 ！！！","categories":[],"tags":[{"name":"mybatisPlus","slug":"mybatisPlus","permalink":"http://newbieqiu.top/tags/mybatisPlus/"}]},{"title":"Mybatis 复习(一对多多对一)","slug":"Mybatis-复习-一对多多对一","date":"2022-04-24T09:44:33.000Z","updated":"2022-04-24T09:50:34.967Z","comments":true,"path":"2022/04/24/Mybatis-复习-一对多多对一/","link":"","permalink":"http://newbieqiu.top/2022/04/24/Mybatis-%E5%A4%8D%E4%B9%A0-%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%A4%9A%E5%AF%B9%E4%B8%80/","excerpt":"","text":"自定义映射resultMapresultMap处理字段和属性的映射关系 resultMap：设置自定义映射 属性： id：表示自定义映射的唯一标识，不能重复 type：查询的数据要映射的实体类的类型 子标签： id：设置主键的映射关系 result：设置普通字段的映射关系 子标签属性： property：设置映射关系中实体类中的属性名 column：设置映射关系中表中的字段名 若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射，即使字段名和属性名一致的属性也要映射，也就是全部属性都要列出来 &lt;resultMap id=\"empResultMap\" type=\"Emp\"&gt; &lt;id property=\"eid\" column=\"eid\"&gt;&lt;/id&gt; &lt;result property=\"empName\" column=\"emp_name\"&gt;&lt;/result&gt; &lt;result property=\"age\" column=\"age\"&gt;&lt;/result&gt; &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"email\" column=\"email\"&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;!--List&lt;Emp&gt; getAllEmp();--&gt; &lt;select id=\"getAllEmp\" resultMap=\"empResultMap\"&gt; select * from t_emp &lt;/select&gt; 若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用_），实体类中的属性名符合Java的规则（使用驼峰）。此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系 可以通过为字段起别名的方式，保证和实体类中的属性名保持一致 &lt;!--List&lt;Emp&gt; getAllEmp();--&gt; &lt;select id=\"getAllEmp\" resultType=\"Emp\"&gt; select eid,emp_name empName,age,sex,email from t_emp &lt;/select&gt; 可以在MyBatis的核心配置文件中的setting标签中，设置一个全局配置信息mapUnderscoreToCamelCase，可以在查询表中数据时，自动将_类型的字段名转换为驼峰，例如：字段名user_name，设置了mapUnderscoreToCamelCase，此时字段名就会转换为userName。核心配置文件详解 &lt;settings&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;/settings&gt; 多对一映射处理 查询员工信息以及员工所对应的部门信息 public class Emp { private Integer eid; private String empName; private Integer age; private String sex; private String email; private Dept dept; //...构造器、get、set方法等 } 级联方式处理映射关系&lt;resultMap id=\"empAndDeptResultMapOne\" type=\"Emp\"&gt; &lt;id property=\"eid\" column=\"eid\"&gt;&lt;/id&gt; &lt;result property=\"empName\" column=\"emp_name\"&gt;&lt;/result&gt; &lt;result property=\"age\" column=\"age\"&gt;&lt;/result&gt; &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"email\" column=\"email\"&gt;&lt;/result&gt; &lt;result property=\"dept.did\" column=\"did\"&gt;&lt;/result&gt; &lt;result property=\"dept.deptName\" column=\"dept_name\"&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;!--Emp getEmpAndDept(@Param(\"eid\")Integer eid);--&gt; &lt;select id=\"getEmpAndDept\" resultMap=\"empAndDeptResultMapOne\"&gt; select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #{eid} &lt;/select&gt; 使用association处理映射关系 association：处理多对一的映射关系 property：需要处理多对的映射关系的属性名 javaType：该属性的类型 &lt;resultMap id=\"empAndDeptResultMapTwo\" type=\"Emp\"&gt; &lt;id property=\"eid\" column=\"eid\"&gt;&lt;/id&gt; &lt;result property=\"empName\" column=\"emp_name\"&gt;&lt;/result&gt; &lt;result property=\"age\" column=\"age\"&gt;&lt;/result&gt; &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"email\" column=\"email\"&gt;&lt;/result&gt; &lt;association property=\"dept\" javaType=\"Dept\"&gt; &lt;id property=\"did\" column=\"did\"&gt;&lt;/id&gt; &lt;result property=\"deptName\" column=\"dept_name\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;!--Emp getEmpAndDept(@Param(\"eid\")Integer eid);--&gt; &lt;select id=\"getEmpAndDept\" resultMap=\"empAndDeptResultMapTwo\"&gt; select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #{eid} &lt;/select&gt; 分步查询1. 查询员工信息 select：设置分布查询的sql的唯一标识（namespace.SQLId或mapper接口的全类名.方法名） column：设置分步查询的条件 //EmpMapper里的方法 /** * 通过分步查询，员工及所对应的部门信息 * 分步查询第一步：查询员工信息 * @param * @return com.atguigu.mybatis.pojo.Emp * @date 2022/2/27 20:17 */ Emp getEmpAndDeptByStepOne(@Param(\"eid\") Integer eid); &lt;resultMap id=\"empAndDeptByStepResultMap\" type=\"Emp\"&gt; &lt;id property=\"eid\" column=\"eid\"&gt;&lt;/id&gt; &lt;result property=\"empName\" column=\"emp_name\"&gt;&lt;/result&gt; &lt;result property=\"age\" column=\"age\"&gt;&lt;/result&gt; &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"email\" column=\"email\"&gt;&lt;/result&gt; &lt;association property=\"dept\" select=\"com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo\" column=\"did\"&gt;&lt;/association&gt; &lt;/resultMap&gt; &lt;!--Emp getEmpAndDeptByStepOne(@Param(\"eid\") Integer eid);--&gt; &lt;select id=\"getEmpAndDeptByStepOne\" resultMap=\"empAndDeptByStepResultMap\"&gt; select * from t_emp where eid = #{eid} &lt;/select&gt; 2. 查询部门信息//DeptMapper里的方法 /** * 通过分步查询，员工及所对应的部门信息 * 分步查询第二步：通过did查询员工对应的部门信息 * @param * @return com.atguigu.mybatis.pojo.Emp * @date 2022/2/27 20:23 */ Dept getEmpAndDeptByStepTwo(@Param(\"did\") Integer did); &lt;!--此处的resultMap仅是处理字段和属性的映射关系--&gt; &lt;resultMap id=\"EmpAndDeptByStepTwoResultMap\" type=\"Dept\"&gt; &lt;id property=\"did\" column=\"did\"&gt;&lt;/id&gt; &lt;result property=\"deptName\" column=\"dept_name\"&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;!--Dept getEmpAndDeptByStepTwo(@Param(\"did\") Integer did);--&gt; &lt;select id=\"getEmpAndDeptByStepTwo\" resultMap=\"EmpAndDeptByStepTwoResultMap\"&gt; select * from t_dept where did = #{did} &lt;/select&gt; 一对多映射处理public class Dept { private Integer did; private String deptName; private List&lt;Emp&gt; emps; //...构造器、get、set方法等 } collection collection：用来处理一对多的映射关系 ofType：表示该属性对饮的集合中存储的数据的类型 &lt;resultMap id=\"DeptAndEmpResultMap\" type=\"Dept\"&gt; &lt;id property=\"did\" column=\"did\"&gt;&lt;/id&gt; &lt;result property=\"deptName\" column=\"dept_name\"&gt;&lt;/result&gt; &lt;collection property=\"emps\" ofType=\"Emp\"&gt; &lt;id property=\"eid\" column=\"eid\"&gt;&lt;/id&gt; &lt;result property=\"empName\" column=\"emp_name\"&gt;&lt;/result&gt; &lt;result property=\"age\" column=\"age\"&gt;&lt;/result&gt; &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"email\" column=\"email\"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!--Dept getDeptAndEmp(@Param(\"did\") Integer did);--&gt; &lt;select id=\"getDeptAndEmp\" resultMap=\"DeptAndEmpResultMap\"&gt; select * from t_dept left join t_emp on t_dept.did = t_emp.did where t_dept.did = #{did} &lt;/select&gt; 分步查询1. 查询部门信息/** * 通过分步查询，查询部门及对应的所有员工信息 * 分步查询第一步：查询部门信息 * @param did * @return com.atguigu.mybatis.pojo.Dept * @date 2022/2/27 22:04 */ Dept getDeptAndEmpByStepOne(@Param(\"did\") Integer did); &lt;resultMap id=\"DeptAndEmpByStepOneResultMap\" type=\"Dept\"&gt; &lt;id property=\"did\" column=\"did\"&gt;&lt;/id&gt; &lt;result property=\"deptName\" column=\"dept_name\"&gt;&lt;/result&gt; &lt;collection property=\"emps\" select=\"com.atguigu.mybatis.mapper.EmpMapper.getDeptAndEmpByStepTwo\" column=\"did\"&gt;&lt;/collection&gt; &lt;/resultMap&gt; &lt;!--Dept getDeptAndEmpByStepOne(@Param(\"did\") Integer did);--&gt; &lt;select id=\"getDeptAndEmpByStepOne\" resultMap=\"DeptAndEmpByStepOneResultMap\"&gt; select * from t_dept where did = #{did} &lt;/select&gt; 2. 根据部门id查询部门中的所有员工/** * 通过分步查询，查询部门及对应的所有员工信息 * 分步查询第二步：根据部门id查询部门中的所有员工 * @param did * @return java.util.List&lt;com.atguigu.mybatis.pojo.Emp&gt; * @date 2022/2/27 22:10 */ List&lt;Emp&gt; getDeptAndEmpByStepTwo(@Param(\"did\") Integer did); &lt;!--List&lt;Emp&gt; getDeptAndEmpByStepTwo(@Param(\"did\") Integer did);--&gt; &lt;select id=\"getDeptAndEmpByStepTwo\" resultType=\"Emp\"&gt; select * from t_emp where did = #{did} &lt;/select&gt;","categories":[],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://newbieqiu.top/tags/Mybatis/"}]},{"title":"Mybatis 笔记","slug":"Mybatis-笔记","date":"2022-04-24T07:11:32.000Z","updated":"2022-04-24T07:15:32.967Z","comments":true,"path":"2022/04/24/Mybatis-笔记/","link":"","permalink":"http://newbieqiu.top/2022/04/24/Mybatis-%E7%AC%94%E8%AE%B0/","excerpt":"","text":"MyBatis 笔记（基础配置）环境初始化依赖坐标 打包方式： jar &lt;dependencies&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.18&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; jdbc.propertiesdriver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/mybatis?userSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8 username=root password=1234 log4j.propertieslog4j.rootLogger=DEBUG,A1 log4j.appender.A1=org.apache.log4j.ConsoleAppender log4j.appender.A1.layout=org.apache.log4j.PatternLayout log4j.appender.A1.layout.ConversionPattern=[%t] [%c]-[%p] %m%n Mapper.xml 文件&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;!-- namespace:名称空间, 对应接口的全类名 --&gt; &lt;mapper namespace=\"org.hong.mapper.UserMapper\"&gt; &lt;!-- select: 配置查询 id: 唯一标识, 对应接口中的方法名 resultType: 返回值类型, 类的全类名, 如果返回值是集合写集合中泛型的类型 --&gt; &lt;select id=\"getAll\" resultType=\"org.hong.pojo.User\"&gt; select * from user &lt;/select&gt; &lt;/mapper&gt; mybatis 核心配置文件习惯上命名为mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。将来整合Spring之后，这个配置文件可以省略核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息核心配置文件存放的位置是src/main/resources目录下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//MyBatis.org//DTD Config 3.0//EN\" \"http://MyBatis.org/dtd/MyBatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;!--引入properties文件，此时就可以${属性名}的方式访问属性值--&gt; &lt;properties resource=\"jdbc.properties\"&gt;&lt;/properties&gt; &lt;settings&gt; &lt;!--将表中字段的下划线自动转换为驼峰--&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;!--开启延迟加载--&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;!-- typeAlias：设置某个具体的类型的别名 属性： type：需要设置别名的类型的全类名 alias：设置此类型的别名，且别名不区分大小写。若不设置此属性，该类型拥有默认的别名，即类名 --&gt; &lt;!--&lt;typeAlias type=\"com.atguigu.mybatis.bean.User\"&gt;&lt;/typeAlias&gt;--&gt; &lt;!--&lt;typeAlias type=\"com.atguigu.mybatis.bean.User\" alias=\"user\"&gt; &lt;/typeAlias&gt;--&gt; &lt;!--以包为单位，设置改包下所有的类型都拥有默认的别名，即类名且不区分大小写--&gt; &lt;package name=\"com.atguigu.mybatis.bean\"/&gt; &lt;/typeAliases&gt; &lt;!-- environments：设置多个连接数据库的环境 属性： default：设置默认使用的环境的id --&gt; &lt;environments default=\"mysql_test\"&gt; &lt;!-- environment：设置具体的连接数据库的环境信息 属性： id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境的id，表示默认使用的环境 --&gt; &lt;environment id=\"mysql_test\"&gt; &lt;!-- transactionManager：设置事务管理方式 属性： type：设置事务管理方式，type=\"JDBC|MANAGED\" type=\"JDBC\"：设置当前环境的事务管理都必须手动处理 type=\"MANAGED\"：设置事务被管理，例如spring中的AOP --&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!-- dataSource：设置数据源 属性： type：设置数据源的类型，type=\"POOLED|UNPOOLED|JNDI\" type=\"POOLED\"：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从缓存中直接获取，不需要重新创建 type=\"UNPOOLED\"：不使用数据库连接池，即每次使用连接都需要重新创建 type=\"JNDI\"：调用上下文中的数据源 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!--设置驱动类的全类名--&gt; &lt;property name=\"driver\" value=\"${jdbc.driver}\"/&gt; &lt;!--设置连接数据库的连接地址--&gt; &lt;property name=\"url\" value=\"${jdbc.url}\"/&gt; &lt;!--设置连接数据库的用户名--&gt; &lt;property name=\"username\" value=\"${jdbc.username}\"/&gt; &lt;!--设置连接数据库的密码--&gt; &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--引入映射文件--&gt; &lt;mappers&gt; &lt;!-- &lt;mapper resource=\"UserMapper.xml\"/&gt; --&gt; &lt;!-- 以包为单位，将包下所有的映射文件引入核心配置文件 注意： 1. 此方式必须保证mapper接口和mapper映射文件必须在相同的包下 2. mapper接口要和mapper映射文件的名字一致 --&gt; &lt;package name=\"Mappers.UserMapper\"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 把getSQLSession封装成工具类package org.hong.util; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; public class MyBatisUtil { private static SqlSessionFactory sqlSessionFactory; static { try { // 获取sqlSessionFactory对象 String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } // 既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。 // SqlSession 提供了在数据库执行 SQL 命令所需的所有方法 public static SqlSession getSqlSession(){ // openSession(): 此方式打开SQL会话, 事务是开启状态 // openSession(true): 此方式打开SQL会话, 事务是关闭状态 return sqlSessionFactory.openSession(); } public static SqlSessionFactory getSqlSessionFactory() { return sqlSessionFactory; } } 普通的CRUD创建mapper接口 MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要提供实现类 package Mappers; public interface UserMapper { int insertUser(); } 创建MyBatis的映射文件 对象：Java的实体类对象 关系：关系型数据库 映射：二者之间的对应关系 Java概念 数据库概念 类 表 属性 字段/列 对象 记录/行 映射文件的命名规则 表所对应的实体类的类名+Mapper.xml 例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml 因此一个映射文件对应一个实体类，对应一张表的操作 MyBatis映射文件用于编写SQL，访问以及操作表中的数据 MyBatis映射文件存放的位置是src/main/resources/mappers目录下 MyBatis中可以面向接口操作数据，要保证两个一致 mapper接口的全类名和映射文件的命名空间（namespace）保持一致 mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"zjiet.mapper.UserMapper\"&gt; &lt;!--int insertUser();--&gt; &lt;insert id=\"insertUser\"&gt; insert into user values (20, '张三', null , 2, , '176@qq.com') &lt;/insert&gt; &lt;/mapper&gt; 注意接口在java包里，xml在resources里面 且resources里的结构要与java里的结构保持一致.（即Mapper文件的相对位置） Test方法 public void test001(){ // 1.获取sqlSession对象 SqlSession sqlSession = MyBatisUtil.getSqlSession(); // 2.获取需要的mapper接口的代理对象 UserMapper mapper = sqlSession.getMapper(UserMapper.class); // 3.调用对应的方法执行操作 int save = mapper.insertUser(); System.out.println(save); // 4.提交事务 sqlSession.commit(); // 5.关闭sqlSession sqlSession.close(); }","categories":[],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://newbieqiu.top/tags/Mybatis/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-04-22T09:50:46.644Z","updated":"2022-04-23T01:20:09.890Z","comments":true,"path":"2022/04/22/hello-world/","link":"","permalink":"http://newbieqiu.top/2022/04/22/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"算法","slug":"算法","permalink":"http://newbieqiu.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"http://newbieqiu.top/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"英语","slug":"英语","permalink":"http://newbieqiu.top/categories/%E8%8B%B1%E8%AF%AD/"},{"name":"构词法","slug":"英语/构词法","permalink":"http://newbieqiu.top/categories/%E8%8B%B1%E8%AF%AD/%E6%9E%84%E8%AF%8D%E6%B3%95/"},{"name":"构词法","slug":"构词法","permalink":"http://newbieqiu.top/categories/%E6%9E%84%E8%AF%8D%E6%B3%95/"},{"name":"英语","slug":"构词法/英语","permalink":"http://newbieqiu.top/categories/%E6%9E%84%E8%AF%8D%E6%B3%95/%E8%8B%B1%E8%AF%AD/"},{"name":"最短路","slug":"算法/最短路","permalink":"http://newbieqiu.top/categories/%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://newbieqiu.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://newbieqiu.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"构词法","slug":"构词法","permalink":"http://newbieqiu.top/tags/%E6%9E%84%E8%AF%8D%E6%B3%95/"},{"name":"英语","slug":"英语","permalink":"http://newbieqiu.top/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"图论","slug":"图论","permalink":"http://newbieqiu.top/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"mybatisPlus","slug":"mybatisPlus","permalink":"http://newbieqiu.top/tags/mybatisPlus/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://newbieqiu.top/tags/Mybatis/"}]}