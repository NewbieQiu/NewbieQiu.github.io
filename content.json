{"meta":{"title":"菜鸡日志","subtitle":"newbieQiu的小屋","description":"莫听穿林打叶声，何妨吟啸且徐行","author":"newbieQiu","url":"http://newbieqiu.top","root":"/"},"pages":[{"title":"","date":"2022-04-22T14:53:20.495Z","updated":"2022-04-22T14:53:20.495Z","comments":true,"path":"404/index.html","permalink":"http://newbieqiu.top/404/index.html","excerpt":"","text":"​—title: 404date: 2018-09-30 17:25:30type: “404”layout: “404”description: “Oops～，我崩溃了！找不到你想要的页面 :(“​—"},{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2022-04-22T14:53:55.061Z","comments":true,"path":"about/index.html","permalink":"http://newbieqiu.top/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-09-30T09:25:30.000Z","updated":"2022-04-22T14:51:55.135Z","comments":true,"path":"categories/index.html","permalink":"http://newbieqiu.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2022-04-22T14:54:33.157Z","updated":"2022-04-22T14:54:33.157Z","comments":true,"path":"friends/index.html","permalink":"http://newbieqiu.top/friends/index.html","excerpt":"","text":"title: friendsdate: 2018-12-12 21:25:30type: “friends”layout: “friends”"},{"title":"contact","date":"2018-09-30T09:25:30.000Z","updated":"2022-04-22T14:54:54.207Z","comments":true,"path":"contact/index.html","permalink":"http://newbieqiu.top/contact/index.html","excerpt":"","text":""},{"title":"","date":"2022-04-22T14:54:13.190Z","updated":"2022-04-22T14:54:13.190Z","comments":true,"path":"tags/index.html","permalink":"http://newbieqiu.top/tags/index.html","excerpt":"","text":"​—title: tagsdate: 2018-09-30 18:23:38type: “tags”layout: “tags”​—"}],"posts":[{"title":"写项目时如何正确地把日期格式转换成json","slug":"写项目时如何正确地把日期格式转换成json","date":"2023-10-08T12:13:14.000Z","updated":"2023-10-08T12:13:54.338Z","comments":true,"path":"2023/10/08/写项目时如何正确地把日期格式转换成json/","link":"","permalink":"http://newbieqiu.top/2023/10/08/%E5%86%99%E9%A1%B9%E7%9B%AE%E6%97%B6%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%9C%B0%E6%8A%8A%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%E6%88%90json/","excerpt":"","text":"2.4 代码完善问题描述：操作时间字段显示有问题。 解决方式： 1). 方式一 在属性上加上注解，对日期进行格式化 但这种方式，需要在每个时间属性上都要加上该注解，使用较麻烦，不能全局处理。 2). 方式二（推荐 ) 在WebMvcConfiguration中扩展SpringMVC的消息转换器，统一对日期类型进行格式处理 /** * 扩展Spring MVC框架的消息转化器 * @param converters */ protected void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) { log.info(\"扩展消息转换器...\"); //创建一个消息转换器对象 MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter(); //需要为消息转换器设置一个对象转换器，对象转换器可以将Java对象序列化为json数据 converter.setObjectMapper(new JacksonObjectMapper()); //将自己的消息转化器加入容器中 converters.add(0,converter); } 添加后，再次测试 时间格式定义，sky-common模块中 package com.sky.json; public class JacksonObjectMapper extends ObjectMapper { //....... public static final String DEFAULT_DATE_TIME_FORMAT = \"yyyy-MM-dd HH:mm\"; //....... } } 2.5","categories":[{"name":"大型项目","slug":"大型项目","permalink":"http://newbieqiu.top/categories/%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE/"},{"name":"SpringBoot","slug":"大型项目/SpringBoot","permalink":"http://newbieqiu.top/categories/%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE/SpringBoot/"}],"tags":[{"name":"大型项目","slug":"大型项目","permalink":"http://newbieqiu.top/tags/%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://newbieqiu.top/tags/SpringBoot/"}]},{"title":"全局异常处理","slug":"全局异常处理","date":"2023-10-07T11:10:59.000Z","updated":"2023-10-07T11:11:24.924Z","comments":true,"path":"2023/10/07/全局异常处理/","link":"","permalink":"http://newbieqiu.top/2023/10/07/%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","excerpt":"","text":"3. 异常处理3.1 当前问题登录功能和登录校验功能我们都实现了，下面我们学习下今天最后一块技术点：异常处理。首先我们先来看一下系统出现异常之后会发生什么现象，再来介绍异常处理的方案。 我们打开浏览器，访问系统中的新增部门操作，系统中已经有了 “就业部” 这个部门，我们再来增加一个就业部，看看会发生什么现象。 点击确定之后，窗口关闭了，页面没有任何反应，就业部也没有添加上。 而此时，大家会发现，网络请求报错了。 状态码为500，表示服务器端异常，我们打开idea，来看一下，服务器端出了什么问题。 上述错误信息的含义是，dept部门表的name字段的值 就业部 重复了，因为在数据库表dept中已经有了就业部，我们之前设计这张表时，为name字段建议了唯一约束，所以该字段的值是不能重复的。 而当我们再添加就业部，这个部门时，就违反了唯一约束，此时就会报错。 我们来看一下出现异常之后，最终服务端给前端响应回来的数据长什么样。 响应回来的数据是一个JSON格式的数据。但这种JSON格式的数据还是我们开发规范当中所提到的统一响应结果Result吗？显然并不是。由于返回的数据不符合开发规范，所以前端并不能解析出响应的JSON数据。 接下来我们需要思考的是出现异常之后，当前案例项目的异常是怎么处理的？ 答案：没有做任何的异常处理 当我们没有做任何的异常处理时，我们三层架构处理异常的方案： Mapper接口在操作数据库的时候出错了，此时异常会往上抛(谁调用Mapper就抛给谁)，会抛给service。 service 中也存在异常了，会抛给controller。 而在controller当中，我们也没有做任何的异常处理，所以最终异常会再往上抛。最终抛给框架之后，框架就会返回一个JSON格式的数据，里面封装的就是错误的信息，但是框架返回的JSON格式的数据并不符合我们的开发规范。 3.2 解决方案那么在三层构架项目中，出现了异常，该如何处理? 方案一：在所有Controller的所有方法中进行try…catch处理 缺点：代码臃肿（不推荐） 方案二：全局异常处理器 好处：简单、优雅（推荐） 3.3 全局异常处理器我们该怎么样定义全局异常处理器？ 定义全局异常处理器非常简单，就是定义一个类，在类上加上一个注解@RestControllerAdvice，加上这个注解就代表我们定义了一个全局异常处理器。 在全局异常处理器当中，需要定义一个方法来捕获异常，在这个方法上需要加上注解@ExceptionHandler。通过@ExceptionHandler注解当中的value属性来指定我们要捕获的是哪一类型的异常。 @RestControllerAdvice public class GlobalExceptionHandler { //处理异常 @ExceptionHandler(Exception.class) //指定能够处理的异常类型 public Result ex(Exception e){ e.printStackTrace();//打印堆栈中的异常信息 //捕获到异常之后，响应一个标准的Result return Result.error(\"对不起,操作失败,请联系管理员\"); } } @RestControllerAdvice = @ControllerAdvice + @ResponseBody 处理异常的方法返回值会转换为json后再响应给前端 重新启动SpringBoot服务，打开浏览器，再来测试一下添加部门这个操作，我们依然添加已存在的 “就业部” 这个部门： 此时，我们可以看到，出现异常之后，异常已经被全局异常处理器捕获了。然后返回的错误信息，被前端程序正常解析，然后提示出了对应的错误提示信息。 以上就是全局异常处理器的使用，主要涉及到两个注解： @RestControllerAdvice //表示当前类为全局异常处理器 @ExceptionHandler //指定可以捕获哪种类型的异常进行处理","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://newbieqiu.top/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://newbieqiu.top/tags/SpringBoot/"}]},{"title":"浅浅了解@Builder注解","slug":"浅浅了解-Builder注解","date":"2023-10-07T08:39:40.000Z","updated":"2023-10-07T08:45:04.761Z","comments":true,"path":"2023/10/07/浅浅了解-Builder注解/","link":"","permalink":"http://newbieqiu.top/2023/10/07/%E6%B5%85%E6%B5%85%E4%BA%86%E8%A7%A3-Builder%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"前言Lombok大家都知道，在使用POJO过程中，它给我们带来了很多便利，省下大量写get、set方法、构造器、equal、toString方法的时间。除此之外，通过@Builder注解，lombok还可以方便的实现建造者模式。 认识@Builder注解lombok注解在java进行编译时进行代码的构建，对于java对象的创建工作它可以更优雅，不需要写多余的重复的代码，这对于JAVA开发人员是很重要的，在出现lombok之后，对象的创建工作更提供Builder方法，它提供在设计数据实体时，对外保持private setter，而对属性的赋值采用Builder的方式，这种方式最优雅，也更符合封装的原则，不对外公开属性的写操作！@Builder声明实体，表示可以进行Builder方式初始化，@Value注解，表示只公开getter，对所有属性的setter都封闭，即private修饰，所以它不能和@Builder现起用 简单使用在项目生成的实体类上，只需要我们添加@Builder注解即可。示例代码： package com.zy.pagehelper.model; import lombok.Builder; import lombok.Data; import java.io.Serializable; @Data @Builder public class Admin implements Serializable { private Long id; private String department; private String email; private String encodedpassword; private String name; private String username; private static final long serialVersionUID = 1L; } 项目中使用。代码实例： Admin admins = Admin.builder() .id(admin.getId()) .name(admin.getName()) .email(admin.getEmail()) .department(admin.getDepartment()) .username(admin.getUsername()) .build(); 根据上面的示例，我们可以对@Builder注解有一个简单的认识。当我们向一个对象赋值的时候，可以通过@Builder注解类似于链式的调用对象进行赋值。它的主要优点就是可以优雅的给对象赋值，修改对象，省去了set方法来定义属性内容。","categories":[{"name":"Builder","slug":"Builder","permalink":"http://newbieqiu.top/categories/Builder/"}],"tags":[{"name":"Builder","slug":"Builder","permalink":"http://newbieqiu.top/tags/Builder/"}]},{"title":"springboot原理篇(略)","slug":"springboot原理篇-略","date":"2023-10-07T08:09:31.000Z","updated":"2023-10-07T08:09:31.590Z","comments":true,"path":"2023/10/07/springboot原理篇-略/","link":"","permalink":"http://newbieqiu.top/2023/10/07/springboot%E5%8E%9F%E7%90%86%E7%AF%87-%E7%95%A5/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"外卖项目之Swagger","slug":"外卖项目之Swagger","date":"2023-10-07T08:00:55.000Z","updated":"2023-10-07T08:05:51.296Z","comments":true,"path":"2023/10/07/外卖项目之Swagger/","link":"","permalink":"http://newbieqiu.top/2023/10/07/%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%B9%8BSwagger/","excerpt":"","text":"Swagger5.1 介绍Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务(https://swagger.io/)。 它的主要作用是： 使得前后端分离开发更加方便，有利于团队协作 接口的文档在线自动生成，降低后端开发人员编写接口文档的负担 功能测试 Spring已经将Swagger纳入自身的标准，建立了Spring-swagger项目，现在叫Springfox。通过在项目中引入Springfox ，即可非常简单快捷的使用Swagger。 knife4j是为Java MVC框架集成Swagger生成Api文档的增强解决方案,前身是swagger-bootstrap-ui,取名kni4j是希望它能像一把匕首一样小巧,轻量,并且功能强悍! 目前，一般都使用knife4j框架。 5.2 使用步骤 导入 knife4j 的maven坐标 在pom.xml中添加依赖 &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; 在配置类中加入 knife4j 相关配置 WebMvcConfiguration.java /** * 通过knife4j生成接口文档 * @return */ @Bean public Docket docket() { ApiInfo apiInfo = new ApiInfoBuilder() .title(\"苍穹外卖项目接口文档\") .version(\"2.0\") .description(\"苍穹外卖项目接口文档\") .build(); Docket docket = new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo) .select() .apis(RequestHandlerSelectors.basePackage(\"com.sky.controller\")) .paths(PathSelectors.any()) .build(); return docket; } 设置静态资源映射，否则接口文档页面无法访问 WebMvcConfiguration.java /** * 设置静态资源映射 * @param registry */ protected void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(\"/doc.html\").addResourceLocations(\"classpath:/META-INF/resources/\"); registry.addResourceHandler(\"/webjars/**\").addResourceLocations(\"classpath:/META-INF/resources/webjars/\"); } 访问测试 接口文档访问路径为 http://ip:port/doc.html —&gt; http://localhost:8080/doc.html 接口测试:测试登录功能 思考：通过 Swagger 就可以生成接口文档，那么我们就不需要 Yapi 了？ 1、Yapi 是设计阶段使用的工具，管理和维护接口 2、Swagger 在开发阶段使用的框架，帮助后端开发人员做后端的接口测试 5.3 常用注解通过注解可以控制生成的接口文档，使接口文档拥有更好的可读性，常用注解如下： 注解 说明 @Api 用在类上，例如Controller，表示对类的说明 @ApiModel 用在类上，例如entity、DTO、VO @ApiModelProperty 用在属性上，描述属性信息 @ApiOperation 用在方法上，例如Controller的方法，说明方法的用途、作用 接下来，使用上述注解，生成可读性更好的接口文档 在sky-pojo模块中 EmployeeLoginDTO.java package com.sky.dto; import io.swagger.annotations.ApiModel; import io.swagger.annotations.ApiModelProperty; import lombok.Data; import java.io.Serializable; @Data @ApiModel(description = \"员工登录时传递的数据模型\") public class EmployeeLoginDTO implements Serializable { @ApiModelProperty(\"用户名\") private String username; @ApiModelProperty(\"密码\") private String password; } EmployeeLoginVo.java package com.sky.vo; import io.swagger.annotations.ApiModel; import io.swagger.annotations.ApiModelProperty; import lombok.AllArgsConstructor; import lombok.Builder; import lombok.Data; import lombok.NoArgsConstructor; import java.io.Serializable; @Data @Builder @NoArgsConstructor @AllArgsConstructor @ApiModel(description = \"员工登录返回的数据格式\") public class EmployeeLoginVO implements Serializable { @ApiModelProperty(\"主键值\") private Long id; @ApiModelProperty(\"用户名\") private String userName; @ApiModelProperty(\"姓名\") private String name; @ApiModelProperty(\"jwt令牌\") private String token; } 在sky-server模块中 EmployeeController.java package com.sky.controller.admin; import com.sky.constant.JwtClaimsConstant; import com.sky.dto.EmployeeLoginDTO; import com.sky.entity.Employee; import com.sky.properties.JwtProperties; import com.sky.result.Result; import com.sky.service.EmployeeService; import com.sky.utils.JwtUtil; import com.sky.vo.EmployeeLoginVO; import io.swagger.annotations.Api; import io.swagger.annotations.ApiOperation; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import java.util.HashMap; import java.util.Map; /** * 员工管理 */ @RestController @RequestMapping(\"/admin/employee\") @Slf4j @Api(tags = \"员工相关接口\") public class EmployeeController { @Autowired private EmployeeService employeeService; @Autowired private JwtProperties jwtProperties; /** * 登录 * * @param employeeLoginDTO * @return */ @PostMapping(\"/login\") @ApiOperation(value = \"员工登录\") public Result&lt;EmployeeLoginVO&gt; login(@RequestBody EmployeeLoginDTO employeeLoginDTO) { //.............. } /** * 退出 * * @return */ @PostMapping(\"/logout\") @ApiOperation(\"员工退出\") public Result&lt;String&gt; logout() { return Result.success(); } } 启动服务：访问http://localhost:8080/doc.html","categories":[{"name":"大型项目","slug":"大型项目","permalink":"http://newbieqiu.top/categories/%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE/"},{"name":"Swagger","slug":"大型项目/Swagger","permalink":"http://newbieqiu.top/categories/%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE/Swagger/"}],"tags":[{"name":"大型项目","slug":"大型项目","permalink":"http://newbieqiu.top/tags/%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE/"},{"name":"Swagger","slug":"Swagger","permalink":"http://newbieqiu.top/tags/Swagger/"}]},{"title":"外卖项目之nginx反向代理和负载均衡","slug":"外卖项目之nginx反向代理和负载均衡","date":"2023-10-07T07:54:23.000Z","updated":"2023-10-07T07:59:21.674Z","comments":true,"path":"2023/10/07/外卖项目之nginx反向代理和负载均衡/","link":"","permalink":"http://newbieqiu.top/2023/10/07/%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%B9%8Bnginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/","excerpt":"","text":"nginx反向代理和负载均衡前端发送的请求，是如何请求到后端服务的？ 前端请求地址：http://localhost/api/employee/login 后端接口地址：http://localhost:8080/admin/employee/login ​ 前端请求地址 后端接口地址 很明显，两个地址不一致，那是如何请求到后端服务的呢？ 1). nginx反向代理 nginx 反向代理，就是将前端发送的动态请求由 nginx 转发到后端服务器 那为什么不直接通过浏览器直接请求后台服务端，需要通过nginx反向代理呢？ nginx 反向代理的好处： 提高访问速度 因为nginx本身可以进行缓存，如果访问的同一接口，并且做了数据缓存，nginx就直接可把数据返回，不需要真正地访问服务端，从而提高访问速度。 进行负载均衡 所谓负载均衡,就是把大量的请求按照我们指定的方式均衡的分配给集群中的每台服务器。 保证后端服务安全 因为一般后台服务地址不会暴露，所以使用浏览器不能直接访问，可以把nginx作为请求访问的入口，请求到达nginx后转发到具体的服务中，从而保证后端服务的安全。 nginx 反向代理的配置方式： server{ listen 80; server_name localhost; location /api/{ proxy_pass http://localhost:8080/admin/; #反向代理 } } proxy_pass：该指令是用来设置代理服务器的地址，可以是主机名称，IP地址加端口号等形式。 如上代码的含义是：监听80端口号， 然后当我们访问 http://localhost:80/api/../..这样的接口的时候，它会通过 location /api/ {} 这样的反向代理到 http://localhost:8080/admin/上来。 接下来，进到nginx-1.20.2\\conf，打开nginx配置 # 反向代理,处理管理端发送的请求 location /api/ { proxy_pass http://localhost:8080/admin/; #proxy_pass http://webservers/admin/; } 当在访问http://localhost/api/employee/login，nginx接收到请求后转到http://localhost:8080/admin/，故最终的请求地址为http://localhost:8080/admin/employee/login，和后台服务的访问地址一致。 2). nginx 负载均衡 当如果服务以集群的方式进行部署时，那nginx在转发请求到服务器时就需要做相应的负载均衡。其实，负载均衡从本质上来说也是基于反向代理来实现的，最终都是转发请求。 nginx 负载均衡的配置方式： upstream webservers{ server 192.168.100.128:8080; server 192.168.100.129:8080; } server{ listen 80; server_name localhost; location /api/{ proxy_pass http://webservers/admin;#负载均衡 } } upstream：如果代理服务器是一组服务器的话，我们可以使用upstream指令配置后端服务器组。 如上代码的含义是：监听80端口号， 然后当我们访问 http://localhost:80/api/../..这样的接口的时候，它会通过 location /api/ {} 这样的反向代理到 http://webservers/admin，根据webservers名称找到一组服务器，根据设置的负载均衡策略(默认是轮询)转发到具体的服务器。 注：upstream后面的名称可自定义，但要上下保持一致。 nginx 负载均衡策略： 名称 说明 轮询 默认方式 weight 权重方式，默认为1，权重越高，被分配的客户端请求就越多 ip_hash 依据ip分配方式，这样每个访客可以固定访问一个后端服务 least_conn 依据最少连接方式，把请求优先分配给连接数少的后端服务 url_hash 依据url分配方式，这样相同的url会被分配到同一个后端服务 fair 依据响应时间方式，响应时间短的服务将会被优先分配 具体配置方式： 轮询： upstream webservers{ server 192.168.100.128:8080; server 192.168.100.129:8080; } weight: upstream webservers{ server 192.168.100.128:8080 weight=90; server 192.168.100.129:8080 weight=10; } ip_hash: upstream webservers{ ip_hash; server 192.168.100.128:8080; server 192.168.100.129:8080; } least_conn: upstream webservers{ least_conn; server 192.168.100.128:8080; server 192.168.100.129:8080; } url_hash: upstream webservers{ hash &amp;request_uri; server 192.168.100.128:8080; server 192.168.100.129:8080; } fair: upstream webservers{ server 192.168.100.128:8080; server 192.168.100.129:8080; fair; }","categories":[{"name":"大型项目","slug":"大型项目","permalink":"http://newbieqiu.top/categories/%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE/"},{"name":"nginx","slug":"大型项目/nginx","permalink":"http://newbieqiu.top/categories/%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE/nginx/"}],"tags":[{"name":"大型项目","slug":"大型项目","permalink":"http://newbieqiu.top/tags/%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE/"},{"name":"nginx","slug":"nginx","permalink":"http://newbieqiu.top/tags/nginx/"}]},{"title":"外卖项目项目结构","slug":"外卖项目项目结构","date":"2023-10-07T07:47:48.000Z","updated":"2023-10-07T07:52:59.657Z","comments":true,"path":"2023/10/07/外卖项目项目结构/","link":"","permalink":"http://newbieqiu.top/2023/10/07/%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"后端环境搭建熟悉项目结构后端工程基于 maven 进行项目构建，并且进行分模块开发。 1).找到后端初始工程： 2). 用 IDEA 打开初始工程，了解项目的整体结构： 对工程的每个模块作用说明： 序号 名称 说明 1 sky-take-out maven父工程，统一管理依赖版本，聚合其他子模块 2 sky-common 子模块，存放公共类，例如：工具类、常量类、异常类等 3 sky-pojo 子模块，存放实体类、VO、DTO等 4 sky-server 子模块，后端服务，存放配置文件、Controller、Service、Mapper等 对项目整体结构了解后，接下来我们详细分析上述的每个子模块： sky-common: 模块中存放的是一些公共类，可以供其他模块使用 分析sky-common模块的每个包的作用： 名称 说明 constant 存放相关常量类 context 存放上下文类 enumeration 项目的枚举类存储 exception 存放自定义异常类 json 处理json转换的类 properties 存放SpringBoot相关的配置属性类 result 返回结果类的封装 utils 常用工具类 sky-pojo: 模块中存放的是一些 entity、DTO、VO 分析sky-pojo模块的每个包的作用： 名称 说明 Entity 实体，通常和数据库中的表对应 DTO 数据传输对象，通常用于程序中各层之间传递数据 VO 视图对象，为前端展示数据提供的对象 POJO 普通Java对象，只有属性和对应的getter和setter sky-server: 模块中存放的是 配置文件、配置类、拦截器、controller、service、mapper、启动类等 分析sky-server模块的每个包的作用： 名称 说明 config 存放配置类 controller 存放controller类 interceptor 存放拦截器类 mapper 存放mapper接口 service 存放service类 SkyApplication 启动类","categories":[{"name":"大型项目","slug":"大型项目","permalink":"http://newbieqiu.top/categories/%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE/"},{"name":"项目结构","slug":"大型项目/项目结构","permalink":"http://newbieqiu.top/categories/%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"大型项目","slug":"大型项目","permalink":"http://newbieqiu.top/tags/%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE/"},{"name":"项目结构","slug":"项目结构","permalink":"http://newbieqiu.top/tags/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据库从入门到入土","slug":"数据库从入门到入土","date":"2023-10-03T04:54:32.000Z","updated":"2023-10-03T05:16:36.403Z","comments":true,"path":"2023/10/03/数据库从入门到入土/","link":"","permalink":"http://newbieqiu.top/2023/10/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/","excerpt":"","text":"1.2 数据模型（理论都不看bushi）在介绍 Mysql的数据模型之前，需要先了解一个概念：关系型数据库。 关系型数据库（RDBMS） 概念：建立在关系模型基础上，由多张相互连接的二维表组成的数据库。 而所谓二维表，指的是由行和列组成的表，如下图： 二维表的优点： 使用表存储数据，格式统一，便于维护 使用SQL语言操作，标准统一，使用方便，可用于复杂查询 我们之前提到的MySQL、Oracle、DB2、SQLServer这些都是属于关系型数据库，里面都是基于二维表存储数据的。 结论：基于二维表存储数据的数据库就成为关系型数据库，不是基于二维表存储数据的数据库，就是非关系型数据库（比如大家后面要学习的Redis，就属于非关系型数据库）。 2). 数据模型 介绍完了关系型数据库之后，接下来我们再来看一看在Mysql数据库当中到底是如何来存储数据的，也就是Mysql 的数据模型。 MySQL是关系型数据库，是基于二维表进行数据存储的，具体的结构图下: 通过MySQL客户端连接数据库管理系统DBMS，然后通过DBMS操作数据库 使用MySQL客户端，向数据库管理系统发送一条SQL语句，由数据库管理系统根据SQL语句指令去操作数据库中的表结构及数据 一个数据库服务器中可以创建多个数据库，一个数据库中也可以包含多张表，而一张表中又可以包含多行记录。 在Mysql数据库服务器当中存储数据，你需要： 先去创建数据库（可以创建多个数据库，之间是相互独立的） 在数据库下再去创建数据表（一个数据库下可以创建多张表） 再将数据存放在数据表中（一张表可以存储多行数据） 1.3 SQL简介SQL：结构化查询语言。一门操作关系型数据库的编程语言，定义操作所有关系型数据库的统一标准。 注释： 单行注释：– 注释内容 或 # 注释内容(MySQL特有) 多行注释： /* 注释内容 */ 以上就是SQL语句的通用语法，这些通用语法大家目前先有一个直观的认识，我们后面在讲解每一类SQL语句的时候，还会再来强调通用语法。 1.3.2 分类SQL语句根据其功能被分为四大类：DDL、DML、DQL、DCL 分类 全称 说明 DDL Data Definition Language 数据定义语言，用来定义数据库对象(数据库，表，字段) DML Data Manipulation Language 数据操作语言，用来对数据库表中的数据进行增删改 DQL Data Query Language 数据查询语言，用来查询数据库中表的记录 DCL Data Control Language 数据控制语言，用来创建数据库用户、控制数据库的访问权限 2. 数据库设计-DDL下面我们就正式的进入到SQL语句的学习，在学习之前先给大家介绍一下我们要开发一个项目，整个开发流程是什么样的，以及在流程当中哪些环节会涉及到数据库。 2.1 项目开发流程 需求文档： 在我们开发一个项目或者项目当中的某个模块之前，会先会拿到产品经理给我们提供的页面原型及需求文档。 设计： 拿到产品原型和需求文档之后，我们首先要做的不是编码，而是要先进行项目的设计，其中就包括概要设计、详细设计、接口设计、数据库设计等等。 数据库设计根据产品原型以及需求文档，要分析各个模块涉及到的表结构以及表结构之间的关系，以及表结构的详细信息。最终我们需要将数据库以及数据库当中的表结构设计创建出来。 开发/测试： 参照页面原型和需求进行编码，实现业务功能。在这个过程当中，我们就需要来操作设计出来的数据库表结构，来完成业务的增删改查操作等。 部署上线： 在项目的功能开发测试完成之后，项目就可以上线运行了，后期如果项目遇到性能瓶颈，还需要对项目进行优化。优化很重要的一个部分就是数据库的优化，包括数据库当中索引的建立、SQL 的优化、分库分表等操作。 在上述的流程当中，针对于数据库来说，主要包括三个阶段： 数据库设计阶段 参照页面原型以及需求文档设计数据库表结构 数据库操作阶段 根据业务功能的实现，编写SQL语句对数据表中的数据进行增删改查操作 数据库优化阶段 通过数据库的优化来提高数据库的访问性能。优化手段：索引、SQL优化、分库分表等 接下来我们就先来学习第一部分数据库的设计，而数据库的设计就是来定义数据库，定义表结构以及表中的字段。 2.3 表操作学习完了DDL语句当中关于数据库的操作之后，接下来我们继续学习DDL语句当中关于表结构的操作。 关于表结构的操作也是包含四个部分：创建表、查询表、修改表、删除表。 2.3.1 创建2.3.1.1 语法create table 表名( 字段1 字段1类型 [约束] [comment 字段1注释 ], 字段2 字段2类型 [约束] [comment 字段2注释 ], ...... 字段n 字段n类型 [约束] [comment 字段n注释 ] ) [ comment 表注释 ] ; 注意： [ ] 中的内容为可选参数； 最后一个字段后面没有逗号 案例：创建tb_user表 对应的结构如下： 建表语句： create table tb_user ( id int comment 'ID,唯一标识', # id是一行数据的唯一标识（不能重复） username varchar(20) comment '用户名', name varchar(10) comment '姓名', age int comment '年龄', gender char(1) comment '性别' ) comment '用户表'; 数据表创建完成，接下来我们还需要测试一下是否可以往这张表结构当中来存储数据。 2.3.1.2 约束概念：所谓约束就是作用在表中字段上的规则，用于限制存储在表中的数据。 作用：就是来保证数据库当中数据的正确性、有效性和完整性。（后面的学习会验证这些） 在MySQL数据库当中，提供了以下5种约束： 约束 描述 关键字 非空约束 限制该字段值不能为null not null 唯一约束 保证字段的所有数据都是唯一、不重复的 unique 主键约束 主键是一行数据的唯一标识，要求非空且唯一 primary key 默认约束 保存数据时，如果未指定该字段值，则采用默认值 default 外键约束 让两张表的数据建立连接，保证数据的一致性和完整性 foreign key 注意：约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束。 案例：创建tb_user表 对应的结构如下： 在上述的表结构中: id 是一行数据的唯一标识 username 用户名字段是非空且唯一的 name 姓名字段是不允许存储空值的 gender 性别字段是有默认值，默认为男 建表语句： create table tb_user ( id int primary key comment 'ID,唯一标识', username varchar(20) not null unique comment '用户名', name varchar(10) not null comment '姓名', age int comment '年龄', gender char(1) default '男' comment '性别' ) comment '用户表'; 大家有没有发现一个问题：id字段下存储的值，如果由我们自己来维护会比较麻烦(必须保证值的唯一性)。MySQL数据库为了解决这个问题，给我们提供了一个关键字：auto_increment（自动增长） 主键自增：auto_increment 每次插入新的行记录时，数据库自动生成id字段(主键)下的值 具有auto_increment的数据列是一个正数序列开始增长(从1开始自增) create table tb_user ( id int primary key auto_increment comment 'ID,唯一标识', #主键自动增长 username varchar(20) not null unique comment '用户名', name varchar(10) not null comment '姓名', age int comment '年龄', gender char(1) default '男' comment '性别' ) comment '用户表'; 2.3.1.3 数据类型在上面建表语句中，我们在指定字段的数据类型时，用到了int 、varchar、char，那么在MySQL中除了以上的数据类型，还有哪些常见的数据类型呢？ 接下来,我们就来详细介绍一下MySQL的数据类型。 MySQL中的数据类型有很多，主要分为三类：数值类型、字符串类型、日期时间类型。 数值类型 类型 大小 有符号(SIGNED)范围 无符号(UNSIGNED)范围 描述 TINYINT 1byte (-128，127) (0，255) 小整数值 SMALLINT 2bytes (-32768，32767) (0，65535) 大整数值 MEDIUMINT 3bytes (-8388608，8388607) (0，16777215) 大整数值 INT/INTEGER 4bytes (-2147483648，2147483647) (0，4294967295) 大整数值 BIGINT 8bytes (-2^63，2^63-1) (0，2^64-1) 极大整数值 FLOAT 4bytes (-3.402823466 E+38，3.402823466351 E+38) 0 和 (1.175494351 E-38，3.402823466 E+38) 单精度浮点数值 DOUBLE 8bytes (-1.7976931348623157 E+308，1.7976931348623157 E+308) 0 和 (2.2250738585072014 E-308，1.7976931348623157 E+308) 双精度浮点数值 DECIMAL 依赖于M(精度)和D(标度)的值 依赖于M(精度)和D(标度)的值 小数值(精确定点数) 示例: 年龄字段 ---不会出现负数, 而且人的年龄不会太大 age tinyint unsigned 分数 ---总分100分, 最多出现一位小数 score double(4,1) 字符串类型 类型 大小 描述 CHAR 0-255 bytes 定长字符串(需要指定长度) VARCHAR 0-65535 bytes 变长字符串(需要指定长度) TINYBLOB 0-255 bytes 不超过255个字符的二进制数据 TINYTEXT 0-255 bytes 短文本字符串 BLOB 0-65 535 bytes 二进制形式的长文本数据 TEXT 0-65 535 bytes 长文本数据 MEDIUMBLOB 0-16 777 215 bytes 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215 bytes 中等长度文本数据 LONGBLOB 0-4 294 967 295 bytes 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295 bytes 极大文本数据 char 与 varchar 都可以描述字符串，char是定长字符串，指定长度多长，就占用多少个字符，和字段值的长度无关 。而varchar是变长字符串，指定的长度为最大占用长度 。相对来说，char的性能会更高些。 示例： 用户名 username ---长度不定, 最长不会超过50 username varchar(50) 手机号 phone ---固定长度为11 phone char(11) 日期时间类型 类型 大小 范围 格式 描述 DATE 3 1000-01-01 至 9999-12-31 YYYY-MM-DD 日期值 TIME 3 -838:59:59 至 838:59:59 HH:MM:SS 时间值或持续时间 YEAR 1 1901 至 2155 YYYY 年份值 DATETIME 8 1000-01-01 00:00:00 至 9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 1970-01-01 00:00:01 至 2038-01-19 03:14:07 YYYY-MM-DD HH:MM:SS 混合日期和时间值，时间戳 示例: 生日字段 birthday ---生日只需要年月日 birthday date 创建时间 createtime --- 需要精确到时分秒 createtime datetime 2.3.2 查询 关于表结构的查询操作，工作中一般都是直接基于图形化界面操作。 查询当前数据库所有表 show tables; 查看指定表结构 desc 表名 ;#可以查看指定表的字段、字段的类型、是否可以为NULL、是否存在默认值等信息 查询指定表的建表语句 show create table 表名 ; 2.3.3 修改 关于表结构的修改操作，工作中一般都是直接基于图形化界面操作。 添加字段 alter table 表名 add 字段名 类型(长度) [comment 注释] [约束]; 案例： 为tb_emp表添加字段qq，字段类型为 varchar(11) alter table tb_emp add qq varchar(11) comment 'QQ号码'; 图形化操作：添加字段 修改数据类型 alter table 表名 modify 字段名 新数据类型(长度); alter table 表名 change 旧字段名 新字段名 类型(长度) [comment 注释] [约束]; 案例：修改qq字段的字段类型，将其长度由11修改为13 alter table tb_emp modify qq varchar(13) comment 'QQ号码'; 案例：修改qq字段名为 qq_num，字段类型varchar(13) alter table tb_emp change qq qq_num varchar(13) comment 'QQ号码'; 图形化操作：修改数据类型和字段名 删除字段 alter table 表名 drop 字段名; 案例：删除tb_emp表中的qq_num字段 alter table tb_emp drop qq_num; 图形化操作：删除字段 修改表名 rename table 表名 to 新表名; 案例：将当前的tb_emp表的表名修改为emp rename table tb_emp to emp; 图形化操作：修改表名 2.3.4 删除 关于表结构的删除操作，工作中一般都是直接基于图形化界面操作。 删除表语法： drop table [ if exists ] 表名; if exists ：只有表名存在时才会删除该表，表名不存在，则不执行删除操作(如果不加该参数项，删除一张不存在的表，执行将会报错)。 案例：如果tb_emp表存在，则删除tb_emp表 drop table if exists tb_emp; -- 在删除表时，表中的全部数据也会被删除。 图形化操作：删除表 3. 数据库操作-DMLDML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进行增、删、改操作。 添加数据（INSERT） 修改数据（UPDATE） 删除数据（DELETE） 3.1 增加(insert)insert语法： 向指定字段添加数据 insert into 表名 (字段名1, 字段名2) values (值1, 值2); 全部字段添加数据 insert into 表名 values (值1, 值2, ...); 批量添加数据（指定字段） insert into 表名 (字段名1, 字段名2) values (值1, 值2), (值1, 值2); 批量添加数据（全部字段） insert into 表名 values (值1, 值2, ...), (值1, 值2, ...); 案例1：向tb_emp表的username、name、gender字段插入数据 -- 因为设计表时create_time, update_time两个字段不能为NULL，所以也做为要插入的字段 insert into tb_emp(username, name, gender, create_time, update_time) values ('wuji', '张无忌', 1, now(), now()); 案例2：向tb_emp表的所有字段插入数据 insert into tb_emp(id, username, password, name, gender, image, job, entrydate, create_time, update_time) values (null, 'zhirou', '123', '周芷若', 2, '1.jpg', 1, '2010-01-01', now(), now()); 案例3：批量向tb_emp表的username、name、gender字段插入数据 insert into tb_emp(username, name, gender, create_time, update_time) values ('weifuwang', '韦一笑', 1, now(), now()), ('fengzi', '张三疯', 1, now(), now()); 图形化操作：双击tb_emp表查看数据 Insert操作的注意事项： 插入数据时，指定的字段顺序需要与值的顺序是一一对应的。 字符串和日期型数据应该包含在引号中。 插入的数据大小，应该在字段的规定范围内。 3.2 修改(update)update语法： update 表名 set 字段名1 = 值1 , 字段名2 = 值2 , .... [where 条件] ; 案例1：将tb_emp表中id为1的员工，姓名name字段更新为’张三’ update tb_emp set name='张三',update_time=now() where id=1; 案例2：将tb_emp表的所有员工入职日期更新为’2010-01-01’ update tb_emp set entrydate='2010-01-01',update_time=now(); 注意事项: 修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据。 在修改数据时，一般需要同时修改公共字段update_time，将其修改为当前操作时间。 3.3 删除(delete)delete语法： delete from 表名 [where 条件] ; 案例1：删除tb_emp表中id为1的员工 delete from tb_emp where id = 1; 案例2：删除tb_emp表中所有员工 delete from tb_emp; 注意事项: ​ • DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据。 ​ • DELETE 语句不能删除某一个字段的值(可以使用UPDATE，将该字段值置为NULL即可)。 ​ • 当进行删除全部数据操作时，会提示询问是否确认删除所有数据，直接点击Execute即可。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://newbieqiu.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"数据库/mysql","permalink":"http://newbieqiu.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://newbieqiu.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"mysql","permalink":"http://newbieqiu.top/tags/mysql/"}]},{"title":"从0开始的前端生活1","slug":"从0开始的前端生活1","date":"2023-09-29T01:58:23.000Z","updated":"2023-09-29T02:19:54.739Z","comments":true,"path":"2023/09/29/从0开始的前端生活1/","link":"","permalink":"http://newbieqiu.top/2023/09/29/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E5%89%8D%E7%AB%AF%E7%94%9F%E6%B4%BB1/","excerpt":"","text":"标签1). 图片标签 img A. 图片标签: &lt;img&gt; B. 常见属性: src: 指定图像的url (可以指定 绝对路径 , 也可以指定 相对路径) width: 图像的宽度 (像素 / 百分比 , 相对于父元素的百分比) height: 图像的高度 (像素 / 百分比 , 相对于父元素的百分比) 备注: 一般width 和 height 我们只会指定一个，另外一个会自动的等比例缩放。 C. 路径书写方式: 绝对路径: 1. 绝对磁盘路径: C:\\Users\\Administrator\\Desktop\\HTML\\img\\news_logo.png &lt;img src=\"C:\\Users\\Administrator\\Desktop\\HTML\\img\\news_logo.png\"&gt; 2. 绝对网络路径: https://i2.sinaimg.cn/dy/deco/2012/0613/yocc20120613img01/news_logo.png &lt;img src=\"https://i2.sinaimg.cn/dy/deco/2012/0613/yocc20120613img01/news_logo.png\"&gt; 相对路径: ./ : 当前目录 , ./ 可以省略的 ../: 上一级目录 2). 标题标签 h 系列 A. 标题标签: &lt;h1&gt; - &lt;h6&gt; &lt;h1&gt;111111111111&lt;/h1&gt; &lt;h2&gt;111111111111&lt;/h2&gt; &lt;h3&gt;111111111111&lt;/h3&gt; &lt;h4&gt;111111111111&lt;/h4&gt; &lt;h5&gt;111111111111&lt;/h5&gt; &lt;h6&gt;111111111111&lt;/h6&gt; B. 效果 : h1为一级标题，字体也是最大的 ； h6为六级标题，字体是最小的。 3). 水平分页线标签 2.3.1.2 标题样式那在HTML的文件中，我们如何来编写CSS样式呢，此时就涉及到CSS的三种引入方式。 2.3.1.2.1 CSS引入方式具体有3种引入方式，语法如下表格所示： 名称 语法描述 示例 行内样式 在标签内使用style属性，属性值是css属性键值对 &lt;h1 style=”xxx:xxx;”&gt;中国新闻网&lt;/h1&gt; 内嵌样式 定义&lt;style&gt;标签，在标签内部定义css样式 &lt;style&gt; h1 {…} &lt;/style&gt; 外联样式 定义&lt;link&gt;标签，通过href属性引入外部css文件 &lt;link rel=”stylesheet” href=”css/news.css”&gt; 对于上述3种引入方式，企业开发的使用情况如下： 内联样式会出现大量的代码冗余，不方便后期的维护，所以不常用。 内部样式，通过定义css选择器，让样式作用于当前页面的指定的标签上。 外部样式，html和css实现了完全的分离，企业开发常用方式。 2.3.1.2.2 颜色表示在前端程序开发中，颜色的表示方式常见的有如下三种： 表示方式 表示含义 取值 关键字 预定义的颜色名 red、green、blue… rgb表示法 红绿蓝三原色，每项取值范围：0-255 rgb(0,0,0)、rgb(255,255,255)、rgb(255,0,0) 十六进制表示法 #开头，将数字转换成十六进制表示 #000000、#ff0000、#cccccc，简写：#000、#ccc 标题字体颜色&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;焦点访谈：中国底气 新思想夯实大国粮仓&lt;/title&gt; &lt;!-- 方式二: 内嵌样式 --&gt; &lt;style&gt; h1 { /* color: red; */ /* color: rgb(0, 0, 255); */ color: #4D4F53; } &lt;/style&gt; &lt;!-- 方式三: 外联样式 --&gt; &lt;!-- &lt;link rel=\"stylesheet\" href=\"css/news.css\"&gt; --&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=\"img/news_logo.png\"&gt; 新浪政务 &gt; 正文 &lt;!-- 方式一: 行内样式 --&gt; &lt;!-- &lt;h1 style=\"color: red;\"&gt;焦点访谈：中国底气 新思想夯实大国粮仓&lt;/h1&gt; --&gt; &lt;h1&gt;焦点访谈：中国底气 新思想夯实大国粮仓&lt;/h1&gt; &lt;hr&gt; 2023年03月02日 21:50 央视网 &lt;hr&gt; &lt;/body&gt; &lt;/html&gt; 备注: 要想拾取某一个网页中的颜色，我们可以借助于浏览器的拾色器插件来完成。 CSS选择器顾名思义：选择器是选取需设置样式的元素（标签），但是我们根据业务场景不同，选择的标签的需求也是多种多样的，所以选择器有很多种，因为我们是做后台开发的，所以对于css选择器，我们只学习最基本的3种。 选择器通用语法如下： 选择器名 { css样式名：css样式值; css样式名：css样式值; } 我们需要学习的3种选择器是元素选择器，id选择器，class选择器，语法以及作用如下： 1.元素（标签）选择器： 选择器的名字必须是标签的名字 作用：选择器中的样式会作用于所有同名的标签上 元素名称 { css样式名:css样式值； } 例子如下： div{ color: red; } 2.id选择器: 选择器的名字前面需要加上# 作用：选择器中的样式会作用于指定id的标签上，而且有且只有一个标签（由于id是唯一的） #id属性值 { css样式名:css样式值； } 例子如下： #did { color: blue; } 3.类选择器： 选择器的名字前面需要加上 . 作用：选择器中的样式会作用于所有class的属性值和该名字一样的标签上，可以是多个 .class属性值 { css样式名:css样式值； } 例子如下： .cls{ color: green; } 发布时间字体颜色&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;焦点访谈：中国底气 新思想夯实大国粮仓&lt;/title&gt; &lt;style&gt; h1 { color: #4D4F53; } /* 元素选择器 */ /* span { color: red; } */ /* 类选择器 */ /* .cls { color: green; } */ /* ID选择器 */ #time { color: #968D92; font-size: 13px; /* 设置字体大小 */ } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=\"img/news_logo.png\"&gt; 新浪政务 &gt; 正文 &lt;h1&gt;焦点访谈：中国底气 新思想夯实大国粮仓&lt;/h1&gt; &lt;hr&gt; &lt;span class=\"cls\" id=\"time\"&gt;2023年03月02日 21:50&lt;/span&gt; &lt;span class=\"cls\"&gt;央视网&lt;/span&gt; &lt;hr&gt; &lt;/body&gt; &lt;/html&gt; 上述我们还使用了一个css的属性 font-size , 用来设置字体的大小。 但是需要注意，在设置字体的大小时，单位px不能省略，否则不生效。 介绍 超链接 标签: &lt;a href=”…” target=”…”&gt;央视网 属性: href: 指定资源访问的url target: 指定在何处打开资源链接 _self: 默认值，在当前页面打开 _blank: 在空白页面打开 标签1). 视频、音频标签 视频标签: &lt;video&gt; 属性: src: 规定视频的url controls: 显示播放控件 width: 播放器的宽度 height: 播放器的高度 音频标签: &lt;audio&gt; 属性: src: 规定音频的url controls: 显示播放控件 2). 段落标签 换行标签: &lt;br&gt; 注意: 在HTML页面中,我们在编辑器中通过回车实现的换行, 仅仅在文本编辑器中会看到换行效果, 浏览器是不会解析的, HTML中换行需要通过br标签 ​ 段落标签: &lt;p&gt; 如: &lt;p&gt; 这是一个段落 &lt;/p&gt; 3). 文本格式标签 效果 标签 标签(强调) 加粗 b strong 倾斜 i em 下划线 u ins 删除线 s del 前面的标签 b、i、u、s 就仅仅是实现加粗、倾斜、下划线、删除线的效果，是没有强调语义的。 而后面的strong、em、ins、del在实现加粗、倾斜、下划线、删除线的效果的同时，还带有强调语义。 注意事项: 在HTML页面中无论输入了多少个空格, 最多只会显示一个。 可以使用空格占位符（&amp;nbsp；）来生成空格，如果需要多个空格，就使用多次占位符。 那在HTML中，除了空格占位符以外，还有一些其他的占位符(了解, 只需要知道空格的占位符写法即可)，如下： 显示结果 描述 占位符 空格 &amp;nbsp; &lt; 小于号 &amp;lt; &gt; 大于号 &amp;gt; &amp; 和号 &amp;amp; “ 引号 &amp;quot; ‘ 撇号 &amp;apos; 页面布局目前，新闻页面的基本排版，我们都已经完成了，但是，大家会看到，无论是标题部分，还是正文部分，都是铺满了整个浏览器。 而我们再来看看新浪新闻的原始页面，我们会看到新闻网页内容都是居中展示的，左边、右边都是一定的边距的。 那接下来呢，我们就需要按照这个效果，来完成页面布局。 而要想完成这样一个页面布局，我们就需要介绍一下CSS中的盒子模型 。 2.3.2.2.1 盒子模型 盒子：页面中所有的元素（标签），都可以看做是一个 盒子，由盒子将页面中的元素包含在一个矩形区域内，通过盒子的视角更方便的进行页面布局 盒子模型组成：内容区域（content）、内边距区域（padding）、边框区域（border）、外边距区域（margin） CSS盒子模型，其实和日常生活中的包装盒是非常类似的，就比如： 盒子的大小，其实就包括三个部分： border、padding、content，而margin外边距是不包括在盒子之内的。 2.3.2.2.2 布局标签 布局标签：实际开发网页中，会大量频繁的使用 div 和 span 这两个没有语义的布局标签。 标签： 特点： div标签： 一行只显示一个（独占一行） 宽度默认是父元素的宽度，高度默认由内容撑开 可以设置宽高（width、height） span标签： 一行可以显示多个 宽度和高度默认由内容撑开 不可以设置宽高（width、height） 测试： &lt;body&gt; &lt;div&gt; A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A &lt;/div&gt; &lt;div&gt; A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A &lt;/div&gt; &lt;span&gt; A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A &lt;/span&gt; &lt;span&gt; A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A &lt;/span&gt; &lt;/body&gt; 浏览器打开后的效果: 1). div会独占一行，默认宽度为父元素 body 的宽度 2). span一行会显示多个，用来组合行内元素，默认宽度为内容撑开的宽度 2.3.2.2.3 盒子模型代码代码如下: &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;盒子模型&lt;/title&gt; &lt;style&gt; div { width: 200px; /* 宽度 */ height: 200px; /* 高度 */ box-sizing: border-box; /* 指定width height为盒子的高宽 */ background-color: aquamarine; /* 背景色 */ padding: 20px 20px 20px 20px; /* 内边距, 上 右 下 左 , 边距都一行, 可以简写: padding: 20px;*/ border: 10px solid red; /* 边框, 宽度 线条类型 颜色 */ margin: 30px 30px 30px 30px; /* 外边距, 上 右 下 左 , 边距都一行, 可以简写: margin: 30px; */ } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 代码编写好了, 可以通过浏览器打开该页面, 通过开发者工具,我们就可以看到盒子的大小, 以及盒子各个组成部分(内容、内边距、边框、外边距)： 我们也可以，通过浏览器的开发者工具，清晰的看到这个盒子，以及每一个部分的大小： 2.3.2.2.3 布局实现在实现新闻页面的布局时，我们需要做两部操作： 第一步：需要将body中的新闻标题部分、正文部分使用一个 div 布局标签将其包裹起来，方便通过css设置内容占用的宽度，比如：65%。 第二步：通过css为该div设置外边距，左右的外边距分别为：17.5%，上下外边距靠边展示即可，为：0%。 具体的代码实现如下： &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;焦点访谈：中国底气 新思想夯实大国粮仓&lt;/title&gt; &lt;style&gt; h1 { color: #4D4F53; } #time { color: #968D92; font-size: 13px; /* 设置字体大小 */ } a { color: black; text-decoration: none; /* 设置文本为一个标准的文本 */ } p { text-indent: 35px; /* 设置首行缩进 */ line-height: 40px; /* 设置行高 */ } #plast { text-align: right; /* 对齐方式 */ } #center { width: 65%; /* margin: 0% 17.5% 0% 17.5% ; */ /* 外边距, 上 右 下 左 */ margin: 0 auto; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"center\"&gt; &lt;!-- 标题 --&gt; &lt;img src=\"img/news_logo.png\"&gt; &lt;a href=\"http://gov.sina.com.cn/\" target=\"_self\"&gt;新浪政务&lt;/a&gt; &gt; 正文 &lt;h1&gt;焦点访谈：中国底气 新思想夯实大国粮仓&lt;/h1&gt; &lt;hr&gt; &lt;span id=\"time\"&gt;2023年03月02日 21:50&lt;/span&gt; &lt;span&gt;&lt;a href=\"https://news.cctv.com/2023/03/02/ARTIUCKFf9kE9eXgYE46ugx3230302.shtml\" target=\"_blank\"&gt;央视网&lt;/a&gt;&lt;/span&gt; &lt;hr&gt; &lt;!-- 正文 --&gt; &lt;!-- 视频 --&gt; &lt;video src=\"video/1.mp4\" controls width=\"950px\"&gt;&lt;/video&gt; &lt;!-- 音频 --&gt; &lt;!-- &lt;audio src=\"audio/1.mp3\" controls&gt;&lt;/audio&gt; --&gt; &lt;p&gt; &lt;strong&gt;央视网消息&lt;/strong&gt; （焦点访谈）：党的十八大以来，以习近平同志为核心的党中央始终把解决粮食安全问题作为治国理政的头等大事，重农抓粮一系列政策举措有力有效，我国粮食产量站稳1.3万亿斤台阶，实现谷物基本自给、口粮绝对安全。我们把饭碗牢牢端在自己手中，为保障经济社会发展提供了坚实支撑，为应对各种风险挑战赢得了主动。连续八年1.3万亿斤，这个沉甸甸的数据是如何取得的呢？ &lt;/p&gt; &lt;p&gt; 人勤春来早，春耕农事忙。立春之后，由南到北，我国春耕春管工作陆续展开，春天的田野处处生机盎然。 &lt;/p&gt; &lt;img src=\"img/1.jpg\"&gt; &lt;p&gt; 今年，我国启动了新一轮千亿斤粮食产能提升行动，这是一个新的起点。2015年以来，我国粮食产量连续8年稳定在1.3万亿斤以上，人均粮食占有量始终稳稳高于国际公认的400公斤粮食安全线。从十年前的约12200亿斤到2022年的约13700亿斤，粮食产量提高了1500亿斤。 &lt;/p&gt; &lt;img src=\"img/2.jpg\"&gt; &lt;p&gt; 中国式现代化一个重要的中国特色是人口规模巨大的现代化。我们粮食生产的发展，意味着我们要立足国内，解决14亿多人吃饭的问题。仓廪实，天下安。保障粮食安全是一个永恒的课题，任何时候都不能放松。在以习近平同志为核心的党中央坚强领导下，亿万中国人民辛勤耕耘、不懈奋斗，我们就一定能够牢牢守住粮食安全这一“国之大者”，把中国人的饭碗牢牢端在自己手中，夯实中国式现代化基础。 &lt;/p&gt; &lt;p id=\"plast\"&gt; 责任编辑：王树淼 SN242 &lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 浏览器打开此页面，最终效果如下： 2.4 表格标签场景：在网页中以表格（行、列）形式整齐展示数据，我们在一些管理类的系统中，会看到数据通常都是以表格的形式呈现出来的，比如：班级表、学生表、课程表、成绩表等等。 标签： &lt;table&gt; : 用于定义整个表格, 可以包裹多个 &lt;tr&gt;， 常用属性如下： border：规定表格边框的宽度 width：规定表格的宽度 cellspacing: 规定单元之间的空间 &lt;tr&gt; : 表格的行，可以包裹多个 &lt;td&gt; &lt;td&gt; : 表格单元格(普通)，可以包裹内容 , 如果是表头单元格，可以替换为 &lt;th&gt; 演示： 代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;HTML-表格&lt;/title&gt; &lt;style&gt; td { text-align: center; /* 单元格内容居中展示 */ } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;table border=\"1px\" cellspacing=\"0\" width=\"600px\"&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;品牌Logo&lt;/th&gt; &lt;th&gt;品牌名称&lt;/th&gt; &lt;th&gt;企业名称&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt; &lt;img src=\"img/huawei.jpg\" width=\"100px\"&gt; &lt;/td&gt; &lt;td&gt;华为&lt;/td&gt; &lt;td&gt;华为技术有限公司&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt; &lt;img src=\"img/alibaba.jpg\" width=\"100px\"&gt; &lt;/td&gt; &lt;td&gt;阿里&lt;/td&gt; &lt;td&gt;阿里巴巴集团控股有限公司&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 打开浏览器，效果如下图所示： 整合表格使用 table 标签包裹 , 其中的每一行数据都是一个 tr , 每一行中的每一个单元格都是一个 td , 而如果是表头单元格, 可以使用 th (具有加粗居中展示的效果)。 2.5 表单标签2.5.1 表单2.5.1.1 介绍那表单呢,在我们日常的上网的过程中,基本上每天都会遇到。比如，我们经常在访问网站时，出现的登录页面、注册页面、个人信息提交页面，其实都是一个一个的表单 。 当我们在这些表单中录入数据之后，一点击 “提交”，就会将表单中我们填写的数据采集到，并提交， 那其实这个数据呢，一般会提交到服务端，最终保存在数据库中 （后面的课程中会讲到）。 那其实，上述的整个窗口是一个表单，而表单是一项一项的，这个我们称为表单项 或 表单元素。 表单场景: 表单就是在网页中负责数据采集功能的，如：注册、登录的表单。 表单标签: &lt;form&gt; 表单属性: action: 规定表单提交时，向何处发送表单数据，表单提交的URL。 method: 规定用于发送表单数据的方式，常见为： GET、POST。 GET：表单数据是拼接在url后面的， 如： xxxxxxxxxxx?username=Tom&amp;age=12，url中能携带的表单数据大小是有限制的。 POST： 表单数据是在请求体（消息体）中携带的，大小没有限制。 表单项标签: 不同类型的input元素、下拉列表、文本域等。 input: 定义表单项，通过type属性控制输入形式 select: 定义下拉列表 textarea: 定义文本域 2.5.1.3 注意事项表单中的所有表单项，要想能够正常的采集数据，在提交的时候能提交到服务端，表单项必须指定name属性。 否则，无法提交该表单项。 用户名: &lt;input type=\"text\" name=\"username\"&gt; 2.5.2 表单项2.5.2.1 介绍在一个表单中，可以存在很多的表单项，而虽然表单项的形式各式各样，但是表单项的标签其实就只有三个，分别是： &lt;input&gt;: 表单项 , 通过type属性控制输入形式。 type取值 描述 text 默认值，定义单行的输入字段 password 定义密码字段 radio 定义单选按钮 checkbox 定义复选框 file 定义文件上传按钮 date/time/datetime-local 定义日期/时间/日期时间 number 定义数字输入框 email 定义邮件输入框 hidden 定义隐藏域 submit / reset / button 定义提交按钮 / 重置按钮 / 可点击按钮 &lt;select&gt;: 定义下拉列表, &lt;option&gt; 定义列表项 &lt;textarea&gt;: 文本域 2.5.2.2 演示创建一个新的表单项的html文件，具体内容如下： &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;HTML-表单项标签&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- value: 表单项提交的值 --&gt; &lt;form action=\"\" method=\"post\"&gt; 姓名: &lt;input type=\"text\" name=\"name\"&gt; &lt;br&gt;&lt;br&gt; 密码: &lt;input type=\"password\" name=\"password\"&gt; &lt;br&gt;&lt;br&gt; 性别: &lt;input type=\"radio\" name=\"gender\" value=\"1\"&gt; 男 &lt;label&gt;&lt;input type=\"radio\" name=\"gender\" value=\"2\"&gt; 女 &lt;/label&gt; &lt;br&gt;&lt;br&gt; 爱好: &lt;label&gt;&lt;input type=\"checkbox\" name=\"hobby\" value=\"java\"&gt; java &lt;/label&gt; &lt;label&gt;&lt;input type=\"checkbox\" name=\"hobby\" value=\"game\"&gt; game &lt;/label&gt; &lt;label&gt;&lt;input type=\"checkbox\" name=\"hobby\" value=\"sing\"&gt; sing &lt;/label&gt; &lt;br&gt;&lt;br&gt; 图像: &lt;input type=\"file\" name=\"image\"&gt; &lt;br&gt;&lt;br&gt; 生日: &lt;input type=\"date\" name=\"birthday\"&gt; &lt;br&gt;&lt;br&gt; 时间: &lt;input type=\"time\" name=\"time\"&gt; &lt;br&gt;&lt;br&gt; 日期时间: &lt;input type=\"datetime-local\" name=\"datetime\"&gt; &lt;br&gt;&lt;br&gt; 邮箱: &lt;input type=\"email\" name=\"email\"&gt; &lt;br&gt;&lt;br&gt; 年龄: &lt;input type=\"number\" name=\"age\"&gt; &lt;br&gt;&lt;br&gt; 学历: &lt;select name=\"degree\"&gt; &lt;option value=\"\"&gt;----------- 请选择 -----------&lt;/option&gt; &lt;option value=\"1\"&gt;大专&lt;/option&gt; &lt;option value=\"2\"&gt;本科&lt;/option&gt; &lt;option value=\"3\"&gt;硕士&lt;/option&gt; &lt;option value=\"4\"&gt;博士&lt;/option&gt; &lt;/select&gt; &lt;br&gt;&lt;br&gt; 描述: &lt;textarea name=\"description\" cols=\"30\" rows=\"10\"&gt;&lt;/textarea&gt; &lt;br&gt;&lt;br&gt; &lt;input type=\"hidden\" name=\"id\" value=\"1\"&gt; &lt;!-- 表单常见按钮 --&gt; &lt;input type=\"button\" value=\"按钮\"&gt; &lt;input type=\"reset\" value=\"重置\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;br&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 通过浏览器打开上述的表单项html文件，最终展示出的表单信息如下： 而对于input type=”hidden”，是一个隐藏域，在表单中并不会显示出来，但是在提交表单的时候，是会提交到服务端的。 接下来，我们就点击提交按钮，来提交当前表单，看看提交的数据： 3. 文档查阅文档地址: https://www.w3school.com.cn/index.html 3.1 HTML文档查阅以video标签为例: 3.2 CSS文档查阅以padding属性为例:","categories":[{"name":"前端","slug":"前端","permalink":"http://newbieqiu.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"html","slug":"html","permalink":"http://newbieqiu.top/tags/html/"},{"name":"css","slug":"css","permalink":"http://newbieqiu.top/tags/css/"}]},{"title":"求求二分不要再折磨我了QAQ","slug":"求求二分不要再折磨我了QAQ","date":"2023-08-10T01:55:43.000Z","updated":"2023-08-10T10:11:02.969Z","comments":true,"path":"2023/08/10/求求二分不要再折磨我了QAQ/","link":"","permalink":"http://newbieqiu.top/2023/08/10/%E6%B1%82%E6%B1%82%E4%BA%8C%E5%88%86%E4%B8%8D%E8%A6%81%E5%86%8D%E6%8A%98%E7%A3%A8%E6%88%91%E4%BA%86QAQ/","excerpt":"","text":"代码随想录算法训练营第一天| 704. 二分查找、27. 移除元素。 题目描述 []: https://www.acwing.com/problem/content/description/791/ 求出序列中第一个大于等于x的元素的位置L以及第一个大于x的元素的位置R，这样元素x在序列中存在的区间就是左闭右开。【L,R） 假如对下标从 0开始，有 5个元素的序列 {1,3,3,3,6}来说，如果要查询 3，则应当得到 L=1、R=4；如果查询 5，则应当得到 L=R=4；如果查询 6，则应当得到L=4、R=5；而如果查询 88，则应当得到 L=R=5。显然，如果序列中没有 x，那么 L和 R也可以理解为假设序列中存在 ，则 x 应当存在的位置。 先来考虑第一小问：求序列中第一个大于等于 x 的元素的位置。假设当前二分区间为 [l,r]，那么根据 mid 位置处的元素与欲查元素 x的大小判断应当往哪个子区间继续查找： ①如果 A[mid]&gt;=x，则说明第一个大于等于 x 的元素的位置，一定在 mid 处或 mid的左侧，应往左子区间 [l,mid]继续查询，即令 r=mid 。 ②如果A[mid]&lt;x，说明第一个大于等于x的元素的位置一定在 mid的的右侧，应往右子区间 [mid+1,r]继续查询，即令 l=mid+1。 相应代码为： // A[]为递增序列，x为欲查询的数，函数返回第一个大于等于x的位置 // 二分上下界为左闭右闭的[l,r]，传入的初值为[0,n] int lower_bound(int A[], int l, int r, int x) { while (l &lt; r) { int mid = l + r &gt;&gt; 1 if (A[mid] &gt;= x) { r = mid; } else { l = mid + 1; } } return l; } 上述代码有几个需要注意的地方： 循环条件为 l&lt;r 而非 l≤r (课本上的二分)，这是由问题本身决定的，“课本上”的二分问题中，查找序列元素不存在时需要返回−1，这样当 l&gt;r 时 [l,r]就不再是闭区间，可以该情况为判定元素不存在的标准，因此 l≤r满足时循环一直进行。但是如果要返回第一个大于等于 x的元素的位置，就不需要判断该元素本身是否存在，因为就算它不存在，返回的也是“假设它存在，它应该在的位置”，于是当 l=r时，[l,r]刚好能夹出唯一的位置，就是需要的结果，因此只要当 l&lt;r时让循环一直执行即可。 由于当 l=r时 while循环停止，因此最后的返回值既可以是 l，也可以是 r。 二分的所有区间应当能覆盖到所有可能返回的结果。首先，二分下界是0是显然的，但是二分上届是 n还是 n−1?考虑到欲查询元素有可能比序列中所有的元素都要大，此时应当返回 n(即假设它存在，它应该在的位置)，因此二分上界是 n，故二分的初始区间为 [l,r]=[0,n]。 接下来解决第二小问：求序列中第一个大于 x的元素的位置。做法是类似的。假设当前区间为 [l,r]，那么可以根据 mid位置的元素与欲查元素 x的大小来判断应往哪个子区间继续查找： ①如果 A[mid]&gt;x，则说明第一个大于 x的元素的位置，一定在 mid处或 mid的左侧，应往左子区间 [l,r]继续查询，即令 r=mid 。 ②如果 A[mid]≤x，说明第一个大于 x的元素的位置一定在 mid的的右侧，应往右子区间 [mid+1,r] 继续查询，即令 l=mid+1。 相应代码为： // A[]为递增序列，x为欲查询的数，函数返回第一个大于x的位置 // 二分上下界为左闭右闭的[l,r]，传入的初值为[0,n] int upper_bound(int A[], int l, int r, int x) { while (l &lt; r) { int mid = l + r &gt;&gt; 1 if (A[mid] &gt; x) { r = mid; } else { l = mid + 1; } } return l; } 通过思考会发现，lower_bound和upper_bound都在解决这样一个问题：寻找有序序列中第一个满足某条件的元素的位置。这是一个非常重要且经典的问题，平时能遇到的大部分二分法问题都可以归结为这个问题。所谓的“某条件”在序列中一定是从左到右先不满足，然后满足的**(否则把该条件取反即可)。** 对lower_bound来说，它寻找的就是第一个满足条件“值大于等于 x”的元素的位置；对upper_bound函数来说，它寻找的是第一个满足“值大于 x ”的元素的位置。 另外，如果要寻找最后一个满足“条件C”的元素的位置，则可以先求第一个满足“条件!C”的元素的位置，然后将该位置减1即可。 分析完毕，在这道题里我们需要用到lower_bound和upper_bound减1。 代码(C++) #include &lt;iostream&gt; using namespace std; const int N = 100010; int a[N]; int main() { int n, q; cin &gt;&gt; n &gt;&gt; q; for (int i = 0; i &lt; n; i ++) cin &gt;&gt; a[i]; while (q --) { int k; cin &gt;&gt; k; // 确定二分区间，这里 r 为 n int l = 0, r = n; while (l &lt; r) { int mid = l + r &gt;&gt; 1; // a[mid] 大于等于 k 说明第一个大于等于 k 的元素一定在 mid 处或 mid 左边 // 右边界变小，更加关注左半区间 if (a[mid] &gt;= k) r = mid; //a[mid] 小于 k 说明第一个大于等于 k 的元素一定在 mid 右边(不包含 mid) // 左边界变大，更加关注右半区间 else l = mid + 1; } // 二分一定有答案，但要检查答案是否正确 // 若序列中没有等于 k 的元素，查找出的是第一个大于 k 的元素的下标 if (a[l] != k) cout &lt;&lt; \"-1 -1\" &lt;&lt; endl; else { cout &lt;&lt; l &lt;&lt; ' '; int l = 0, r = n; while (l &lt; r) { int mid = l + r &gt;&gt; 1; // 不同点在这里的 check 函数 // 这一部分要寻找的是元素 k 的终止位置 // 我们可以理解为求第一个满足大于 k 的位置，再将结果减 1 ，即是最后一个大于等于 k 的位置 if (a[mid] &gt; k) r = mid; else l = mid + 1; } // 这也是我们的 r 要开到 n 的原因，假设我们的目标 k 是 a[n-1] // 那么第一个大于 k 的下标将达到 n ，如果二分区间到不了这，将导致答案错误 cout &lt;&lt; l - 1 &lt;&lt; endl; } } }","categories":[{"name":"算法","slug":"算法","permalink":"http://newbieqiu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://newbieqiu.top/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-10-31T04:05:37.880Z","updated":"2022-04-23T01:20:09.890Z","comments":true,"path":"2022/10/31/hello-world/","link":"","permalink":"http://newbieqiu.top/2022/10/31/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"从0开始的英语语法生活","slug":"从0开始的英语语法生活","date":"2022-08-15T12:45:39.000Z","updated":"2022-08-15T12:47:33.042Z","comments":true,"path":"2022/08/15/从0开始的英语语法生活/","link":"","permalink":"http://newbieqiu.top/2022/08/15/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E7%94%9F%E6%B4%BB/","excerpt":"","text":"简单句什么是英语句子 英语的句子必须具备主语和谓语，并且主语一定 是谓语动作的发出者，如果有宾语，那么宾语一定是谓语动作的承受者或接收者。 基本结构 主谓结构 主谓宾结构 谓语是实义动词 主系(谓)表结构 谓语是实义动词 be 感官动词(look、sound、smell、taste、feel) 变化(become、get、turn、grow、fall) 保持(keep、stay、remain、stand) 表象(seem、appear) 证明(prove) 主谓双宾 主谓宾宾补 如何区别主谓双宾和主谓宾宾补呢？只需要在最后两个宾语中间加个be动词，如果读起来意思是对的是宾补，否则是双宾。 句子的成分 谓语 谓语的成分：有时态的实义动词或系动词； 谓语只能是动词且动词只能作谓语：分析长难句先找动词； 一句话中所有不作谓语的动词都是非谓语动词： 三种变化形式：v-ing(表主动)、v-ed(表被动)、to do(表目的)。 非谓语动词可以作句子中除谓语以外的任意成分。 句子中只能有一个动词并充当谓语，如果有多个动词，那就把最重要的动词设置为谓语，其余动词变为非谓语。 我爱你，你爱我I loving you, you love me.(独立主格) 独立主格(主语不一致)与非谓语(主语一致)本质上相同，只是两分句的主语不同。 冬天来了，春天就不远了Winter approaching, spring will be around the corner. 一句话中必须要有动词，当一句话需要动词而没有动词时，永远都加be动词，且be动词没有含义。 I (am) against you. 谓语的总结：一句话之中有且只有一个有时态的实义动词或系动词的存在，并充当谓语。 主语 主语的成分：名词、代词(与名词一个东西)、非谓语动词、从句(引导词+句子)； Being handsome and strong is his nature.handsomeness and strength are his nature. 句子中绝不能缺少主语，但没有主语怎么办？ 加it作为主语：必须与天气、温度、时间有关系。 It keeps cold in South Pole. there be 句型：当一句话没有主语，并听到”有”的时候使用。 there exist/seem/remainThere exist a sea of private individuals having passion for me. (主语是a sea of private individuals) 被动：没有主语或用人称代词做主语的句子，都可以考虑写成被动。 English must be pointed out exceedingly indispensable.Authorities should be proposed to adopt action. 以下三种情况没有被动： 动词后面有介词，无被动； 系动词无被动； have表达”有”的意思时，无被动； 人称代词作主语(最好不使用) If there exists a dream, glories are supposed to be achieved. 宾语 宾语的成分：名词、代词、非谓语动词、从句； 表语 表语的成分：名词、代词、非谓语动词、从句、介词短语、形容词； 写作中的应用 所有写不来的词汇都可以写成自己会的单词，反正老师也不知道我想表达什么意思； 所有写不来的长难句都可暂时写成简单句 长难句分析 第一步找句子中的动词(谓语)，从而找到一句话的主谓宾； 如果一句话有多个动词出现，就找主句的谓语动词(前面没有引导词的动词)； 动词的分类 实义动词 及物动词(后直接并必须跟宾语)vt: watch TV 不及物动词(后加介词才加宾语，可不加宾语)vi: look at me 系动词 助动词：在一句话中，帮谓语构成时态、被动、否定和疑问的词 情态动词：表明说话人主观态度的词汇。 情态动词表对过去的推测： must have done：一定做过某事 他一定是爱上了我。He must have fallen in love with me. neednot have done：本没必要做某事但做了 你本没必要以这种方式表达你的爱。You neednot have shown your love in this way. could have done：本能够做某事但没做，表遗憾 我本能成为一名优秀的诗人。I could have become a prominent poet. should do：本应该做某事但没做 我们本应该在一起了We should have stayed together 并列句什么是并列句 并列句：在两句话之间加个连词所组成的新句子。 并列连词及逻辑关系词 平行关系 连词 and not only… but also… 逻辑关系词 similarly equally likewise at the same time 转折关系 连词 but yet while whereas 逻辑关系词 however nevertheless on the contrary 选择关系 连词 or whether… or… 逻辑关系词 alternatively 因果关系 连词 for so 逻辑关系词 therefore thus consequently as a result 递进(表递进的没有连词) 逻辑关系词 besides furthermore moreover additionally then(adv.) 写作中的应用 只要写作的上下句有逻辑关系，通常都要用逻辑关系词(连词、副词、介词和介词短语)。 有朋自远方来，不亦乐乎There seems a friend coming from afar, so I feel exceedingly delighted.There seems a friend coming from afar. Consequently I feel exceedingly delighted.There seems a friend coming from afar, and consequently, I feel exceedingly delighted. 连词和其他逻辑关系词的区别在于：连词前有无逗号均可，而其他的逻辑关系词前要么用句号，要么用加连词’and’。 都说我如水百变，不知我清澈不变I am said to be chageable like water, and on the cotrary, my clarity keeps the same. 长难句分析 只要见到连词，通常都会有省略，翻译的时候，先将省略的部分补充后再翻译； 一句话只要有省略，就一定会省略在连词后，而不是连词前； 所以连词后有的成分，连词前通常(如果连词后只有一个成分，连词前一定能找到对应的；如果连词后有多个成分，连词前不一定都能找到对应的成分，但至少能找到一个对应成分)有； 连词前有而连词后没有的就是省略部分； Under modern conditions, this requires varying measures of centrelized control and hence the help of specialized scientists such as economies and operational research experts.先找到主句的谓语动词”requires”，主语是”this”，宾语是”varying measures”；再找到连词”and”，”and”后是名词(the help)+定语，那么”and”前也能找到名词(varying measures)+定语(of centrelized control)，所以”this requires”要加在”hence”与”the”之间。 The data suggest, for example, that physically attractive individuals are more likely to be treated well by their parents, sought out as friends, and pursued romantically.先找到谓语动词”suggest”，主语是”The data”，宾语是由”that”引导的宾语从句；宾语从句的谓语是”are”，主语是”attractive individuals”；再找连词”and”，”and”后是v.-ed+状语，”sought out”是动词，”as friends”是状语，”treated”是动词，”by their parents”是状语，所以后面的两个v.-ed+状语前要加上”more likely to be”。 There is no agreement whether methodology refers to the concepts peculiar to historical work in general or to the research technique appropriate to the various branches historical inquiry.先找到谓语动词”is”，句子的主干是”There is no agreement”，再找连词”whether… or…”， “or”的后面是介词+名词(the research technique)+定语(appropriate to the various branches historical inquiry)，”whether”后也找到介词+名词(the concepts)+定语(peculiar to historical work in general)，”or”与”to”之间省略了”methodology refers” Until these issues are resolved, a technology of behavior will continue to be rejected, and with it possibly the only way to solve our problems.先找主句的谓语”will continue”，”to be continued”是宾语；再找连词”and”，后面跟的是介词短语(with it)+状语(possibly)+名词(the only way)+定语(to solve our problems)，前面只找到名词(a technology)+定语(of behavior)，所以”problems”后面缺少”will continue to be rejected”。 代词指代的原则：就近原则和一致原则(语法和意思上的一致)； 分析长难句的第二步：找连词(当连词在连接两名词时，这个连词就当没看见)； 名词(短语)与名词性从句名词在句子中充当什么成分 名词可以充当主语、宾语、表语、同位语(用来解释名词的成分，只能加在名词后) Overfishing, a universal issue throughout the world(同位语), has become increasingly fearful under modern conditions. 什么是名词性从句 名词在句子中能充当的成分，从句都能充当，这就是名词性从句。 名词性从句包括：主语从句、宾语从句、表语从句、同位语从句。 名词性从句的引导词 名词性从句的引导词是按从句的类型分类，一共把引导词分为三类 that：从句是陈述句，并且that在从句中不充当任何成分，无含义，仅起引导作用。 That he has go divorced is my fault. whether：从句是一般疑问句，whether翻译为：是否，在从句中不充当任何成分，把一般疑问句变为陈述句。 Whether he has got divorced is obvious. 所有特殊疑问词：从句是特殊疑问句， Who he will marry is a secret. 英语中所有的从句一定是陈述句的形式，也就是引导词+主语+谓语的形式。 女人总是对的That ladies tend to be right proves common knowledge.(主语从句)我在思考我应该减肥吗I am wondering whether I should lose my weight.(宾语从句)有一天你会发现：事业、亲情、友情都比爱情重要。One(正式文体中，用one代替you更贴切), some day, will perceive that career, kinship and friendship prove more crucial than romance.(宾语从句)关键是你什么时候有钱呢The point seems when wealth will become available for you.(表语从句)他们为什么离开家乡去西藏是个谜。Why they left the hometown for Tibet keeps a mystery. 写作中的应用 主语从句满分句型 把主语从句放到句末，用it做形式主语 it… that… it is apparent that… it looks beyond dispute that… it has been widely accepted that… it is universally acknowledged that… it keeps my agreement that… 成功属于全力以赴的人，已经被无数个事实所证明。It has been validated by numerous facts that glories belong to those who spare no efforts. 同位语从句满分句型他已经找到了一个女朋友，这件事让他的家人感到很开心。The matter makes his families rejoiced that he has found a girlfriend.没有什么能掩盖她正在变老这个事实。Nothing can hide the truth that she is getting old.她丈夫去世了这个消息传遍了整个村庄。The message that her husband passed away was spread the whole village.温室里的花朵不能经受风雨，这个事实表明我们不应该溺爱孩子。The truth that the flower in the greenhouse fails to undergo storms demonstrates that kids should never be spoiled by their families. 长难句分析 目的：能快速识别各个名词性从句并将其通顺地翻译出来。 如何识别主语从句？ 只要见到有引导词出现在句首，且和主语的谓语动词之间没有逗号，就一定是主语从句，主语从句从引导词开始，到主句的谓语动词结束。 Whether the Government should increase the financing of pure science at the expense of technology or vice versa often depends on the issue of which is seen as the driving force.主句的谓语动词是”depends on”，主语是”Whether the Government should increase the financing of pure science at the expense of technology or vice versa”，”or”的两边是同义词，”以牺牲纯科学保技术”还是”以牺牲技术保科学”； How well the predictions will be validated by later performance depends upon the amount, reliability, and appropriateness of the information used and on the skill and wisdom with which it is interpreted. 主句的谓语动词是”depends on”，主语是”How well the predictions will be validated by later performance”，宾语是”amount, reliability and appropriateness and on the skill and wisdom”，”and”与”on”之间省略了”depends”，”of the information used”修饰”appropriateness”，”with which it is interpreted”修饰”wisdom”；”…with which it is…”中的”it”按就近原则是指”information”。 分析长难句时，见到it…that也通常都是主语从句，主语从句从that开始，到句末结束。 It is generally agreed that a person of high intelligence is one who can grasp ideas readily, make distinctions, reason logically, and make use of verbal and mathematical symbols in solving problems. 先找主句的谓语动词：”is agreed”，”grasp ideas readily”、”make distinctions”、”reason logically”、”make use of symbols”四个定语短语并列。 For example, it has long been known that total sleep deprivation is 100 percent fatal to rats, yet, upon examination of the dead bodies, the animals look completely normat. 先找主句谓语”has been known”，主语从句是两个由”yet”连接的句子构成，两个句子的结构是主系表。 如何识别宾语从句？ 只要实义动词的后面有引导词，通常都是宾语从句(也有可能是状语从句) She said (that) she would marry an old rich man.“that”只有在引导宾语从句时，可省略可不省略；在引导主语从句、表语从句、同位语从句时不能省略。在正式的文体中不要省略所有的”that”。I wonder if I can pass the National Postgraduate Entrance Examination smoothly.“if”作”是否”之意时，只能引导宾语从句，而”whether”可以引导所有的名词性从句。This alone demonstrates that the television bussiness is not an easy world. A fact underlined by statistics shows that out of eightly European television networks no less than 50% look a loss in 1989.“bussiness”作”行业”之意时不可数，作”公司”之意时可数；”out of”有”在…之中””在…之外”两个含义。 如何识别表语从句？ 只要系动词的后面有引导词，通常都是表语从句。 A report consistently brought by visitors to the US is how friendly, courteous and helpful most Americans were to them.这句话的总体结构是主系表，主语是:”A report consistently brought by visitors to the US”，表语是:”how friendly, courteous and helpful most Americans were to them”。 如何识别同位语从句？ 只要在名词后有引导词，就暂定为同位语从句，也有可能是定语从句。 Being interested in the relationship of language and thought, Whorf developed the idea that the structure of language determines the structure of habitual thought in a society.“Being interested in the relationship of language and thought” 是状语从句，” the structure of language determines the structure of habitual thought in a society”是同位语从句，解释”the idea”。 定语与定语从句什么是定语及定语的成分 只要在中文听到”…的”+名词，”…的”就是修饰这个名词(短语)的定语成分。 定语的成分 形容词 The innocent nightingale died.The nightingale innocent and brave died. 名词(短语) The nightingale’s singing can make the rose bloom.The singing of nightingale can make the rose bloom. 介词短语 The nightingale out of the window heard the sighs of the youngster. 非谓语动词 The singing nightingale lost his life. 从句 定语的位置 前小后大：当一个单词修饰名词时，通常放在名词前；当多个单词修饰名词时，通常放在名词后。 This keeps a fiction about a nightingale and a rose.可数名词永远不能单独使用；介词短语作定语。The youngster grasping rommance left the party of the prince.The boy dumped looks pitiful.当过去分词修饰名词时，即使只有一个单词，也放在名词后。I have something important to say.当形容词修饰不定代词时，即使只有一个单词，也放在名词后。 定语从句 定语从句的构成：n.+引导词+句子 定语从句的引导词 引导词按先行词的种类分为5类: 当先行词是人时: who whom whose 当先行词是物时: that(pron.) which(pron.) whose 当先行词是时间时: that(pron.) which(pron.) when(adv.) 当先行词是地点时: that(pron.) which(pron.) where(adv.) 当先行词是原因时: that(pron.) which(pron.) why(adv.) 什么决定了引导词的用法 先行词 引导词在从句中的成分 引导词可以按照引导词本身的词性分为3类： 代词(在从句中一定要充当主语或宾语的成分): who whom that which 副词(在从句中不能充当任何主干成分): where when why 形容词(在从句中修饰离它最近的名词): whose Boys whose families keep wealthy never fail to fascinate me. The rose that the nightingale exchanged with his life was discarded. The senior citizen passed away on the day when his son arrived. 定语从句的特殊用法 that做引导词时的省略 当that引导定语从句且充当宾语时，可省略。 如果见到两个名词或代词直接连接在一起，中间没有任何标点符号或连词，通常都是省略了”that”的定语从句。 区别限制和非限制性定语从句 I love liu who is beautiful.限制性定语从句，我喜欢美丽的刘。I love liu, who is beautiful.非限制性定语从句，我喜欢刘，她很漂亮。 非限制性定语从句相当于插入语，可以忽略；限制性定语从句一定要添加进句子中翻译出来，不可忽略。 先行词和引导词之间有介词的情况 “人”用”whom”不用”who”，”物”用”which”不用”that”。 Gump is a man from whom we should learn. I will never forget the day on which I met you.“on”后面需要加名词或代词，不能加副词”when”。 区别 the same … as; the same … that 引导的定语从句 He is the same man as I love.他就像我爱的那个男人。 He is the same man that I love.他就是我爱的那个男人。 as和which引导的非限制性定语从句的区别 “which”引导的非限制性定语从句可以修饰前面整句话，”as”也可以，但”which”引导的非限制性定语从句只能放在句子后面，而”as”引导的可前可后。 My husband enjoys chatting with other young ladies, which drives me mad. As drives me mad, my husband enjoys chatting with other young ladies. 定语从句中引导词”which”和”that”的区别 区分定语从句和同位语从句 I have a dream that sounds ridiculous. I have a dream that I become a rich lady. 定语从句是对前面名词的修饰，同位语从句是对前面名词的解释。 看引导词”that”在从句中是否充当了成分，如果充当了就是定语从句，否则是同位语从句。 定语从句的先行词可以是所有名词，而同位语从句的先行词只能是抽象名词。 定语从句的引导词一共有8个，而同位语从句的引导词只有”that”。 定语从句难点 寻找先行词 定语从句的先行词就是离它最近的名词 定语从句的先行词是它前面并列的名词 定语从句的先行词是它前面的从句 定语从句的先行词是它前面的整个句子 定语从句的先行词和引导词之间被其他成分隔开 写作中的应用 Raising pets looking strikingly cute as well as smart can reduce loneliness of senior citizens who have no any descendants. Reading books which are benifical to both physical and mental health of youngsters can broaden horizon of readers. Reading books such as a Nightingale and a Rose, Little Prince can broaden horizon. 只要在作文中见到名词，都可以加定语加长句子。 英汉差异对比 汉语注重”意合”，英语注重”形合” 句子结构 逻辑关系词的使用 汉语多”主动”，英语多”被动” Couplets are put on doors to add the atmosphere of festivals. 汉语多”短句”，英语多”长句” 非谓语 连词 从句 Wuzhen is a water town in zhejiang province, locating near the river from beijing to hangzhou. I, going to play football yesterday, came across a lady whose daughter looked cute. 长难句分析 找到一句话中的定语成分，并把它们通顺翻译出来 找定语的关键是：找名词(n+定语/同位语/插入语/谓语/状语)，只要名词后有一堆东西且这堆东西不是谓语，就暂定为定语成分(还没讲到状语)。 如果定语在主语谓语动词之前，定语从名词开始，到主句的谓语动词前结束；如果定语在主语谓语动词之后，定语从名词开始，到句末结束，但是，如果定语后有连词，定语就在连词前结束。 一个大定语中通常会有若干个小定语，每个小定语都是到下一个名词结束，但固定搭配除外(例allow sb. to do sth.)。 In short, a leader of the new school contends, “the scientific revolution, as we call it, was largely the improvement and invention and use of a series of instructments that expanded the reach of science in innumerable directions”.“of the new school”修饰”a leader”，主句谓语动词是”contend”，”of a series of instructments that expanded the reach of science in innumerable directions”修饰”the improvement and invention and use”，其中，谓语1是”of a series”，谓语2是”of instructments”，谓语3是”that expanded the reach”，谓语4是”of science”，谓语5是”in innumerable directions”。 In Europe, as elsewhere, multi-media groups have been increasingly successful groups which bring together television, radio, newspapers, magazines and publishing houses that work in relation to one another.“bring together”是”整合”之意。 Creating a “European identity” that respects the different cultures and traditions which go to make up the connecting fabric of the Old Continent is no easy task and demands a strategic choice.主句是: Creating a “European identity” is no easy task and demands a strategic choice. 定语1是”that respects the different cultures and traditions”，定语2是”which go to make up the connecting fabric of the Old Continent”。 Astrophysicists working with ground-based detectors at the South Pole and ballon-borne instruments are closing in on such structures, and may report their findings soon.“working with ground-based detectors at the South Pole and ballon-borne instruments”是非谓语，修饰”astrophysicists”，”and”与”ballon-borne instruments”之间省略了”working with”，”are closing in on”是谓语动词(“探究”之意) After six months of arguing and final 16 hours of hot parliamentary debates, Australia’s Northern Territory became the first legal authority in the world to allow doctors to take the lives of incurably ill patients who wish to die.“of arguing”是定语1，”of hot parliamentary debates”是定语2，”in the world”是定语3，”to allow doctors to take the lives”是定语4(这里注意allow…to是固定搭配)，”of incurably ill patients who wish to die”是定语5。 Whether to use tests, other kinds of information, or both in a particular situation depends, therefore, upon the evidence from experience concerning comparative validity and upon such factors as costs and availability.“or”与”both”之间省略了”to use”，”in a particular situation”是状语，”and”与”upon”之间省略了”depends”，”depends”是主句谓语动词。 状语与状语从句形容词、副词的成分 形容词 作表语、定语 —— 修饰名词 副词 修饰形容词、实义动词、副词、句子 什么是状语 状语：在句子中修饰形容词、实义动词、副词以及整个句子的成分。 状语在一句话中除了名词(由定语修饰)外，其他都可修饰。 状语的成分 副词(短语) 介词短语 非谓语 从句 状语的位置 随便放 状语从句 引导词的分类标准：按引导词本身的意思分类，一共把引导词分为9类。 状语从句的时态问题 When love comes, I will hold her hands.在所有的状语从句中，如果主句和从句的动作都尚未发生，主句用一般将来时，从句用一般现在时表将来。 When love came, I failed to hold her hands.在所有的状语从句中，如果主句和从句的动作都发生了，该用什么时态就用什么时态。 作文中只要出现形容词或副词的地方，都可以使用”so…that”。 状语的9种分类 时间状语从句 引导词 when = while = as，”while”翻译为”当…的时候”时，后面一定跟进行时态。 before after since the moment = as soon as by the time until not … until 区别until与not…until I will wait here until you come.I will not leave until you come.主句的谓语动词是瞬间动词还是延续性动词，如果是延续性动词就用”until”；如果是瞬间动词就用”not…until”。 地点状语从句 引导词 where The tree grows well in wet places.The tree grows well where it is wet. 原因状语从句 引导词 because as since in that seeing that considering that now that given that 连词 for 介词短语 because of due to owing to thanks to for the sake of as result of He had a car accident because he was careless.He had a car accident for he was careless.He had a car accident because of his carelessness.状语可以放在句子的任意位置；连词的作用是连接两个句子，只能放在后面 目的状语从句 动词不定式 in order to so as to 引导词 so that in order that We climb higher in order that we can see farther.(further表示抽象意义上的远)We climb higher in order to see farther. 结果状语从句 引导词 so…that such…that I feel so delighted that I cannot help shouting and jumping. 方式状语从句 引导词(好像、似乎) as the way as if/though 介词短语 by/by means of in…way/manner He talks with me as if he had known(虚拟语气) me three years ago. 条件状语从句 引导词 suppose that supposing that if unless(=if not 表否定的假设) provided that as long as(=if 只要) so long as 比较状语从句 引导词 as…as… 比较结构(than) You look as beautiful as I (look).(I look是从句，look一般省略) 让步状语从句 引导词 although though even though even if as while(翻译为”虽然、尽管”，只能放在句首，不能放在句中) She is a beauty although she seems lazy.Pursuing stars exerts influence on the study of students although their singing sounds touching. 写作中的应用 作文中任何一句话旁，都可以加状语 长难句分析 能快速找到一句话中的状语成分，并通顺地翻译出来 句子中以下部分都是状语 副词 条件状语从句 原因状语从句 目的状语从句 结果状语从句 让步状语从句 方式状语从句 比较状语从句 伴随状语(with) 时间和地点放在名词后，可能是定语，也可能是状语，当无法确定定语或状语，定语优先，只有翻译为定语很不通顺的时候就是状语。 状语和状语从句通常翻译在离它最近的那句话的前面，或那句话的主谓之间。 The Greeks assumed that the structure of language had some connection with the process of thought, which took root in Europe long before people realized how diverse languages could be.“ have some connection with”是固定搭配，”in Europe”是地点状语，”long before people realized how diverse languages could be”是时间状语从句。 Social science is that branch of intellectual enquiry which seeks to study humans and their endeavors in the same reasoned, orderly, systematic, and dispassioned manner that natural scientists use for the study of natural phenomena.“of intellectual … phenomena”是定语，修饰”that branch”，”in the same reasoned, orderly, systematic, and dispassioned manner”是状语，”natural … phenomena”修饰”manner”。 The behavioral sciences have been slow to change partly because the explanatory items often seem to be directly observed and partly because other kinds of explanations have been hard to find.“partly because … and partly because …” 两个并列的原因状语从句。 While it is easy to ignore in our contact with them the effect of our acts upon their disposition, it is not so easy as in dealing with adults.“in our contact with them”、”as in dealing with adults”与”while … disposition”是状语，”in our contact with them”要放在”while”后翻译 Although mental health is the cure-all for living our lives, it is perfectly ordinary as you will see that it has been there to direct you through all you difficult decisions.“Although … lives”与”as … decisions”是状语，”through all you difficult decisions”是状语，翻译时插在”that”与”it”之间。 句子所有成分总结 句子主干 主语：名词 代词 非谓语 从句 谓语：实义动词 系动词 宾语：名词 代词 非谓语 从句 表语：名词 代词 非谓语 从句 形容词 介词短语 句子枝叶 定语：名词 代词 非谓语 从句 形容词 介词短语 状语：副词 介词短语 非谓语 从句 同位语：名词 代词 非谓语 从句 My mother is an elegant lady.My mother is a lady of elegance.My mother is a lady as elegant as a lily.My mother is a lady proving elegant.My mother is a lady who proves elegant. He killed his wife cruelly.As cruelly as a monster, he killed his wife.He, detaching the body, killed his wife.He killed his wife when he detached her body. 长难句的模样：(状语)主语(定语/同位语/状语)+谓语(时态/语态)+宾语(定语/同位语/状语) When I heard one of his songs named long time no see, I, an English teacher, love Eason whose singing sounds touching. English, a useful communicating tool, is important in the general routine of everyday living. 特殊结构强调句 it is … that …(不能强调谓语) 我昨天在街上遇到了我的旧情人I met my old flame in the street yesterday. 就是在我的女儿出生以后，我才意识到母亲的伟大It is After my daughter was born that I realized that greatness of mothers. There exist a sea of causes to explain my perspective.It is a sea of causes that there exist to explain my perspective. 强调句型的翻译：去掉it is…that… 还原为句子本来的样子后再翻译。 But it is the arrival of new satellite channels - funded partly by advertising and partly by viewers’ subscriptions - that will bring about the biggest changes in the long term.句子的主干是:”the arrival of new satellite channels will bring about the biggest changes.” Perhaps it is humankind’s long suffering at the mercy of flood and drought that makes the idea of force the waters to do our bidding so fascinating.句子的主干是:”humankind’s long suffering makes the idea so fascinating.” 主语从句与强调句型的区别在于：把it is … that …去掉后，句子仍然通顺的话，就是强调句型，否则是主语从句。 As was discussed before, it was not until the 19th that the newspaper became the dominant pre-electronic medium, following in the wake of the pamphlet and the book and in the company of the periodical.句子的主干是:”not until the 19th, the newspaper became the dominant pre-electronic medium.” 倒装句 什么是倒装？—— 把一句话写成一般疑问句的形式，也就是给一句话提一个助动词或be动词放在句首。 倒装的具体用法 否定词放在句首用倒装 Never will I love you.Pets not only do harm to their neighbors and families but also pollute the enviroment.Not only do pets do harm to their neighbors and families but also pollute the enviroment. so, nor/neither位于句首，表明承前句子的肯定或否定时用倒装 So can I.Nor can I. 含有so…that…结构的句子将so引导的部分置于句首时用倒装 I feel so delighted that I cannot help jumping and dancing.So delighted do I feel that I cannot help jumping and dancing. only 引出的状语位于句首时用倒装 I love you only in my mind.Only in my mind do I love you. as 引导让步状语从句，从句(主系表结构)的表语可以放在句首构成部分(不加助动词)倒装 As I am ugly, I am gentle.Ugly as I am, I am gentle.As he is a teacher, he keeps common.teacher as he is, he keeps common.(可数名词单独使用) 省略if的虚拟语气用倒装 倒装的考点分析 写作：所有的倒装都是写作的满分句型 在任何情况下，父母都不能忽略培养孩子自信的重要性Under no circumstances can parents fail to shed light on cultivating the confidence of their children. I feel so exhausted that I have no any strength all over.So exhausted do I feel that I have no any strength all over. 只有在自己的家里，我才感到安全和放松Only at home do I feel safe and relaxed. 长难句分析 识别倒装：只要在一句话中见到一般疑问句的形式，通常都是倒装。 倒装的翻译方法：还原倒装部分后再作翻译。 For example, they do not compensate for gross social inequality, and thus do not tell how able an underprivileged youngster might have been had he grown up under more favorable circumstance.“had he grown up”属于省略”if”的虚拟语气用倒装，正常语序应是”if he had grown up”，”thus”与”do”之间省略了”they”。 虚拟语气 虚拟语气表示与事实相反或是语气委婉 虚拟语气的一般用法 如何将一个正常的条件状语从句变为虚拟语气？ 把写好的句子的时态变为它的过去式即可 注意 虚拟语气中，所有be动词的过去式通常是were，不用was would = could = might If you are a tear in my eyes, I will never shed it. (if引导的条件状语从句)If you were a tear in my eyes, I would never shed it. If I was a dog, I could sleep with you. (if引导的条件状语从句)If I had been a dog, I could have slept with you. If I still remember you in my next life, we will definely stay together.If I still remembered you in my next life, we would definely stay together.Did I still remember you, we would definely stay together. If you followed me at the beginning, you could pass the examination smoothly.If you had followed me at the beginning, you could have passed the examination smoothly.had you follow me at the beginning, you could have passed the examination smoothly. 虚拟语气的特殊用法 以下情况从句用”should+v.”表示虚拟，并且should可以省略 以防: in case that; for fear that; lest 命: order; direct; command 贱(建议): suggest; advice; propose 要求: ask; request; require; demand 用虚拟 是必要的: it is necessary (important) that In case that it (should) rain, you had better stay at home.It seems necessary that authorities should inspire their citizens to protect our environment. 以下情况从句用过去时表示虚拟 would rather it is high time that … I would rather you will happier than me 特殊用法(以下情况特殊对待) 把它本来的时态变为过去式即可 wish if only(如果…多好) but for(要不是) or/otherwise(否则) as if/as though(好像，似乎) He treats me as if I were his son.He treats me as if I had been his son. 长难句分析 无论句子有没有使用虚拟语气，都可以直接翻译 The millions of calculations involved, had they been done by hand, would have lost all practical value by the time they were finished.“ had they been done by hand”的正常语序是”if they had been done by hand” Countless divorced politicians would have been elected out of office years ago had they even thought of a divorce, let alone gotten one.“had they even thought”的正常语序是”if they had even thought” 插入语 插入语 —— 放在主谓之间，用逗号或破折号隔开的部分 常用的插入语 副词作插入语 介词短语作插入语 不定式短语作插入语 分词作插入语 现在分词短语作插入语","categories":[{"name":"英语","slug":"英语","permalink":"http://newbieqiu.top/categories/%E8%8B%B1%E8%AF%AD/"},{"name":"英语语法","slug":"英语/英语语法","permalink":"http://newbieqiu.top/categories/%E8%8B%B1%E8%AF%AD/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"英语","slug":"英语","permalink":"http://newbieqiu.top/tags/%E8%8B%B1%E8%AF%AD/"}]},{"title":"JAVA 注解","slug":"JAVA-注解","date":"2022-07-11T01:47:41.000Z","updated":"2022-07-11T01:56:06.459Z","comments":true,"path":"2022/07/11/JAVA-注解/","link":"","permalink":"http://newbieqiu.top/2022/07/11/JAVA-%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"JAVA 注解一、注解是什么？ 在Java中注解其实就是写在接口、类、属性、方法上的一个标签，或者说是一个特殊形式的注释，与普通的//或/**/注释不同的是：普通注释只是一个注释，而注解在代码运行时是可以被反射读取并进行相应的操作，而如果没有使用反射或者其他检查，那么注解是没有任何真实作用的，也不会影响到程序的正常运行结果。 举个例子@Override就是一个注解，它的作用是告诉阅读者(开发人员、编译器)这个方法重写了父类的方法，对于开发人员只是一个标志，而编译器则会多做一些事情，编译器如果发现方法标注了这个注解，就会检查这个方法到底是不是真的覆写了父类的方法，如果没有那就是在欺骗他的感情，甭废话，编译时直接给你报个错，不留情面的那种。而如果不添加@Override注解，程序也是可以正常运行的，不过缺乏了静态的检查，本来是想覆写父类的hello方法的，却写成了he110方法，这就会有些尴尬了。 在spring框架中加注的注解会影响到程序的运行，是因为spring内部使用反射操作了对应的注解。 上面的说法是为了方便理解的，那么下面来个稍微正式一点的：注解是提供一种为程序元素设置元数据的方法，理解起来还是一样的，程序元素就是指接口、类、属性、方法，这些都是属于程序的元素，那啥叫元数据呢？就是描述数据的数据(data about data)，举个简单的例子，系统上有一个sm.png文件，这个文件才是我们真正需要的数据本身，而这个文件的属性则可以称之为sm.png的元数据，是用来描述png文件的创建时间、修改时间、分辨率等信息的，这些信息无论是有还是没有都不影响它作为图片的性质，都可以使用图片软件打开。 元数据是添加到程序元素如方法、字段、类和包上的额外信息，注解就是一种载体形式注解不能直接干扰程序代码的运行 三、为什么要使用注解？ 以Spring为例，早期版本的Spring是通过XML文件的形式对整个框架进行配置的，一个缩减版的配置文件如下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\"&gt; &lt;!-- 配置事物管理器 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; &lt;!-- 配置注解驱动事物管理 --&gt; &lt;tx:annotation-driven transaction-manager=\"transactionManager\"/&gt; &lt;/beans&gt; 在xml文件中可以定义Spring管理的Bean、事物切面等，话说当年非常流行xml配置的。优点呢就是整个项目的配置信息集中在一个文件中，从而方便管理，是集中式的配置。缺点也显而易见，当配置信息非常多的时候，配置文件会变得越来越大不易查看管理，特别是多人协作开发时会导致一定的相互干扰。 现在都提倡解耦、轻量化或者说微小化，那么注解就顺应了这一需求，各个包或模块在内部方法或类上使用注解即可实现指定功能，而且使用起来灰常方便，简单易懂。缺点呢就是不方便统一管理，如果需要修改某一类功能，则需要整体搜索逐个修改，是分散式的存在各个角落。 这里扩充一下，Spring注解替代了之前Spring xml文件，是不是说spring的xml也是一种元数据呢？对的，spring的配置文件xml也是元数据的一种表现形式。不过xml的方式是集中式的元数据，不需要和代码绑定的，而注解是一种分散式的元数据设置方式。 三、注解的作用 作为 Java开发几乎都使用过一些框架，相信大家对注解的作用都是有所体会的，这里再啰嗦几句加深印象。根本来说注解就是一个注释标签。开发者的视角可以解读出这个类/方法/属性的作用以及该怎么使用，而从框架的视角则可以解析注解本身和其属性实现各种功能，编译器的角度则可以进行一些预检查(@Override)和抑制警告(@SuppressWarnings)等。 作为特定标记，用于告诉编译器一些信息编译时动态处理，如动态生成代码运行时动态处理，作为额外信息的载体，如获取注解信息 四、注解的分类 通常来说注解分为以下三类 元注解 – java内置的注解，标明该注解的使用范围、生命周期等。标准注解 – Java提供的基础注解，标明过期的元素/标明是复写父类方法的方法/标明抑制警告。自定义注解 – 第三方定义的注解，含义和功能由第三方来定义和实现。4.1 元注解 用于定义注解的注解，通常用于注解的定义上，标明该注解的使用范围、生效范围等。元XX 都代表最基本最原始的东西，因此，元注解就是最基本不可分解的注解，我们不能去改变它只能使用它来定义自定义的注解。元注解包含以下五种： @Retention、@Target、@Documented、@Inherited、@Repeatable，其中最常用的是@Retention和@Target下面分别介绍一下这五种元注解。 @Retention ★★★★★中文翻译为保留的意思，标明自定义注解的生命周期 @Documented @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.ANNOTATION_TYPE) public @interface Retention { RetentionPolicy value(); } 从编写Java代码到运行主要周期为源文件→ Class文件 → 运行时数据，@Retention则标注了自定义注解的信息要保留到哪个阶段，分别对应的value取值为SOURCE →CLASS→RUNTIME。 SOURCE 源代码java文件，生成的class文件中就没有该信息了CLASS class文件中会保留注解，但是jvm加载运行时就没有了RUNTIME 运行时，如果想使用反射获取注解信息，则需要使用RUNTIME，反射是在运行阶段进行反射的示例：当RentionPolicy取值为SOURCE时，Class文件中不会保留注解信息，而取值为CLASS时，Class反编译文件中则保留了注解的信息 各个生命周期的用途： Source：一个最简单的用法，就是自定义一个注解例如@ThreadSafe，用来标识一个类时线程安全的，就和注释的作用一样，不过更引人注目罢了。Class：这个有啥用呢？个人觉得主要是起到标记作用，还没有做实验，例如标记一个@Proxy，JVM加载时就会生成对应的代理类。Runtime：反射实在运行阶段执行的，那么只有Runtime的生命周期才会保留到运行阶段，才能被反射读取，也是我们最常用的。@Target ★★★★★中文翻译为目标，描述自定义注解的使用范围，允许自定义注解标注在哪些Java元素上(类、方法、属性、局部属性、参数…) @Documented @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.ANNOTATION_TYPE) public @interface Target { ElementType[] value(); } value是一个数组，可以有多个取值，说明同一个注解可以同时用于标注在不同的元素上。value的取值如下 值 说明TYPE 类、接口、注解、枚举FIELD 属性MEHOD 方法PARAMETER 方法参数CONSTRUCTOR 构造函数LOCAL_VARIABLE 局部变量(如循环变量、catch参数)ANNOTATION_TYPE 注解PACKAGE 包TYPE_PARAMETER 泛型参数 jdk1.8TYPE_USE 任何元素 jdk1.8示例：自定义一个注解@MyAnnotation1想要用在类或方法上，就可以如下定义 @Retention(RetentionPolicy.RUNTIME)@Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.TYPE, ElementType.METHOD}) public @interface MyAnnotation { String description() default \"\"; } @MyAnnotation public class AnnotationTest { // @MyAnnotation 用在属性上则会报错 public String name; @MyAnnotation public void test(){} } @Inherited ★★是否可以被标注类的子类继承。被@Inherited修饰的注解是具有继承性的，在自定义的注解标注到某个类时，该类的子类会继承这个自定义注解。这里需要注意的是只有当子类继承父类的时候，注解才会被继承，类实现接口，或者接口继承接口，都是无法获得父接口上的注解声明的。正确的示例如下(通过反射获取注解) @Repeatable ★★是否可以重复标注。这个注解其实是一个语法糖，jdk1.8之前也是有办法进行重复标注的，就是使用数组属性（自定义注解会讲到）。下面给一个例子，虽然我们标注的是多个@MyAnnotation，其实会给我们返回一个@MyAnnotations，相当于是Java帮我们把重复的注解放入了一个数组属性中，所以只是一个语法糖而已。 @Documented ★是否在生成的JavaDoc文档中体现，被标注该注解后，生成的javadoc中，会包含该注解，这里就不做演示了。 5.2 标准注解标准注解有一下三个 @Override 标记一个方法是覆写父类方法@Deprecated 标记一个元素为已过期，避免使用 支持的元素类型为：CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE @SuppressWarnings 不输出对应的编译警告比较常用且固定，下面给出一个简单示例 @SuppressWarnings(value = {\"unused\", \"rawtypes\"}) public class StandardDemo extends Parent{ @Override public void sayHello() { // unused 声明了list却没有使用 // rawtypes 创建了泛型类却没有指定元素类型 List list = new ArrayList(); } @Deprecated public void walk() { } } 5.3 自定义注解注解定义格式 public @interface 注解名 { 修饰符 返回值 属性名() 默认值; 修饰符 返回值 属性名() 默认值; } 首先注解的修饰符一般是public的，定义注解一般都是要给三方使用的，不是public的又有什么意义呢？定义的类型使用@interface，可以猜出来和接口是有一些说不清道不明的关系的，其实注解就是一个接口，在程序运行时，JVM会为其生成对应的代理类。 然后内部的定义，这个有点四不像，说是方法吧它还有一个默认值，说它是属性吧它的后面还加了一个括号，我个人还是喜欢称之为带默认返回值的接口方法，通过后面的学习我们会进一步认识它的真面目。内部的修饰符只能是public的，即使不写也默认是public的，因为它本质上就是一个接口，而接口方法的默认访问权限就是pubilc的。 注解是不能继承也不能实现其他类或接口的，本身就是一个元数据了，确实没什么必要。 返回值支持的类型如下 基本类型 int float boolean byte double char logn shortStringClassEnumAnnotation以上所有类型的数组类型定义一个简单的接口示例 // 保留至运行时@Retention(RetentionPolicy.RUNTIME)// 可以加在方法或者类上@Target(value = {ElementType.TYPE,ElementType.METHOD})public @interface RequestMapping { public String method() default “GET”; public String path(); public boolean required();}123456789接下来我们来看下它到底是不是一个接口 首先编译一下该注解javac RequestMapping.java生成对应的RequestMapping.class文件，然后对其进行反编译javap -v RequestMapping,输出如下 // …①public interface RequestMapping extends java.lang.annotation.Annotation //… ②public abstract java.lang.String method(); descriptor: ()Ljava/lang/String; flags: ACC_PUBLIC, ACC_ABSTRACT AnnotationDefault: ③default_value: s#7 public abstract java.lang.String path(); descriptor: ()Ljava/lang/String; flags: ACC_PUBLIC, ACC_ABSTRACT public abstract boolean required(); descriptor: ()Z flags: ACC_PUBLIC, ACC_ABSTRACT}//… 123456789101112131415161718① 从这里可以看到，注解的本质就是一个接口，并且继承了java.lang.annotation.Annotation ② ③这里验证了上面所说的，内部的定义其实就是一个带默认值的方法 六、使用反射操作注解 反射的相关知识就不多做介绍了，不太了解的同学可以看下我的另外一篇博客Java反射学习总结。反射可以获取到Class对象，进而获取到Constructor、Field、Method等实例，点开源码结构发现Class、Constructor、Field、Method等均实现了AnnotatedElement接口，AnnotatedElement接口的方法如下 // 判断该元素是否包含指定注解，包含则返回trueboolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)// 返回该元素上对应的注解，如果没有返回null T getAnnotation(Class annotationClass);// 返回该元素上的所有注解，如果没有任何注解则返回一个空数组Annotation[] getAnnotations();// 返回指定类型的注解，如果没有返回空数组T[] getAnnotationsByType(Class annotationClass)// 返回指定类型的注解，如果没有返回空数组，只包含直接标注的注解，不包含inherited的注解T getDeclaredAnnotation(Class annotationClass)// 返回指定类型的注解，如果没有返回空数组，只包含直接标注的注解，不包含inherited的注解T[] getDeclaredAnnotationsByType// 返回该元素上的所有注解，如果没有任何注解则返回一个空数组，只包含直接标注的注解，不包含inherited的注解Annotation[] getDeclaredAnnotations();1234567891011121314这就说明以上元素均可以通过反射获取该元素上标注的注解。 来一个完整的示例，show you the code // package-info.java@AnyAnnotation(order = 0, desc = “包”)package demo.annotation.reflect; // AnyAnnotation.java@Retention(RetentionPolicy.RUNTIME)@Target(value = {ElementType.PACKAGE, ElementType.TYPE, ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.FIELD, ElementType.LOCAL_VARIABLE, ElementType.PARAMETER})public @interface AnyAnnotation { int order() default 0; String desc() default “”;} // ReflectAnnotationDemo.java@AnyAnnotation(order = 1, desc = “我是类上的注释”)public class ReflectAnnotationDemo { @AnyAnnotation(order = 2, desc = \"我是成员属性\") private String name; @AnyAnnotation(order = 3, desc = \"我是构造器\") public ReflectAnnotationDemo(@AnyAnnotation(order = 4, desc = \"我是构造器参数\") String name) { this.name = name; } @AnyAnnotation(order = 45, desc = \"我是方法\") public void method(@AnyAnnotation(order = 6, desc = \"我是方法参数\") String msg) { @AnyAnnotation(order = 7, desc = \"我是方法内部变量\") String prefix = \"I am \"; System.out.println(prefix + msg); } public static void main(String[] args) throws NoSuchFieldException, NoSuchMethodException { Class&lt;ReflectAnnotationDemo&gt; clazz = ReflectAnnotationDemo.class; // 获取包上的注解，声明在package-info.java文件中 Package packagee = Package.getPackage(\"demo.annotation.reflect\"); printAnnotation(packagee.getAnnotations()); // 获取类上的注解 Annotation[] annotations = clazz.getAnnotations(); printAnnotation(annotations); // 获取成员属性注解 Field name = clazz.getDeclaredField(\"name\"); Annotation[] annotations1 = name.getAnnotations(); printAnnotation(annotations1); //获取构造器上的注解 Constructor&lt;ReflectAnnotationDemo&gt; constructor = clazz.getConstructor(String.class); AnyAnnotation[] annotationsByType = constructor.getAnnotationsByType(AnyAnnotation.class); printAnnotation(annotationsByType); // 获取构造器参数上的注解 Parameter[] parameters = constructor.getParameters(); for (Parameter parameter : parameters) { Annotation[] annotations2 = parameter.getAnnotations(); printAnnotation(annotations2); } // 获取方法上的注解 Method method = clazz.getMethod(\"method\", String.class); AnyAnnotation annotation = method.getAnnotation(AnyAnnotation.class); printAnnotation(annotation); // 获取方法参数上的注解 Parameter[] parameters1 = method.getParameters(); for (Parameter parameter : parameters1) { printAnnotation(parameter.getAnnotations()); } // 获取局部变量上的注解 /** * 查了一些资料，是无法获取局部变量的注解的，且局部变量的注解仅保留到Class文件中，运行时是没有的。 * 这个更多是给字节码工具使用的，例如lombok可以嵌入编译流程，检测到有对应注解转换成相应的代码， * 而反射是无法进行操作的。当然也可以利用asm等工具在编译器完成你要做的事情 */ } public static void printAnnotation(Annotation... annotations) { for (Annotation annotation : annotations) { System.out.println(annotation); } } }12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576感兴趣的同学可以将@AnyAnnotation的Retention中的生命周期改为SOURCE/CLASS试试，这时就获取不到任何注解信息了哦 七、注解的底层实现-动态代理首先准备一下测试代码，如下 @Retention(value = RetentionPolicy.RUNTIME)@Target(value = ElementType.TYPE)public @interface Learn { String name() default “default”; int age();} @Learn(age = 12)public class LearnAnnotationReflect { public static void main(String[] args) { Class&lt;LearnAnnotationReflect&gt; clazz = LearnAnnotationReflect.class; // 判断class元素是否存在对应的注解 if (!clazz.isAnnotationPresent(Learn.class)) { return; } // 获取相应的注解，并打印属性 Learn learn = clazz.getAnnotation(Learn.class); System.out.println(learn.name()); System.out.println(learn.age()); } }12345678910111213141516171819202122 在System.out.println(learn.name());打一个断点，以Debug模式运行，查看learn这个对象到底是什么 从上面的截图可以看出，jdk为Learn生成了一个叫$Proxy1的代理对象，并且包含了一个内部成员AnnotationIvocationHandler，接下来就是调用$Proxy1.name()进行获取name的值，那么我们来看下$Proxy1到底是一个什么样的对象，在jdk8中可以添加JVM参数-Dsun.misc.ProxyGenerator.saveGeneratedFiles来保存代理类，更高版本可以使用-Djdk.proxy.ProxyGenerator.saveGeneratedFiles=true来保存代理类。在Idea中的设置方法如下 重新运行程序，就会发现在项目根目录多了如下类，其中$Proxy1就是Learn注解对应的代理类 当我们调用Learn.name()时，其实就是调用这个代理类的name方法，如下 public final String name() throws { try { return (String)super.h.invoke(this, m3, (Object[])null); } catch (RuntimeException | Error var2) { throw var2; } catch (Throwable var3) { throw new UndeclaredThrowableException(var3); } } 123456789 代理类的name方法中主要是调用h的invoke方法传入当前对象，以及m3这个方法元素，m3如下 m3 = Class.forName(“demo.annotation.runtime.Learn”).getMethod(“name”);1 在5.3讲解的内容时，我们反编译了注解的class文件，知道在编译注解时，实际上编译为了一个接口，接口中定义了想干的属性的方法。 那么基本的流程我们就可以梳理出来了： 通过反射我们可以获取对应元素上的注解@Learn，前面说过注解本质是一个接口，也就是获取到了Learn接口的代理对象。Learn代理对象提供了相应的同名方法，内部声明了原注解的相应方法Method，如method3之后通过代理对象父类的h成员属性，也就是AnnotationInvocationHandler去执行invoke方法AnnotationInvocationHandler在初始化时，会包含一个memberValues的map，key就是方法名，value就是对应的属性值，在invoka内部通过Method的name从memberValues中获取到对应的值并返回 接下来我们来看下AnnotationInvocationHandler中的invoke方法相关信息，如下 // 当前注解类型private final Class&lt;? extends Annotation&gt; type;// 当前注解的相关属性集合，key是方法名，value是对应的值private final Map&lt;String, Object&gt; memberValues; // jdk会将对应的属性信息传过来AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) { this.type = var1; this.memberValues = var2; } public Object invoke(Object var1, Method var2, Object[] var3) { // 方法名 String var4 = var2.getName(); // 参数类型 Class[] var5 = var2.getParameterTypes(); // 如果是equals方法，则调用对应方法 if (var4.equals(“equals”) &amp;&amp; var5.length == 1 &amp;&amp; var5[0] == Object.class) { return this.equalsImpl(var3[0]); // 不是equals方法，却有参数，说明是错误的，注解的方法是不允许有参数的 } else if (var5.length != 0) { throw new AssertionError(“Too many parameters for an annotation method”); } else { // 定义一个变量var7 默认值-1 byte var7 = -1; // 不同的方法赋予var7不同的值 switch(var4.hashCode()) { case -1776922004: if (var4.equals(“toString”)) { var7 = 0; } break; case 147696667: if (var4.equals(“hashCode”)) { var7 = 1; } break; case 1444986633: if (var4.equals(“annotationType”)) { var7 = 2; } } // 返回对应方法的处理 switch(var7) { case 0: return this.toStringImpl(); case 1: return this.hashCodeImpl(); case 2: return this.type; // 默认方法, 也就是我们自定义的属性方法 default: // 从map集合中获取对应的值 Object var6 = this.memberValues.get(var4); if (var6 == null) { throw new IncompleteAnnotationException(this.type, var4); } else if (var6 instanceof ExceptionProxy) { throw ((ExceptionProxy)var6).generateException(); } else { if (var6.getClass().isArray() &amp;&amp; Array.getLength(var6) != 0) { var6 = this.cloneArray(var6); } return var6; } } } } 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970跟着源码debug几次就能明白整体流程了 八、总结：注解工作流程通过键值对的形式为注解属性赋值编译器检查注解的使用范围 (将注解信息写入元素属性表 attribute)运行时JVM将单个Class的runtime的所有注解属性取出并最终存入map里创建AnnotationInvocationHandler实例并传入前面的mapJVM使用JDK动态代理为注解生成代理类，并初始化处理器调用invoke方法，通过传入方法名返回注解对应的属性值————————————————版权声明：本文为CSDN博主「KimZing」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/KingBoyWorld/article/details/105337011","categories":[{"name":"注解","slug":"注解","permalink":"http://newbieqiu.top/categories/%E6%B3%A8%E8%A7%A3/"},{"name":"Spring前置","slug":"注解/Spring前置","permalink":"http://newbieqiu.top/categories/%E6%B3%A8%E8%A7%A3/Spring%E5%89%8D%E7%BD%AE/"}],"tags":[{"name":"注解","slug":"注解","permalink":"http://newbieqiu.top/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"Spring前置","slug":"Spring前置","permalink":"http://newbieqiu.top/tags/Spring%E5%89%8D%E7%BD%AE/"}]},{"title":"反射机制","slug":"反射","date":"2022-07-03T02:28:52.000Z","updated":"2022-07-04T02:26:24.618Z","comments":true,"path":"2022/07/03/反射/","link":"","permalink":"http://newbieqiu.top/2022/07/03/%E5%8F%8D%E5%B0%84/","excerpt":"","text":"反射允许程序在运行时来进行自我检查并且对内部的成员进行操作 反射主要是指程序可以访问，检测和修改它本身状态或行为的一种能力，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。 反射机制的作用： ·在运行时判断任意一个对象所属的类； · 在运行时获取类的对象； ·在运行时访问Java对象的属性，方法，构造方法等； java.lang.reflect类库里面主要的类： ·Field：表示类中的成员变量 ·Method：表示类中的方法 ·Constructor：表示类的构造方法 ·Array：该类提供了动态创建数组和访问数组元素的静态方法 反射以来的class用来表示运行时类型信息的对应类 CLass类的特点： ·Class类也是类的一种，class则是关键字； ·Class类只有一个私有的构造函数，只有JVM能够创建Class类的实例 ·JVM中只有唯一一个和类相对应的Class对象来描述其类型信息* 获取Class对象的三种方式： 1.Object ——&gt;getClass()； 2.任何数据类型（包括基本数据类型）都有一个“静态”的class属性 3.通过Class类的静态方法：forName(String className具体路径)（常用） 在运行期间，一个类，只有一个与之相对应的Class对象产生 反射的主要用法： 如何获取类的构造方法并使用 获取构造方法：* 1).批量的方法：* public Constructor[] getConstructors()：所有”公有的”构造方法 public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)* 2).获取单个的方法，并调用：* public Constructor getConstructor(Class… parameterTypes):获取单个的”公有的”构造方法：* public Constructor getDeclaredConstructor(Class… parameterTypes):获取”某个构造方法”可以是私有的，或受保护、默认、公有； * 调用构造方法：* Constructor–&gt;newInstance(Object… initargs) 用于创建实例 可以看出私有并不安全 如何获取类的成员变量并使用 getDeclaredField(String name)—-获取指定name名称的(包含private修饰)字段，不包括继承的字段 getDeclaredField()—-获取Class对象所表示的类或接口的所有(包含private修饰)字段，不包括继承的字段 getField(String name)—-获取指定name名称、具有public修饰的字段，包含继承字段； getField()—-获取修饰符为public的字段，包含继承字段； 1.批量的* 1).Field[] getFields():获取所有的”公有字段”* 2).Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有；*** 2.获取单个的：*** 1).public Field getField(String fieldName):获取某个”公有的”字段；* 2).public Field getDeclaredField(String fieldName):获取某个字段(可以是私有的)**** 设置字段的值：*** Field –&gt; public void set(Object obj,Object value):* 参数说明：* 1.obj:要设置的字段所在的对象；* 2.value:要为字段设置的值； 如何获取类的成员方法并使用 获取成员方法并调用：** 1.批量的：* public Method[] getMethods():获取所有”公有方法”；（包含了父类的方法也包含Object类）* public Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的)* 2.获取单个的：* public Method getMethod(String name,Class... parameterTypes): \\* 参数： \\* name : 方法名； \\* Class ... : 形参的Class类型对象 \\* public Method getDeclaredMethod(String name,Class… parameterTypes)** 调用方法：* Method –&gt; public Object invoke(Object obj,Object… args):* 参数说明：* obj : 要调用方法的对象；* args:调用方式时所传递的实参；","categories":[{"name":"Spring源码前置","slug":"Spring源码前置","permalink":"http://newbieqiu.top/categories/Spring%E6%BA%90%E7%A0%81%E5%89%8D%E7%BD%AE/"}],"tags":[{"name":"Spring源码前置","slug":"Spring源码前置","permalink":"http://newbieqiu.top/tags/Spring%E6%BA%90%E7%A0%81%E5%89%8D%E7%BD%AE/"}]},{"title":"各种工厂设计模式","slug":"各种工厂设计模式","date":"2022-06-30T03:25:24.000Z","updated":"2022-07-03T01:58:50.508Z","comments":true,"path":"2022/06/30/各种工厂设计模式/","link":"","permalink":"http://newbieqiu.top/2022/06/30/%E5%90%84%E7%A7%8D%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"各种工厂设计模式1. 简单工厂模式 开闭原则 一个软件实体，如类、模块、函数，应该对扩展开放，对修改关闭； 比如现在新增一个Mouse实体类，需要在工厂类中新增判断条件，修改代码，故违反开闭原则。 每种设计模式都有利有弊，要根据实际情况选择具体的设计模式 工厂方法模式工厂方法模式是简单工厂模式的进一步深化。在工厂方法模式中，不再提供一个统一的工厂类来创建所有的对象，而是针对不同的对象提供不同的工厂。 也就是说，每个对象，都有一个与之对的工厂。 定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类。 这意味着，工厂方法使一个类的实例化延迟到了子类当中 工厂方法模式的优缺点：优点： 1.遵循开闭原则； 2.对客户端隐藏对象的创建细节； 3.遵循单一职责原则，即每个具体工厂类只负责创建对应的产品。 工厂方法模式是对简单工厂模式的进一步抽象和扩展，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态的体现。 缺点： 1.添加子类的时候“拖家带口”； 2.只支持同一类产品的创建； 抽象工厂模式 抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口抽象工厂模式侧重于同一产品族，比如鼠标和键盘组成键鼠套装，组成同一个产品族工厂方法模式更加侧重于同一产品等级 抽象工厂模式：解决了工厂模式只生产一种产品的弊端新增一个产品族，之只需要增加一个新的具体工厂，不需要修改代码对工厂模式进行了抽象 工厂方法模式：每个抽象产品派生多个具体产品类，每个抽象工厂类派生多个具体工厂类，每个具体工厂类负责一个具体产品的实例创建 抽象工厂模式：每个抽象产品派生多个具体产品类，每个抽象工厂派生多个具体工厂类，每个具体工厂负责一系列具体产品的实例创建。 可行性调研：当更多类型的Controller被加入到工程时，需要新增Controller的创建方法，甚至需要往工厂的具体类里面增加实现类。比如生产额外的主板，需要修改原代码添加新产品的时候，依旧违背开闭原则，增加系统复杂度 z自此工厂模式相关的牌已经打完：结合了工厂模式和反射机制的Spring IOC容器值得借鉴","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://newbieqiu.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Spring源码前置","slug":"设计模式/Spring源码前置","permalink":"http://newbieqiu.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Spring%E6%BA%90%E7%A0%81%E5%89%8D%E7%BD%AE/"}],"tags":[{"name":"Spring源码前置","slug":"Spring源码前置","permalink":"http://newbieqiu.top/tags/Spring%E6%BA%90%E7%A0%81%E5%89%8D%E7%BD%AE/"},{"name":"设计模式","slug":"设计模式","permalink":"http://newbieqiu.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"DispatherServlet","slug":"DispatherServlet","date":"2022-06-30T03:00:37.000Z","updated":"2022-06-30T03:13:14.213Z","comments":true,"path":"2022/06/30/DispatherServlet/","link":"","permalink":"http://newbieqiu.top/2022/06/30/DispatherServlet/","excerpt":"","text":"DispatherServletservlet 到 controller 减少Servlet的数量,一个servlet对应一个实体类？ 一个servlet对应一个页面? 若一个页面出现两个Get相同请求，则doGet方法指代不清晰 当servlet匹配到对应的请求，会调用相应的service方法 根据springMVC的设计，设计一个servlet解析和派发类，负责派发请求到具体servlet去执行 @WebServlet(“/“)可以拦截几乎所有的请求，只要ip+port+serverRootPath是对的，不管后面子路径是什么，都可以被拦截，也就是被Servlet所处理； @WebServlet(“/*”)表示会拦截所有的请求，发起请求后会造成死循环，原因是：req.getRequestDispatcher(“/WEB-INF/jsp/hello.jsp”).forward(req, resp);也是一次GET请求，所以同样会走到service方法，再调用doGet，从而造成这种循环调用 请求的拦截设置：@WebServlet(“/“)可以拦截几乎所有的请求 处理请求的参数，根据请求的参数来决定调用controller里面哪个具体的方法，改写继承service方法：解析相关的请求并进行处理。请求从参数request里面获取请求的路径以及请求的方法。然后根据获取的请求路径和请求方法选择合适的Controller进行处理 按照不同的URL路径和请求进行派发的思路 具体的请求处理是由特定的controller来进行的；controller对接的是前端发送过来的请求，和业务以及数据源的关联不是很大。不用定义接口，而是直接使用类来进行对接 controller层只需要做的工作，参数校验以及请求参数转化 最后在dispatchservlet根据不同的请求路径以及请求方法，调用不同的controller里面的不同的方法PS: 优先级：精确匹配&gt;路径匹配&gt;拓展名匹配&gt;反斜杠/ @WebServlet(“/“)并不会拦截.jsp的请求，Servlet对.jsp的请求进行了特殊的处理。/虽然会匹配到所有的请求，但它是Servlet中 获取请求路径、请求方法，匹配到具体的controller去处理。@WebServlet(“/“)System.out.println(“request path is : “ + req.getServletPath());System.out.println(“request method is : “ + req.getMethod());","categories":[{"name":"自研框架","slug":"自研框架","permalink":"http://newbieqiu.top/categories/%E8%87%AA%E7%A0%94%E6%A1%86%E6%9E%B6/"},{"name":"源码前置基础","slug":"自研框架/源码前置基础","permalink":"http://newbieqiu.top/categories/%E8%87%AA%E7%A0%94%E6%A1%86%E6%9E%B6/%E6%BA%90%E7%A0%81%E5%89%8D%E7%BD%AE%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"自研框架","slug":"自研框架","permalink":"http://newbieqiu.top/tags/%E8%87%AA%E7%A0%94%E6%A1%86%E6%9E%B6/"},{"name":"源码前置基础","slug":"源码前置基础","permalink":"http://newbieqiu.top/tags/%E6%BA%90%E7%A0%81%E5%89%8D%E7%BD%AE%E5%9F%BA%E7%A1%80/"}]},{"title":"项目依赖配置与门面模式","slug":"项目依赖配置与门面模式","date":"2022-06-29T02:19:59.000Z","updated":"2022-06-29T02:27:03.404Z","comments":true,"path":"2022/06/29/项目依赖配置与门面模式/","link":"","permalink":"http://newbieqiu.top/2022/06/29/%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E9%85%8D%E7%BD%AE%E4%B8%8E%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"项目依赖配置与门面模式 slf4j-api是日志的门面接口 slf4j-api不负责具体的实现，只负责在编译时找到具体的实现进行绑定； slf4j-log412是适配层，便可以不用关心日志框架底层的实现，通过统一的这条语句获取log类对象 按功能来说，只引入log4j的依赖就能使用日志框架就可以了，但是可能其它的jar包引入了别的日志框架进来，这个时候系统就不得不支持并维护多种日志框架了，通过门面模式来兼容多种日志框架","categories":[{"name":"自研框架","slug":"自研框架","permalink":"http://newbieqiu.top/categories/%E8%87%AA%E7%A0%94%E6%A1%86%E6%9E%B6/"},{"name":"设计模式","slug":"自研框架/设计模式","permalink":"http://newbieqiu.top/categories/%E8%87%AA%E7%A0%94%E6%A1%86%E6%9E%B6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"自研框架","slug":"自研框架","permalink":"http://newbieqiu.top/tags/%E8%87%AA%E7%A0%94%E6%A1%86%E6%9E%B6/"},{"name":"设计模式","slug":"设计模式","permalink":"http://newbieqiu.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"泛型复习","slug":"泛型复习","date":"2022-06-29T02:05:14.000Z","updated":"2022-06-29T02:18:55.649Z","comments":true,"path":"2022/06/29/泛型复习/","link":"","permalink":"http://newbieqiu.top/2022/06/29/%E6%B3%9B%E5%9E%8B%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"泛型（generics）复习泛型包括泛型类泛型接口和泛型方法泛型类 泛型的参数不支持基本类型（int等） 泛型相关的信息不会进入到运行时（编译后就会被擦除） 能否在泛型里面使用继承关系的类 ​ 使用通配符 ？，但是会使得泛型的类型检查失去意义 ​ 给泛型加上上边界 ？extends E ​ 给泛型加入下边界 ？super E List&lt;? super Number&gt; list= new ArrayList&lt;&gt;();//只能放 // Number number = list.get(0);编译报错，只能用Object来接收 List&lt;? extends Number&gt; list= new ArrayList&lt;&gt;();//只能取 Number number = list.get(0); list.add(1);//编译报错，不确定集合元素是何种类型 泛型接口（可以直接实现泛型接口，也可以用泛型类实现泛型接口） 泛型方法(可以在泛型类接口或普通方法里面，有泛型标识符 public static void xxx 泛型里面的 T（或别的字母） 是独立于泛型接口或者类的)","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://newbieqiu.top/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://newbieqiu.top/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"Spring源码——Spring模块梳理","slug":"Spring源码——Spring模块梳理","date":"2022-06-28T01:21:41.000Z","updated":"2022-06-28T01:40:39.995Z","comments":true,"path":"2022/06/28/Spring源码——Spring模块梳理/","link":"","permalink":"http://newbieqiu.top/2022/06/28/Spring%E6%BA%90%E7%A0%81%E2%80%94%E2%80%94Spring%E6%A8%A1%E5%9D%97%E6%A2%B3%E7%90%86/","excerpt":"","text":"Spring源码——Spring 模块梳理Spring基础架构图) 重点是“Core Container”中的Beans，Core，Context以及AOP Spring架构 Spring-core IOC&amp;DI(依赖注入) 包含框架的核心工具类，其它组件都要使用到这个包里的类 定义并提供资源的访问方式 Spring-beans：Spring主要面向Bean编程（BOP） *主要注意BeanFacyory这个接口* Bean的定义 Bean的解析 Bean的创建 Spring-context 是bean之间关系的集合 核心接口：ApplicationContext 是BeanFactory的超类 为Spring提供运行时环境，保存对象的状态 **扩展了BeanFactory ** Spring-aop：最小化的动态代理实现，只使用aspectj里的注解功能 JDK动态代理模式：基于接口实现的 Cglib：基于类实现的 共同点：只能运行时织入，仅支持方法级编织，仅支持方法执行切入点 模块之间的依赖可以通过源码里的gradle文件进行查看 spring-aspectj +spring-instrument：Full AspectJ ) weaving 指织入","categories":[{"name":"Spring源码","slug":"Spring源码","permalink":"http://newbieqiu.top/categories/Spring%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"Spring源码","slug":"Spring源码","permalink":"http://newbieqiu.top/tags/Spring%E6%BA%90%E7%A0%81/"}]},{"title":"java8 stream().map().collect()的用法","slug":"java8-stream-map-collect-的用法","date":"2022-06-17T06:21:01.000Z","updated":"2022-06-17T06:29:05.242Z","comments":true,"path":"2022/06/17/java8-stream-map-collect-的用法/","link":"","permalink":"http://newbieqiu.top/2022/06/17/java8-stream-map-collect-%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"java8 中stream().map().collect()的用法List&lt;UserFollowing&gt; fanList = userFollowingDao.getUserFans(userId); Set&lt;Long&gt; fanIdSet = fanList.stream().map(UserFollowing::getUserId).collect(Collectors.toSet()); 有一个集合 fanList 现在想获取User的Id；在后续的逻辑处理中要用； 常用的方法我们大家都知道，用for循环， List id=new ArrayList();//定义一个集合来装 for(int i=0;i&lt;UserFollowing.size();i++){ id.add(UserFollowing.get(i).getUserId()); } 这种方法要写好几行代码，有没有简单点的，如下 Set fanIdSet = fanList.stream().map(UserFollowing::getUserId).collect(Collectors.toSet()); 解释下一这行代码： fanList：一个实体类的集合，类型为ListUserFollowing：实体类getUserId：实体类中的get方法，为获取User的id stream()优点 无存储。stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。为函数式编程而生。对stream的任何修改都不会修改背后的数据源，比如对stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新stream。惰式执行。stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。可消费性。stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。stream().map()方法的使用示例: 再看几个例子：数组字母小写变大写List list= Arrays.asList(“a”, “b”, “c”, “d”); List collect =list.stream().map(String::toUpperCase).collect(Collectors.toList());System.out.println(collect); //[A, B, C, D] 数组所有元素，按某种规律计算：List num = Arrays.asList(1,2,3,4,5);List collect1 = num.stream().map(n -&gt; n * 2).collect(Collectors.toList());System.out.println(collect1); //[2, 4, 6, 8, 10]","categories":[{"name":"java基础","slug":"java基础","permalink":"http://newbieqiu.top/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://newbieqiu.top/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"Springboot集成ElasticSearch入门","slug":"Springboot集成ElasticSearch入门","date":"2022-06-14T07:17:42.000Z","updated":"2022-06-14T07:17:42.045Z","comments":true,"path":"2022/06/14/Springboot集成ElasticSearch入门/","link":"","permalink":"http://newbieqiu.top/2022/06/14/Springboot%E9%9B%86%E6%88%90ElasticSearch%E5%85%A5%E9%97%A8/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"axios使用篇(入门）","slug":"axios使用篇-入门）","date":"2022-06-07T08:38:40.000Z","updated":"2022-06-07T08:56:37.511Z","comments":true,"path":"2022/06/07/axios使用篇-入门）/","link":"","permalink":"http://newbieqiu.top/2022/06/07/axios%E4%BD%BF%E7%94%A8%E7%AF%87-%E5%85%A5%E9%97%A8%EF%BC%89/","excerpt":"","text":"axios的使用（入门篇） 别问，问就是前端代码看不懂来补课了 QAQ 一、axios的特点 在浏览器和node中都可以使用 支持 Promise API 可以拦截请求、响应 转换请求数据、响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 二、使用方法在项目中安装： $ npm install axios ​ 1. 默认配置​ 我们可以给axios设置一个默认的基本配置，里面包括 url、method 等，设置好之后就不用每次添加了。（只有 url 是必需的，如果没有指定 method，请求将默认使用 get 方法。） axios.defaults.baseURL = 'https://api.example.com'; axios.defaults.headers.common['Authorization'] = AUTH_TOKEN; axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 2. 自定义全局配置// 设置配置对象 const configOptions={ baseURL: 'https://api.example.com', timeout:30000, // 超时取消请求 withCredentials: true, // 表示跨域请求时是否需要使用凭证，默认false } //创建实例时，传入配置 const instance = axios.create(configOptions); // 实例创建后更改默认值 axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 注意：配置是有优先级的，这个顺序是：在 lib/defaults.js 找到的库的默认值 &lt; 是实例的 defaults 属性 &lt; 请求的 config 参数。后者将优先于前者。 3. 请求配置{ // `url` 是用于请求的服务器 URL url: '/user', // `method` 是创建请求时使用的方法 method: 'get', // default // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: 'https://some-domain.com/api/', /* `transformRequest`：向服务器发送前，修改请求数据; 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法； 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream */ transformRequest: [function (data, headers) { // 对 data 进行任意转换处理 return data; }], // `transformResponse` 在传递给 then/catch 前，修改响应数据 transformResponse: [function (data) { // 对 data 进行任意转换处理 return data; }], } 官方为了方便起见，给axios的常用方法专门起了别名，可以直接像这样使用：axios.get()，axios.post()，axois.put()等等。请求方法的别名为方便起见，为所有支持的请求方法提供了别名 axios.request(config)axios.get(url[, config])axios.delete(url[, config])axios.head(url[, config])axios.options(url[, config])axios.post(url[, data[, config]])axios.put(url[, data[, config]])axios.patch(url[, data[, config]])注意在使用别名方法时， url、method、data 这些属性都不必在配置中指定。 4.发送get请求get 请求传参可以直接加在地址后，或写在params对象中。 const axios = require('axios').default; // 第一种：直接加在地址后，用问号？传参 axios.get('/user?ID=12345') .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }) .then(function () { // always executed }); // 第二种：在花括号中用params对象传参 axios.get('/user', { params: { ID: 12345 } }) // Want to use async/await? Add the `async` keyword to your outer function/method. async function getUser() { try { const response = await axios.get('/user?ID=12345'); console.log(response); } catch (error) { console.error(error); } } 5.发送post请求axios.post('/user', { firstName: 'Fred', lastName: 'Flintstone' }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); });","categories":[{"name":"前端","slug":"前端","permalink":"http://newbieqiu.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"axios","slug":"前端/axios","permalink":"http://newbieqiu.top/categories/%E5%89%8D%E7%AB%AF/axios/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://newbieqiu.top/tags/%E5%89%8D%E7%AB%AF/"},{"name":"axios","slug":"axios","permalink":"http://newbieqiu.top/tags/axios/"}]},{"title":"SpringCloud入门(Eureka)","slug":"SpringCloud入门-Eureka","date":"2022-06-06T12:16:24.000Z","updated":"2022-06-06T13:24:34.306Z","comments":true,"path":"2022/06/06/SpringCloud入门-Eureka/","link":"","permalink":"http://newbieqiu.top/2022/06/06/SpringCloud%E5%85%A5%E9%97%A8-Eureka/","excerpt":"","text":"SpringCloud入门(Eureka)Spring 概述Spring Cloud是一套组件，如服务治理和发现、配置中心、消息总线、负载均衡、断路器和数据监控等 服务治理和发现：在Spring Cloud中使用Eureka实现服务治理1.先创建一个项目当作Eureka的服务端，并引入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.7&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring.cloud.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 2.在其yaml文件中配置相关的属性 #应用名称 spring.application.name=eureka server #启动端口 server.port=15006 #是否注册到注册中心 eureka.client.register-with-eureka=false #是否检索服务 eureka.client.fetch-registry=false #实例host名称 eureka.instance.hostname=localhost #治理客户端服务域 eureka.client.service-url.defaultZone=http://localhost:15006/eureka/ server说明是服务端 3.在主类上加上注释 @EnableEurekaServer 4.在要注册的项目的pom文件中加入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 注意：若有 mahout依赖会发生包冲突，要除去一些包&lt;!--引入推荐引擎mahout，注意要先全部引入，再使用exclusion标签--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.mahout&lt;/groupId&gt; &lt;artifactId&gt;mahout-mr&lt;/artifactId&gt; &lt;version&gt;0.12.2&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-jcl&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-analyzers-common&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;jersey-client&lt;/artifactId&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;jersey-core&lt;/artifactId&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;jersey-apache-client4&lt;/artifactId&gt; &lt;groupId&gt;com.sun.jersey.contribs&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 在yaml中配置相关信息 spring.application.name=imooc-bilibili-api eureka.client.service-url.defaultZone=http://localhost:15006/eureka/ 6.最后访问上面配置的地址就OK了（服务端的地址）","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://newbieqiu.top/categories/SpringCloud/"},{"name":"Eureka","slug":"SpringCloud/Eureka","permalink":"http://newbieqiu.top/categories/SpringCloud/Eureka/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://newbieqiu.top/tags/SpringCloud/"},{"name":"Eureka","slug":"Eureka","permalink":"http://newbieqiu.top/tags/Eureka/"}]},{"title":"从零开始的Vue生活01(复习)","slug":"从零开始的Vue生活01-复习","date":"2022-05-25T10:56:41.000Z","updated":"2022-05-25T12:18:30.845Z","comments":true,"path":"2022/05/25/从零开始的Vue生活01-复习/","link":"","permalink":"http://newbieqiu.top/2022/05/25/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Vue%E7%94%9F%E6%B4%BB01-%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"开发TodoList&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"inputValue\"&gt; &lt;button v-on:click=\"handleBtnClick\"&gt;提交&lt;/button&gt; &lt;ul&gt; &lt;!-- &lt;li v-for =\"item in list\"&gt;{{item}}&lt;/li&gt; --&gt; &lt;todo-item :content=\"item\" :index =\"index\" v-for=\"(item,index) in list\" v-on:delete=\"handleItemDelete\" &gt;&lt;/todo-item&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var TodoItem ={ props:['content','index'], template:\"&lt;li @click='handleItemClick'&gt;{{content}}&lt;/li&gt;\", methods:{ handleItemClick:function(){ this.$emit(\"delete\",this.index) } } } // Vue.component(\"TodoItem\",{ // props:['content'], // template:\"&lt;li&gt;{{content}}&lt;/li&gt;\" // }) var app =new Vue({ el:\"#app\", components:{TodoItem:TodoItem } , data:{ list:['第一个内容','第二课内容'], inputValue:'' }, methods:{ handleBtnClick: function(){ this.list.push(this.inputValue) this.inputValue='' }, handleItemDelete:function(index){ this.list.splice(index,1) } } }) &lt;/script&gt; &lt;/body&gt; 1.配置对象el挂载点。el为属性，属性值为字符串。表示接管哪一片区域 例如：el: ‘#app’ data—–&gt;实例具体数据data用于创建Vue实例的实例属性。data为方法（常用），也可以为属性（不常用）。 当data为方法时，此方法中必须有返回值，返回值为对象，对象中写属性，属性名即为VM实例的属性名。 methods—–&gt;放置JS方法 2.指令v-for用于遍历数组和对象。item代表每一项。item表示的是列表中的数据， list是data中的列表 例如： v-on为元素绑定事件，简写为 @，与配置对象中的methods配合使用。 在methods配置对象中写的方法，将作为VM实例的方法。 dom元素绑定事件，方法定义在methods 格式： 简写：&lt;button @click=”handler”&gt;单击我加上 v-model用于实现数据的双向绑定，标签类型只能是表单元素（input）。input内容变化，Vue实例里data里的变量值也会跟着改变 Vue底层相当于用value属性实现的。格式： MVP模式（传统）和MVVM模式 M数据层 V视图 P控制器 Presenter是View和Model的中转站 编码的重点在Presenter 其中大部分都是在做dom操作 导致会有很多代码在p层，而mvvm则会自动渲染 mvvm模式： M层数据变化，V层会自动跟着变化。 VM可以监听到M层数据变化去改变V层的数 VM可以监听V层事件触发，调用逻辑代码去改变M层数据，在M层数据变化后又会去把改变的数据映射到V层 MVVM的核心层是M层，VM是Vue写好的不需要关注，V层的变化会根据M层数据的变化而变化。 Vue的生命周期函数1.概念生命周期函数就是Vue实例在某一个时间点会自动执行的函数。共11个函数（常用8个）。 vue的生命周期：创建=&gt;挂载=&gt;更新=&gt;销毁。 注意：Vue的生命周期函数不放在methods方法中，而是直接定义在Vue实例中。 2.所有生命周期函数（1）实例未完全实例化（beforeCreate）此函数是所有生命周期函数中最先执行的，并且只执行一次。在这个钩子函数中，实例并没有完全实例化。 因此响应式数据（写在data里面的属性），在beforeCreate中获取不到，通过this不能访问。并且不能调用methods中的方法。 （2）实例完全实例化（created）此函数只执行一次，在这里可以获取到响应式的数据，因为VM实例完全实例化了。 注意：发送AJAX请求、设置定时器等一次性任务，created速度更快。 （3）实例挂载之前（beforeMount）此函数只执行一次，因为实例还没挂载（渲染），因此不能获取真实DOM节点。 （4）实例挂载完毕（mounted）【重要】此函数只执行一次，这里可以获取到真实的DOM节点（页面渲染完成）。 以后使用AJAX去拉去服务器数据，都是在这里发请求。 （5）响应式数据更新之前（beforeUpdate）当响应式的数据（data里面的）发生变化的时候，会立即执行一次。 （6）响应式数据更新完毕（updated）只要响应式的数据（data里面的）发生变化的时候，就会立即执行一次。 在界面更新之后调用，此时可以访问最新的界面。 如：在浏览器中修改某条数据，也就是重新渲染数据，beforeUpdate和updated都会执行。 （7）销毁之前（beforeDestroy）实例销毁之前调用，此时实例仍然可以正常工作。 使用场景：取消AJAX请求，清除定时器、解绑监听等。 （8）全部销毁（destroyed）实例销毁后调用，实例已经无法正常工作了。 注意：刷新页面并不会触发此生命周期函数，只有关闭页面时才会。 不常用：（9）activated（激活的）每次缓存组件被激活时就会调用。通常与keep-alive结合使用。 （10）deactivated（失活的）缓存的组件停用时调用，可替代destroyed。通常与keep-alive结合使用。 （11）errorCaptured（捕获到错误）Vue的模板语法vue模版语法1、插值表达式：2、v-text：就是innertext，实际上跟插值表达式是一样的3、v-html：就是innerhtml，输出带样式效果4、v-text会进行一次转义，会将标签一起输出，但v-html不会进行转义，只能将内容输出5、：v-指令后面的值为js表达式，除了写js表达式还可以在后面加上字符串 例如： &lt;div v-html=\"name + 'Lee'\"&gt;&lt;/div&gt; Vue的计算属性，方法和侦听器computed：计算属性，有缓存。如果其依赖的数据项没有发生改变就不会重新计算，否则如果其依赖的数据项发生了改变就会触发里面的方法，与其无关的数据变化不会触发计算属性。 methods：方法， 没有缓存，使用时要加上()实现方法的调用，只要数据发生变化就会触发，不管数据就没有关系。（因为是函数的调用，又没有缓存，每调用一次就重新执行一次） watch：监听器，有缓存。功能与computed相似，但是代码复杂。 如果同一个功能，上述三个都可以实现，那么推荐computed，结构简单，性能好。 &lt;body&gt; &lt;div id=\"app\"&gt; {{fullName}} {{age}} &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: \"#app\", data: { firstName: \"Dell\", lastName: \"Lee\", fullName: \"Dell Lee\", age: 28 }, watch: { firstName: function() { console.log(\"计算了一次\"); this.fullName = this.firstName + \" \" + this.lastName; }, lastName: function() { console.log(\"计算了一次\"); this.fullName = this.firstName + \" \" + this.lastName; } } // 方法 // methods: { // fullName: function() { // console.log(\"计算了一次\"); // return this.firstName + \" \" + this.lastName; // } // } // 计算属性 // computed: { // fullName: function() { // console.log(\"计算了一次\"); // return this.firstName + \" \" + this.lastName // } // } }) &lt;/script&gt; &lt;/body&gt; 计算属性的getter和setter方法1.概念getter方法：读取此新属性时，此方法会被执行。setter方法：修改此新属性的属性值，会触发setter方法，参数value即为此属性的属性值。2.基本案例&lt;div id=\"app\"&gt; {{fullName}} &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: \"#app\", data: { firstName: \"Dell\", lastName: \"Lee\" }, computed: { fullName: { get: function () { return this.firstName + \" \" + this.lastName }, // 注意：如果不添加setter方法时，是无法直接修改计算属性的值的。需要通过computed里面的setter方法去修改。 set: function (value) { console.log(value); // 你好 世界 var arr = value.split(\" \"); this.firstName = arr[0]; this.lastName = arr[1]; } } } }) &lt;/script&gt; Vue中的样式绑定1.简介v-bind可以让HTML标签属性的属性值变为动态（响应式的）。 简写为冒号（:）注意：是属性值变成动态，而不是属性名变成动态。 如果是原生语法，其属性值为固定的字符串，而无法改变。 例如：我是一个p标签 格式：我是动态属性值 简写：我是动态属性值 2.案例&lt;style&gt; .activated { color: red } &lt;/style&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 属性值可以写成对象的形式 --&gt; &lt;div @click=\"handleDivClick\" :class=\"{activated : isActivated}\"&gt; Hello world &lt;/div&gt; &lt;!-- 属性值可以直接写变量名的形式 --&gt; &lt;div @click=\"handleDivClick\" :class=\"activated\"&gt; Hello world1 &lt;/div&gt; &lt;!-- 属性值可以写成数组的形式 --&gt; &lt;!-- 实际显示：class=\"iactivated activatedOne\" --&gt; &lt;div @click=\"handleDivClick\" :class=\"[activated , activatedOne]\"&gt; Hello world2 &lt;/div&gt; &lt;!-- 实际显示：style=\"color: black; font-size: 20px;\" --&gt; &lt;div :style=\"[styleObj, {fontSize: '20px'}]\" @click=\"handleDivClick\"&gt; Hello world3 &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: \"#app\", data: { styleObj: { color: \"black\" }, isActivated: false, activated: \"iactivated\", activatedOne: \"activatedOne\" }, methods: { handleDivClick: function () { this.styleObj.color = this.styleObj.color === \"black\" ? \"red\" : \"black\"; this.isActivated = !this.isActivated this.activated = this.activated === \"activated\" ? \"\" : \"activated\" } } }) Vue中的条件渲染v-if = 'show' 如果为false会移除dom结构 为真重新渲染dom结构 v-show='show' //其实相当于display:none和block切换经常切换使用 v-show 效率更高v-if 后边还可以接着写v-else-if v-else，但中间不需要有其他代码，必须紧挨着vue会尽量复用dom结构，如果需要每次都重新渲染 可以给一样的dom标签加上一个不同的key值，这样vue发现key值不一样就会重新渲染dom结果 Vue中的列表循环v-for=”(item.text,index) in list” :key=”item.id” 不建议用index作为key值 可以使用后端返回数据中的id值 传递key值的作用是增强性能 （key值最好是唯一 且不使用index 索引） 操作数据的方式(vue提供可以动态添加数据的方法）改变数据 页面实时响应 1.数组提供的方法pop() 删除数组最后一个元素 push() 可向数组的末尾添加一个或多个元素，并返回新的长度 unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度 shirt() 删除并返回数组的第一个元素 splice() 从数组中添加/删除项目，然后返回被删除的项目，该方法会改变原始数组 sort() 用于对数组的元素进行排序 reverse() 翻转数组 2.更改引用（数组是一个引用类型 更改数组的引用 也可以使数据发生改变）list=[] 将list引用给一个另外的数组 Vue事件处理事件修饰符@click.prevent 阻止事件的默认行为@click.stop 阻止事件冒泡@click.self 点击本身dom才会触发事件 （.self要求，click事件只有在e.target=e.currentTarget的时候才会执行）@click.once 事件只会执行一次，再点击解绑@click.captrue 按照捕获的顺序执行按键修饰符@keydown.enter/tab/esc(按键名） 按键之后才会触发 系统修饰符@keydown.ctrl/shift/meta 按住ctrl等系统修饰符,当按住了@keydown才会执行鼠标修饰符@click.right/left/middle 如：.right鼠标右键点击的时候才会执行 &lt;body&gt; &lt;div id=\"app\"&gt; &lt;div @click.right=\"handleClick\"&gt;click&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: \"#app\", methods: { handleClick: function(e) { console.log(\"right\"); } } }) &lt;/script&gt; &lt;/body&gt; Vue表单绑定通过v-model实现vue表单的双向绑定。1.input 2.textarea 3.checkbox checkbox（复选框true，false） 4.radio radio（单选框，需要给value值，选中则显示） 5.select v-model在select中 如果有value的值指向value的值 =‘1’ 如果没有value指向对应的inner-text = A v-model修饰符v-model.lazy，鼠标失焦（离开input表单）时才改变value v-model.number, 如果输入内容能转换成数字类型，就自动转换 v-model.trim, 去除首尾空格再存入value watch API 与选项式 API this.$watch (以及相应的 watch 选项) 完全等效。watch 需要侦听特定的数据源，并在单独的回调函数中执行副作用。默认情况下，它也是惰性的——即回调仅在侦听源发生变化时被调用。","categories":[{"name":"前端","slug":"前端","permalink":"http://newbieqiu.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"前端/Vue","permalink":"http://newbieqiu.top/categories/%E5%89%8D%E7%AB%AF/Vue/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://newbieqiu.top/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://newbieqiu.top/tags/Vue/"}]},{"title":"RocketMQ 基础篇","slug":"RocketMQ-基础篇","date":"2022-05-17T10:42:23.000Z","updated":"2022-05-17T10:42:23.570Z","comments":true,"path":"2022/05/17/RocketMQ-基础篇/","link":"","permalink":"http://newbieqiu.top/2022/05/17/RocketMQ-%E5%9F%BA%E7%A1%80%E7%AF%87/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"记一次项目所学(中间件等）-动态提醒功能","slug":"记一次项目所学-中间件等）","date":"2022-05-05T04:49:17.000Z","updated":"2022-05-05T14:31:21.111Z","comments":true,"path":"2022/05/05/记一次项目所学-中间件等）/","link":"","permalink":"http://newbieqiu.top/2022/05/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%A1%B9%E7%9B%AE%E6%89%80%E5%AD%A6-%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%AD%89%EF%BC%89/","excerpt":"","text":"记一次项目所学(中间件等）–动态提醒功能订阅发布模式与观察者模式 RocketMQ：纯java编写的开源消息中间件Redis : 高性能缓存工具，数据存储在内存中，读写速度非常快RocketMQ相关工具类及配置实现","categories":[{"name":"springboot","slug":"springboot","permalink":"http://newbieqiu.top/categories/springboot/"},{"name":"项目实战","slug":"springboot/项目实战","permalink":"http://newbieqiu.top/categories/springboot/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://newbieqiu.top/tags/springboot/"},{"name":"项目实战","slug":"项目实战","permalink":"http://newbieqiu.top/tags/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"}]},{"title":"记一次实战项目所学（通用接口篇）","slug":"记一次实战项目所学（通用接口篇）","date":"2022-05-04T11:53:23.000Z","updated":"2022-06-16T06:04:40.109Z","comments":true,"path":"2022/05/04/记一次实战项目所学（通用接口篇）/","link":"","permalink":"http://newbieqiu.top/2022/05/04/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E6%89%80%E5%AD%A6%EF%BC%88%E9%80%9A%E7%94%A8%E6%8E%A5%E5%8F%A3%E7%AF%87%EF%BC%89/","excerpt":"","text":"记一次实战项目所学（通用接口篇）1.加解密工具（AES，RSA，MD5） 账号登录时可用a.引依赖&lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.14&lt;/version&gt; &lt;/dependency&gt; b. AES加密 import org.apache.tomcat.util.codec.binary.Base64; import javax.crypto.Cipher; import javax.crypto.KeyGenerator; import javax.crypto.SecretKey; import java.nio.charset.StandardCharsets; import java.security.SecureRandom; /** * AES: Advanced Encryption Standard 高级加密标准 * 最常见的对称加密算法，即加密和解密使用同样的密钥，加密结果可逆 * 特点：加密速度非常快，适合经常发送数据的场合 * */ public class AESUtil { private static final String KEY_ALGORITHM = \"AES\"; private static final char[] HEX_CHAR = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }; private final Cipher decryptCipher; private final Cipher encryptCipher; private final String seed; public AESUtil(String seed) throws Exception { this.seed = seed; decryptCipher = Cipher.getInstance(KEY_ALGORITHM); encryptCipher = Cipher.getInstance(KEY_ALGORITHM); decryptCipher.init(Cipher.DECRYPT_MODE, this.getSecretKey()); encryptCipher.init(Cipher.ENCRYPT_MODE, this.getSecretKey()); } public String decrypt(String content) throws Exception { byte[] bytes = Base64.decodeBase64(content); byte[] result = decryptCipher.doFinal(bytes); return new String(result, StandardCharsets.UTF_8); } public String encrypt(String content) throws Exception { byte[] result = encryptCipher.doFinal(content.getBytes(StandardCharsets.UTF_8)); return Base64.encodeBase64String(result); } public SecretKey getSecretKey() throws Exception { SecureRandom random = SecureRandom.getInstance(\"SHA1PRNG\"); random.setSeed(seed.getBytes()); KeyGenerator kg = KeyGenerator.getInstance(KEY_ALGORITHM); kg.init(128, random); return kg.generateKey(); } } encrypt 方法用于加密 decrypt 方法用于解密 c. RSA加密import org.apache.commons.codec.binary.Base64; import javax.crypto.Cipher; import java.nio.charset.StandardCharsets; import java.security.*; import java.security.interfaces.RSAPrivateKey; import java.security.interfaces.RSAPublicKey; import java.security.spec.PKCS8EncodedKeySpec; import java.security.spec.X509EncodedKeySpec; /** * RSA加密 * 非对称加密，有公钥和私钥之分，公钥用于数据加密，私钥用于数据解密。加密结果可逆 * 公钥一般提供给外部进行使用，私钥需要放置在服务器端保证安全性。 * 特点：加密安全性很高，但是加密速度较慢 * 用于用户登录场景 */ public class RSAUtil { private static final String PUBLIC_KEY = \"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCQk33iNdA8Iey7J6XrBsidqn6u8EDLWPHsfEUgLQ3qiTikhPKDTzZkpAfU/O0x6NvSKa7Dp0+uqWT3vnW1De0+3u8mCYdVfOdH94VG4xg5U5UrRJei8HhPiXuvKQ+6NBtebCCW5adZ4pBgOiU14cJLhVmm+dYiLo3IDD5LqrlomQIDAQAB\"; private static final String PRIVATE_KEY = \"MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAJCTfeI10Dwh7LsnpesGyJ2qfq7wQMtY8ex8RSAtDeqJOKSE8oNPNmSkB9T87THo29IprsOnT66pZPe+dbUN7T7e7yYJh1V850f3hUbjGDlTlStEl6LweE+Je68pD7o0G15sIJblp1nikGA6JTXhwkuFWab51iIujcgMPkuquWiZAgMBAAECgYA1UT9mciQWWQh9yNRmhXzssFjB2TZ8B5RIe1fe0t7D9NEf0yvAgzDzEo8U3CX5dv/CVL7vxr8bEbt7phCwsa8hJiLEOr7hLZaJzXVTbvfqb91oCZGNkqDQ3NJfGBMVgUmltEYF2Bbk3U0NDyat+Gu54tRd2OH+adJYKsD0XYeDBQJBAN5FE8E04A4FA1q8mQbVTSVJDYIEJwOrdC0r3iZ7za5CyXGk+br8pFalRePFaksRGdN32+mYhDKVNrNHspAObVMCQQCmhBsD+xiWrmpnrzeIfCW1cX8qRC3/RMkq0ACw3l6YedNFdN2Tb5WsRHmcbCI9y8mfLHiG/X1R+zHZKG67EKjjAkAmvAkGSY2mQ89i160fWLq5/bIh71FRPWbgnF15fWfJr4/lgyeWI4MMKn80g2nTrSZACQpE+jRHkGNY+OywWCNLAkEAli5nvztkfeJpDYK2b16pE/B9ZL2BTs3XMcnQFbU5VAPsTKSOgz8MmwZXOIE+kMWP3wPY4McXlC0eVGFnHUh1SQJAeAl3RPk+XbZDMYfPkStRJwocG9Ap+88mwTgR1I7uPzZ1aM84/WsQskiVMXv2SZLmMWvYtnhIKosL6IACp2AcDA==\"; public static void main(String[] args) throws Exception{ String str = RSAUtil.encrypt(\"123456\"); System.out.println(str); } public static String getPublicKeyStr(){ return PUBLIC_KEY; } public static RSAPublicKey getPublicKey() throws Exception { byte[] decoded = Base64.decodeBase64(PUBLIC_KEY); return (RSAPublicKey) KeyFactory.getInstance(\"RSA\") .generatePublic(new X509EncodedKeySpec(decoded)); } public static RSAPrivateKey getPrivateKey() throws Exception { byte[] decoded = Base64.decodeBase64(PRIVATE_KEY); return (RSAPrivateKey) KeyFactory.getInstance(\"RSA\") .generatePrivate(new PKCS8EncodedKeySpec(decoded)); } //获得公钥和私钥 public static RSAKey generateKeyPair() throws NoSuchAlgorithmException { KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(\"RSA\"); keyPairGen.initialize(1024, new SecureRandom()); KeyPair keyPair = keyPairGen.generateKeyPair(); RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate(); RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic(); String publicKeyString = new String(Base64.encodeBase64(publicKey.getEncoded())); String privateKeyString = new String(Base64.encodeBase64(privateKey.getEncoded())); return new RSAKey(privateKey, privateKeyString, publicKey, publicKeyString); } public static String encrypt(String source) throws Exception { byte[] decoded = Base64.decodeBase64(PUBLIC_KEY); RSAPublicKey rsaPublicKey = (RSAPublicKey) KeyFactory.getInstance(\"RSA\") .generatePublic(new X509EncodedKeySpec(decoded)); Cipher cipher = Cipher.getInstance(\"RSA\"); cipher.init(1, rsaPublicKey); return Base64.encodeBase64String(cipher.doFinal(source.getBytes(StandardCharsets.UTF_8))); } public static Cipher getCipher() throws Exception { byte[] decoded = Base64.decodeBase64(PRIVATE_KEY); RSAPrivateKey rsaPrivateKey = (RSAPrivateKey) KeyFactory.getInstance(\"RSA\") .generatePrivate(new PKCS8EncodedKeySpec(decoded)); Cipher cipher = Cipher.getInstance(\"RSA\"); cipher.init(2, rsaPrivateKey); return cipher; } public static String decrypt(String text) throws Exception { Cipher cipher = getCipher(); byte[] inputByte = Base64.decodeBase64(text.getBytes(StandardCharsets.UTF_8)); return new String(cipher.doFinal(inputByte)); } public static class RSAKey { private RSAPrivateKey privateKey; private String privateKeyString; private RSAPublicKey publicKey; public String publicKeyString; public RSAKey(RSAPrivateKey privateKey, String privateKeyString, RSAPublicKey publicKey, String publicKeyString) { this.privateKey = privateKey; this.privateKeyString = privateKeyString; this.publicKey = publicKey; this.publicKeyString = publicKeyString; } public RSAPrivateKey getPrivateKey() { return this.privateKey; } public void setPrivateKey(RSAPrivateKey privateKey) { this.privateKey = privateKey; } public String getPrivateKeyString() { return this.privateKeyString; } public void setPrivateKeyString(String privateKeyString) { this.privateKeyString = privateKeyString; } public RSAPublicKey getPublicKey() { return this.publicKey; } public void setPublicKey(RSAPublicKey publicKey) { this.publicKey = publicKey; } public String getPublicKeyString() { return this.publicKeyString; } public void setPublicKeyString(String publicKeyString) { this.publicKeyString = publicKeyString; } } } 把公钥返回前端，用公钥把前端输入密码进行加密，将暗文返回后端 generateKeyPair用于生成公钥和私钥 encrypt 方法用于加密 （根据公钥） decrypt 方法用于解密 MD5加密 import org.apache.commons.codec.digest.DigestUtils; import java.io.UnsupportedEncodingException; /** * MD5加密 * 单向加密算法 * 特点：加密速度快，不需要秘钥，但是安全性不高，需要搭配随机盐值使用 * */ public class MD5Util { public static String sign(String content, String salt, String charset) { content = content + salt; return DigestUtils.md5Hex(getContentBytes(content, charset)); } public static boolean verify(String content, String sign, String salt, String charset) { content = content + salt; String mysign = DigestUtils.md5Hex(getContentBytes(content, charset)); return mysign.equals(sign); } private static byte[] getContentBytes(String content, String charset) { if (!\"\".equals(charset)) { try { return content.getBytes(charset); } catch (UnsupportedEncodingException var3) { throw new RuntimeException(\"MD5签名过程中出现错误,指定的编码集错误\"); } } else { return content.getBytes(); } } } sign用于加密 （内容，加密盐，编码） verify用于解密 2. Json返回数据类public class JsonResponse&lt;T&gt; { private String code; private String msg; private T data; public String getCode() { return code; } public void setCode(String code) { this.code = code; } public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; } public T getData() { return data; } public void setData(T data) { this.data = data; } public JsonResponse(String code, String msg) { this.code = code; this.msg = msg; } public JsonResponse(T data) { this.data = data; msg=\"成功\"; code=\"0\"; } //不需要返回前端但请求成功 public static JsonResponse&lt;String&gt; success(){ return new JsonResponse&lt;&gt;(null); } public static JsonResponse&lt;String&gt; success(String data){ return new JsonResponse&lt;&gt;(data); } public static JsonResponse&lt;String&gt; fail(){ return new JsonResponse&lt;&gt;(\"1\",\"失败\"); } public static JsonResponse&lt;String&gt; fail(String code ,String msg){ return new JsonResponse&lt;&gt;(code,msg); } } 将 状态码和状态与数据封装 3.Json转化配置（将返回的json搞成看得懂的）引入依赖&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.78&lt;/version&gt; &lt;/dependency&gt; import com.alibaba.fastjson.JSONObject; import com.alibaba.fastjson.serializer.SerializerFeature; import com.alibaba.fastjson.support.config.FastJsonConfig; import com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter; import org.springframework.boot.autoconfigure.http.HttpMessageConverters; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Primary; import java.util.ArrayList; import java.util.List; @Configuration public class JsonHttpMsgConvertConfig { @Bean @Primary public HttpMessageConverters fastJsonHttpMessageConvertes(){ //json转化 FastJsonHttpMessageConverter fastConverter=new FastJsonHttpMessageConverter(); FastJsonConfig fastJsonConfig=new FastJsonConfig(); fastJsonConfig.setDateFormat(\"yyyy-MM-dd HH:mm:ss\"); fastJsonConfig.setSerializerFeatures( SerializerFeature.PrettyFormat, //格式化输出 SerializerFeature.WriteNullStringAsEmpty, //把null值的属性转化为空字符串 SerializerFeature.WriteNullListAsEmpty, //同上 SerializerFeature.WriteMapNullValue, //同上 SerializerFeature.MapSortField, SerializerFeature.DisableCircularReferenceDetect); //禁用循环引用 fastConverter.setFastJsonConfig(fastJsonConfig); return new HttpMessageConverters(fastConverter); } } 4.全局异常处理import com.imooc.bilibili.domain.JsonResponse; import com.imooc.bilibili.domain.except.ConditionException; import org.springframework.core.Ordered; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.ControllerAdvice; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.ResponseBody; import javax.servlet.http.HttpServletRequest; @ControllerAdvice //@ControllerAdvice，是Spring3.2提供的新注解,它是一个Controller增强器,可对controller中被 @RequestMapping注解的方法加一些逻辑处理。最常用的就是异常处理 @Order(Ordered.HIGHEST_PRECEDENCE) public class CommonGlobalExceptionHandler { @ExceptionHandler(value = Exception.class) @ResponseBody //返回参数是responsebody public JsonResponse&lt;String&gt; commonExceptionHandler(HttpServletRequest httpServletRequest,Exception e){ String errorMsg =e.getMessage(); //如果e是condiException类型的话就会有个code状态码 if(e instanceof ConditionException){ String errorCode=((ConditionException)e).getCode(); return new JsonResponse&lt;&gt;(errorCode,errorMsg); }else { return new JsonResponse&lt;&gt;(\"500\",errorMsg); } } } 如果exception是conditionException的话，可以获得一个状态码，再用Json返回数据类返回，用于主动抛出异常，如密码错误等 配置分情况处理异常（ConditionException）补充runtimeException里没有的东西，多了一个code返回值表示状态码。 public class ConditionException extends RuntimeException { private static final long serialVersionUID =1L; //序列版本号 private String code; public ConditionException(String code,String name){ super(name); this.code=code; } public ConditionException(String name){ super(name); code=\"500\"; } public String getCode() { return code; } public void setCode(String code) { this.code = code; } } 5. 登录验证功能先获取公钥准备将前端输入的进行加密 //获得公钥 @GetMapping(\"/rsa-pks\") public JsonResponse&lt;String&gt; getRsaPublicKey(){ String publicKeyStr = RSAUtil.getPublicKeyStr(); return new JsonResponse&lt;&gt;(publicKeyStr); } 新建（注册）一个user（controller层） //新建一个用户 @PostMapping(\"/users\") //@RequestBody 把User 封装成json数据返回 public JsonResponse&lt;String&gt;addUser(@RequestBody User user){ userService.addUser(user); return JsonResponse.success(); } ​ （Service层） @Service public class UserService { @Autowired private UserDao userDao; public void addUser(User user) { String phone = user.getPhone(); if (StringUtils.isNullOrEmpty(phone)) { throw new ConditionException(\"手机号不能为空！\"); } User dbUser = this.getUserByPhone(phone); if (dbUser != null) { throw new ConditionException(\"该手机号已经被注册\"); } //加密需要 Date now = new Date(); //md5需要加密 String salt = String.valueOf(now.getTime()); String password = user.getPassword(); String rawPassword; try { rawPassword = RSAUtil.decrypt(password);//该密码已经通过前端获取的公钥加密 } catch (Exception e) { throw new ConditionException(\"解密失败\"); } String md5Password = MD5Util.sign(rawPassword, salt, \"UTF-8\"); user.setSalt(salt); user.setPassword(md5Password); user.setCreateTime(now); userDao.addUser(user); //添加用户信息(这里有两张表user和userinfo ) UserInfo userInfo = new UserInfo(); userInfo.setUserId(user.getId()); userInfo.setNick(UserConstant.DEFAULT_NICK); userInfo.setBirth(UserConstant.DEFAULT_BIRTH); userInfo.setGender(UserConstant.GENDER_FEMALE); userInfo.setCreateTime(now); userDao.addUserInfo(userInfo); } public User getUserByPhone(String phone) { return userDao.getUserByPhone(phone); } dao层为数据操作不再贴代码啦 用户登录controller //用户登录 @PostMapping(\"/user-tokens\") public JsonResponse&lt;String&gt; login(@RequestBody User user) throws Exception{ String token=userService.login(user); return new JsonResponse&lt;&gt;(token); } service public String login(User user) throws Exception { String phone = user.getPhone(); if (StringUtils.isNullOrEmpty(phone)) { throw new ConditionException(\"手机号不能为空！\");} User dbUser = this.getUserByPhone(phone); if (dbUser == null) { throw new ConditionException(\"当前用户不存在\"); } String password = user.getPassword(); String rowpassword; try { rowpassword = RSAUtil.decrypt(password); } catch (Exception e) { throw new ConditionException(\"密码解密失败\"); } String salt = dbUser.getSalt(); String md5Password = MD5Util.sign(rowpassword, salt, \"UTF-8\"); if (!md5Password.equals(dbUser.getPassword())) { throw new ConditionException(\"密码错误！\"); } return TokenUtil.generateToken(dbUser.getId()); } 前端加密不安全，数据库存入的密码应该是不可逆的，每次认证时候前端传入密码加密后跟后端数据库里密码比对，如果一样密码正确，如果不一样密码不正确，前端加密后传输是怕传输过程被拦截获取到明文密码 因为id是唯一的所以id可以作为token 5.5 基于JWT的用户的token验证 依赖 &lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.18.2&lt;/version&gt; &lt;/dependency&gt; util.token import com.auth0.jwt.JWT; import com.auth0.jwt.JWTVerifier; import com.auth0.jwt.algorithms.Algorithm; import com.auth0.jwt.exceptions.TokenExpiredException; import com.auth0.jwt.interfaces.DecodedJWT; import com.imooc.bilibili.domain.except.ConditionException; import java.util.Calendar; import java.util.Date; public class TokenUtil { private static final String ISSUER=\"签发者\"; //签发者是谁，随意填 public static String generateToken(Long userId) throws Exception{ Algorithm algorithm = Algorithm.RSA256(RSAUtil.getPublicKey(),RSAUtil.getPrivateKey()); Calendar calendar =Calendar.getInstance(); //用于实现过期时间 calendar.setTime(new Date()); calendar.add(Calendar.SECOND,30); //30s过期 return JWT.create().withKeyId(String.valueOf(userId)) .withIssuer(ISSUER) .withExpiresAt(calendar.getTime()) .sign(algorithm); } //解密 public static Long verifyToken(String token) { try{ Algorithm algorithm =Algorithm.RSA256(RSAUtil.getPublicKey(),RSAUtil.getPrivateKey()); JWTVerifier verifier =JWT.require(algorithm).build(); DecodedJWT jwt= verifier.verify(token); String keyId = jwt.getKeyId(); return Long.valueOf(keyId); }catch (TokenExpiredException e){ throw new ConditionException(\"555\",\"token过期！\"); }catch (Exception e){ throw new ConditionException(\"非法用户token\"); } } } 需要一个通用方法，获取token里的userid（一般放在请求头里） import com.imooc.bilibili.domain.except.ConditionException; import com.imooc.bilibili.service.Util.TokenUtil; import org.springframework.stereotype.Component; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes; import javax.servlet.ServletRequest; @Component public class UserSupport { public Long getCurrentUserId(){ //抓取请求上下文,获取token(在请求头中)+ ServletRequestAttributes requestAttributes =(ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); String token =requestAttributes.getRequest().getHeader(\"token\"); Long userId= TokenUtil.verifyToken(token); if(userId&lt;0){ throw new ConditionException(\"非法用户！\"); } return userId; } }","categories":[{"name":"后端项目实战","slug":"后端项目实战","permalink":"http://newbieqiu.top/categories/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"name":"springboot","slug":"后端项目实战/springboot","permalink":"http://newbieqiu.top/categories/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://newbieqiu.top/tags/springboot/"},{"name":"后端项目实战","slug":"后端项目实战","permalink":"http://newbieqiu.top/tags/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"}]},{"title":"从0开始的dp生活——线性dp","slug":"从0开始的dp生活——线性dp","date":"2022-05-03T13:51:08.000Z","updated":"2022-05-04T14:13:48.873Z","comments":true,"path":"2022/05/03/从0开始的dp生活——线性dp/","link":"","permalink":"http://newbieqiu.top/2022/05/03/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84dp%E7%94%9F%E6%B4%BB%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7dp/","excerpt":"","text":"数字三角形模型 #include&lt;iostream&gt; using namespace std; int a[510][510], f[510][510]; //a储存数字三角形，f为从起点到任意点(i,j)的最大路径 int INF = 1e9; int main() { for (int i = 0; i &lt; 510; i++) for (int j = 0; j &lt; 510; j++) f[i][j] = -INF; //a数组中有负数，处理三角形边界时需要使用f的初始值做比较 int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= i; j++) //等边三角形映射为等腰直角三角形后，录入数字三角形数据 cin &gt;&gt; a[i][j]; f[1][1] = a[1][1]; //起点到起点的最短距离为a[1][1]，其他f默认值为-INF，必须手动设置f[1][1] for (int i = 2; i &lt;= n; i++) for (int j = 1; j &lt;= i; j++) f[i][j] = max(f[i - 1][j - 1], f[i - 1][j]) + a[i][j]; //dynamic programming for (int i = 2; i &lt;= n; i++) f[n][1] = max(f[n][1], f[n][i]); //起点到最后一排的各点值的最大值中，选取最大值的最大值 cout &lt;&lt; f[n][1]; } 题目描述给定一个 n×m 的矩阵，起点位置在 (1,1)，终点位置是 (n,m)接着给定该矩阵上，每个位置(x,y)上的物品的价值w现需要我们制定一个方案： 从起点出发，只能向右或向下走，如何走到终点，才能使经过的所有格子的物品总价值最大 题解这题是一道标准的动态规划问题，模型是数字三角形 我们先来分析一下 如果要进行动态规划，则用来表示当前状态的参数有哪些？ 当前走到第i行当前走到第j列于是乎，我们可以开二维数组f(i,j) 来存储当前在i行j列的状态 而f[i,j]的值，就是表示从起点走到该点经过的所有格子的价值总和的最大值 则最终答案的状态就是f(n,m) 然后再考虑状态转移方程 因为限制了只能向右或向下走，因此当前状态f(i,j)只能由f(i-1,j)或f[(i,j-1)(只能向右或向下走)转移过来 闫氏DP分析法状态表示f(i,j) 属性:从起点出发，走到第i行第j列的所有方案 集合:方案中的路线经过的所有物品的总价值最大Max状态转移 f(i,j)=max{f(i−1,j),f(i,j−1)}+w(i,j) #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; const int N =110; int dp[N][N]; int map[N][N]; int main(){ int t; cin&gt;&gt;t ; while(t--){ int m,n; cin&gt;&gt;m&gt;&gt;n; for(int i=1;i&lt;=m;i++){ for(int j=1;j&lt;=n;j++){ cin&gt;&gt;map[i][j]; } } for(int i=1;i&lt;=m;i++){ for(int j=1;j&lt;=n;j++){ dp[i][j]=max(dp[i-1][j],dp[i][j-1])+map[i][j]; } } cout&lt;&lt;dp[m][n]&lt;&lt;endl; } return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"http://newbieqiu.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"http://newbieqiu.top/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://newbieqiu.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://newbieqiu.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"从0开始的英语生活——词根","slug":"从0开始的英语生活——词根","date":"2022-05-03T13:29:55.000Z","updated":"2022-05-03T13:48:38.415Z","comments":true,"path":"2022/05/03/从0开始的英语生活——词根/","link":"","permalink":"http://newbieqiu.top/2022/05/03/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E8%8B%B1%E8%AF%AD%E7%94%9F%E6%B4%BB%E2%80%94%E2%80%94%E8%AF%8D%E6%A0%B9/","excerpt":"","text":"词根篇前缀定方向，后缀定词性，词根定词义1. ced/cess =go 行走precede v先于 precedent 先例 unprecedentedly 史无前例的 recede 后退v recession 经济衰退 intercede 调停v exceed 超过 excess excessive 过分的 access 2.-cid，cis =cut ,kill 切，杀decide concise 简洁的 precise 精确的 ~to be more precise 更精确地说 suicide 自杀 pesticide 杀虫剂 3. claim=cry，shout 喊叫exclaim proclaim 宣告公布v declaim 演讲v reclaim v.收回开拓 acclaim v 称赞 4. clud，clus =close 关闭seclude v使隔绝 conclude 5. dec/dect = lead 引导conduct 指挥 seduce 勾引 6.fer =bring 拿ferry 轮渡，渡 differ differentiate 7.ject，jet =throw 投掷subject 主题话题 / 受影响的 project v抛出 8.migr =move 迁移emigrate 移居国外 immigrate 移居国内 9.pend/pens花费penny 美分 pension 退休金 compensate 赔偿 expenditure 花费n 10.pos=putexpose compose dispose 布置，处理（dis不同方向） propose 提议，求婚 impose 强加 11.rupt =break 破bankrupt 破产 disrupt 使混乱 corrupt 腐败 12. spect =look看prospect 前景 suspect spectator 观众 13.tract =draw 拉，引tractor 拖拉机 contract 合同契约 extract 提取 14.vert/vers =turn 转动reserve extrovert 外向的人 introvert 内向的人 15.vis/vid =see(visit)revise previse 预知 supervise 监督 evident 16.viv =live 活，生命revive vivid 生动的 vital 重要的","categories":[{"name":"英语","slug":"英语","permalink":"http://newbieqiu.top/categories/%E8%8B%B1%E8%AF%AD/"},{"name":"构词法","slug":"英语/构词法","permalink":"http://newbieqiu.top/categories/%E8%8B%B1%E8%AF%AD/%E6%9E%84%E8%AF%8D%E6%B3%95/"}],"tags":[{"name":"英语","slug":"英语","permalink":"http://newbieqiu.top/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"构词法","slug":"构词法","permalink":"http://newbieqiu.top/tags/%E6%9E%84%E8%AF%8D%E6%B3%95/"}]},{"title":"从0开始的英语学习——后缀","slug":"从0开始的英语生活——后缀篇","date":"2022-05-03T12:59:02.000Z","updated":"2022-05-03T13:29:16.830Z","comments":true,"path":"2022/05/03/从0开始的英语生活——后缀篇/","link":"","permalink":"http://newbieqiu.top/2022/05/03/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E8%8B%B1%E8%AF%AD%E7%94%9F%E6%B4%BB%E2%80%94%E2%80%94%E5%90%8E%E7%BC%80%E7%AF%87/","excerpt":"","text":"后缀篇前缀定方向，后缀定词性，词根定词义1.-able 能的，具有…性质的 adjadaptable 可适应的 2.-al 具有..性质的，属性…的regional 地区的 2.-al 名词后缀 ，“人”refusal criminal 3. -ate 做，造成generate v.造成 （gene 基因） activate v.激活 dictate v.口述 accelerate v. 加速 （acc强调，ele速度） differentiate v.区分 demonstrate v演示，证明（demon小样） 3. ate后缀 …的人candidate advocate electorate n.全体选民 3. -ate 形容词后缀 …的fortunate innate adj.天生的 moderate adj.适度的，中等的 legitimate adj.合法的 4. -ed 已….的，被…的extended 延伸的 married 已婚的 5. -en v.后缀 使…变成shorten threaten enlighten 启蒙 6. ence 抽象名词confidence dependence 7. -ful 富有，具有…性质的useful powerful 强大的 8. -ify -fy 使变成purity v净化 identify v.确认 personify v.拟人 modify v.调整 9. -ic …的historic adj. systematic 系统的 historic 历史上著名的 historical 历史的classic 经典的 classical 古文化的，古典的可见 -al 强调时间 -ic 强调意义10.-ion 抽象名词discussion n讨论 11. -ism ..主义，流派，特性individualism 个人主义 capitalism 资本主义 modernism 现代主义 humanism 人道主义 Marxism 马克思主义 12. -ist …人communist 共产主义者 hobbyist业余爱好者 13 -ive 具有..性质的innovative 革新的 （no -new) 14. -ize 化centralize romanticize 浪漫化 15. -less 无..的hopeless 16. -ment 物attachment n附件 basement 地下室n 17. -ness 抽象名词darkness 18. -ship情况.关系hardship 艰难 18. -ship 身份kingship 王权 membership 会员 ownership 所有权 co-authorship 合作者身份 19. -ward 向…的，朝download 20. -y 多的wordy 冗长的 icy 冰冷的 20.-y抽象名词injury 伤 jealousy 嫉妒 mastery 精通","categories":[{"name":"构词法","slug":"构词法","permalink":"http://newbieqiu.top/categories/%E6%9E%84%E8%AF%8D%E6%B3%95/"},{"name":"英语","slug":"构词法/英语","permalink":"http://newbieqiu.top/categories/%E6%9E%84%E8%AF%8D%E6%B3%95/%E8%8B%B1%E8%AF%AD/"}],"tags":[{"name":"英语","slug":"英语","permalink":"http://newbieqiu.top/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"构词法","slug":"构词法","permalink":"http://newbieqiu.top/tags/%E6%9E%84%E8%AF%8D%E6%B3%95/"}]},{"title":"从0开始的英语生活——前缀篇","slug":"从0开始的英语生活——前缀篇","date":"2022-04-28T08:20:10.000Z","updated":"2022-04-28T09:05:33.510Z","comments":true,"path":"2022/04/28/从0开始的英语生活——前缀篇/","link":"","permalink":"http://newbieqiu.top/2022/04/28/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E8%8B%B1%E8%AF%AD%E7%94%9F%E6%B4%BB%E2%80%94%E2%80%94%E5%89%8D%E7%BC%80%E7%AF%87/","excerpt":"","text":"前缀篇前缀定方向，后缀定词性，词根定词义1. ab - 离去，想法，不（消极意思）abnormal 反常的，变态的 adj abuse 滥用，虐待 n/v 2.anti - 反对，相反antiwar 反战的 antiaging 防衰老的 antiforeign 排外的 antinoise 抗噪音的 antibiotics 抗生素 n（biotic像biology） antitrust 反垄断的 （trust为托拉斯，垄断组织） 3.a+双写首字母 - 加强，强调作用account 账目，存款 n attract 吸引（tract的词根意为拉） assimilate 同化 v affluent 富裕的 adj（强调富得流油） 4. co-/col-/con/com- 一起cooperation collaboration 合作（labor为劳动，一起劳动） contribute 贡献（bute为贡品）v 5. counter - 反对，相反counterattack 反击n/v countereffect 反效果n counterpart 相对应的n counterfeit 仿制（feit，fict，fact词根为制造） 6.de- 否定，除去，向下denationlize 非国有化v decompose 分解v（com一起，pose放置） deforest 砍伐树林 devastating 毁灭性的（vast巨大的，巨大的东西掉下来了） deception 欺骗（cep词根 来） derive 起源 7. dis- 否定，除去，分开discover 发现 disease 疾病 disorder 无秩序n distract 分心 dismiss (解雇，清除)不再miss她 disposal 清理 pos词根为放置 8.ex- 外，前任的export 出口v,n ex-boyfriend expression 表情表达（向外压） 9. fore 前，先，预先forehead 前额（头的前面） forefather 祖先 foresee 预知 forerunner 先驱 10. in,im- 向里，否定，加强indoor adj室内的 inbreathe 吸入 incorrect intense（加强，延伸） 热情的 immerge 浸入v impose 强加，征税（放） impluse 冲动（加强，推） 11. mis- 错误，坏mismanagement 管理不当n misfortune 不幸 12.out- 超过，外outlet 出口 outperform v表现得更好 13.over- 过度overstatement 夸大n overemphasize 过分强调n 14.post- 后postwar 战后的 postpone 推后（pon为放） postgraduate 研究生n post-disaster 灾后生活 15. pre -前（时间上的前）prehistory 史前的 precondition 前提条件 precedent 先例 n（ced 超过) 16. pro - 空间上的前progress （gress为go）进步 n prolong 延长v propel 推进，促使v（pel-推） propose 提议，求婚（pose 拿put） 17. re- 向后，再一次return recall 召回，记得 regress 倒退v 18. sub- 下，下级subaverage 低于平均值v suburb 郊区 subconsciously =without knowing it (不易察觉的) –意识向下 19. trans - 转移（from A to B)transform transplant 移植 20. mono 一monotone 单调 monodrama 独角戏 monologue 独白 bi- 二bicycle （两个轮子） bilateral 双边的adj di- 二dioxide divorce tri - 三triangle trike 三轮车 hemi - 半hemisphere 半球 hemicycle 半圆形 semi- 半（抽象）semifinal 半决赛 poly- multi- 多monopoly 垄断（1个有多个） polytechnic 理工学院 multi-media","categories":[{"name":"英语","slug":"英语","permalink":"http://newbieqiu.top/categories/%E8%8B%B1%E8%AF%AD/"}],"tags":[{"name":"英语","slug":"英语","permalink":"http://newbieqiu.top/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"构词法","slug":"构词法","permalink":"http://newbieqiu.top/tags/%E6%9E%84%E8%AF%8D%E6%B3%95/"}]},{"title":"最短路算法之 bellman_ford 算法","slug":"最短路算法之-bellman-ford-算法","date":"2022-04-27T11:22:17.000Z","updated":"2022-04-27T12:00:38.500Z","comments":true,"path":"2022/04/27/最短路算法之-bellman-ford-算法/","link":"","permalink":"http://newbieqiu.top/2022/04/27/%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95%E4%B9%8B-bellman-ford-%E7%AE%97%E6%B3%95/","excerpt":"","text":"最短路算法之 bellman_ford算法bellman_ford 算法的时间复杂度为o（n*m），一般用在存在负权边的情况。存在负权边的情况bellman_ford 算法和 SPFA算法都可以使用 ，但SPFA算法会优于改算法，但有一种情况下不能代替。即题目中出现有边数限制的最短路。模板题思路 代码#include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; const int N = 510, M = 10010; struct Edge { int a; int b; int w; } e[M];//把每个边保存下来即可 int dist[N]; int back[N];//备份数组防止串联 int n, m, k;//k代表最短路径最多包涵k条边 int bellman_ford() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i &lt; k; i++) {//k次循环 memcpy(back, dist, sizeof dist); for (int j = 0; j &lt; m; j++) {//遍历所有边 int a = e[j].a, b = e[j].b, w = e[j].w; dist[b] = min(dist[b], back[a] + w); //使用backup:避免给a更新后立马更新b, 这样b一次性最短路径就多了两条边出来 } } if (dist[n] &gt; 0x3f3f3f3f / 2) return -1; else return dist[n]; } int main() { scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for (int i = 0; i &lt; m; i++) { int a, b, w; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;w); e[i] = {a, b, w}; } int res = bellman_ford(); if (res == -1) puts(\"impossible\"); else cout &lt;&lt; res; return 0; } 一些小细节为什么是dist[n]&gt;0x3f3f3f3f/2， 而不是dist[n]==0x3f3f3f3f5号节点距离起点的距离是无穷大，利用5号节点更新n号节点距离起点的距离，将得到109−2109−2, 虽然小于109109, 但并不存在最短路，(在边数限制在k条的条件下)。 为什么需要back[a]数组为了避免如下的串联情况， 在边数限制为一条的情况下，节点3的距离应该是3，但是由于串联情况，利用本轮更新的节点2更新了节点3的距离，所以现在节点3的距离是2。 正确做法是用上轮节点2更新的距离–无穷大，来更新节点3， 再取最小值，所以节点3离起点的距离是3。","categories":[{"name":"算法","slug":"算法","permalink":"http://newbieqiu.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"最短路","slug":"算法/最短路","permalink":"http://newbieqiu.top/categories/%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}],"tags":[]},{"title":"最短路之 Dijkstra 算法","slug":"最短路之-Dijstra-算法","date":"2022-04-26T04:02:29.000Z","updated":"2022-04-26T07:54:48.756Z","comments":true,"path":"2022/04/26/最短路之-Dijstra-算法/","link":"","permalink":"http://newbieqiu.top/2022/04/26/%E6%9C%80%E7%9F%AD%E8%B7%AF%E4%B9%8B-Dijstra-%E7%AE%97%E6%B3%95/","excerpt":"","text":"最短路之 Dijkstra 算法（朴素做法）时间复杂度 O(n2)没什么好说的先上模板题Dijkstra算法(用于稀疏图) 总结来说就是以下的几步：1.初始化距离 dist[1]=0 dist[i] =无穷大2. for( i=1 到 n)2.1 找t不在s中的距离最近的点2.2 讲 t加入到 s中2.3 用t更新到其他点的距离#include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; const int N=510; int g[N][N]; //为稠密阵所以用邻接矩阵存储 int dist[N]; //用于记录每一个点距离第一个点的距离 bool st[N]; //用于记录该点的最短距离是否已经确定 int n,m; int Dijkstra() { memset(dist, 0x3f,sizeof dist); //初始化距离 0x3f代表无限大 dist[1]=0; //第一个点到自身的距离为0 for(int i=0;i&lt;n;i++) //有n个点所以要进行n次 迭代 { int t=-1; //t存储当前访问的点 for(int j=1;j&lt;=n;j++) //这里的j代表的是从1号点开始 if(!st[j]&amp;&amp;(t==-1|| dist[t]&gt;dist[j]) ) t=j; st[t]=true; for(int j=1;j&lt;=n;j++) //依次更新每个点所到相邻的点路径值 dist[j]=min(dist[j],dist[t]+g[t][j]); //这里可能有同学要问j如果从1开始的话 会不会影响之前已经确定的点的最小距离 //但其实是不会 因为按照我们的Dijkstra算法的操作顺序 先确定最短距离的点的距离已经比后确定的要小 所以不会影响 //当然你也可以在循环判断条件里加上if(!st[i]) //这里j从1开始只是为了代码的简洁 } if(dist[n]==0x3f3f3f3f) return -1; //如果第n个点路径为无穷大即不存在最低路径 return dist[n]; } int main() { cin&gt;&gt;n&gt;&gt;m; memset(g,0x3f,sizeof g); //初始化图 因为是求最短路径 //所以每个点初始为无限大 while(m--) { int x,y,z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; g[x][y]=min(g[x][y],z); //如果发生重边的情况则保留最短的一条边 } cout&lt;&lt;Dijkstra()&lt;&lt;endl; return 0; } Dijkstra算法（堆优化版）用于稠密图，时间复杂度O(mlog(n)) m为变数n为点数模板题：堆优化版模板题 思路1.一号点的距离初始化为零，其他点初始化成无穷大。2.将一号点放入堆中。3.不断循环，直到堆空。每一次循环中执行的操作为：弹出堆顶（与朴素版diijkstra找到S外距离最短的点相同，并标记该点的最短路径已经确定）。用该点更新临界点的距离，若更新成功就加入到堆中。for(i:1 ~ n)//n次 { t &lt;- 没有确定最短路径的节点中距离源点最近的点;//每次遍一遍历dist数组，n次的复杂度是O(n^2) state[t] = 1; 更新 dist;//每次遍历一个节点的出边，n次遍历了所有节点的边，复杂度为O(e) } #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; typedef pair&lt;int, int&gt; PII; const int N = 100010; // 把N改为150010就能ac // 稀疏图用邻接表来存 int h[N], e[N], ne[N], idx; int w[N]; // 用来存权重 int dist[N]; bool st[N]; // 如果为true说明这个点的最短路径已经确定 int n, m; void add(int x, int y, int c) { w[idx] = c; // 有重边也不要紧，假设1-&gt;2有权重为2和3的边，再遍历到点1的时候2号点的距离会更新两次放入堆中 e[idx] = y; // 这样堆中会有很多冗余的点，但是在弹出的时候还是会弹出最小值2+x（x为之前确定的最短路径），并 ne[idx] = h[x]; // 标记st为true，所以下一次弹出3+x会continue不会向下执行。 h[x] = idx++; } int dijkstra() { memset(dist, 0x3f, sizeof(dist)); dist[1] = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; // 定义一个小根堆 // 这里heap中为什么要存pair呢，首先小根堆是根据距离来排的，所以有一个变量要是距离，其次在从堆中拿出来的时 // 候要知道知道这个点是哪个点，不然怎么更新邻接点呢？所以第二个变量要存点。 heap.push({ 0, 1 }); // 这个顺序不能倒，pair排序时是先根据first，再根据second，这里显然要根据距离排序 while(heap.size()) { PII k = heap.top(); // 取不在集合S中距离最短的点 heap.pop(); int ver = k.second, distance = k.first; if(st[ver]) continue; st[ver] = true; for(int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; // i只是个下标，e中在存的是i这个下标对应的点。 if(dist[j] &gt; distance + w[i]) { dist[j] = distance + w[i]; heap.push({ dist[j], j }); } } } if(dist[n] == 0x3f3f3f3f) return -1; else return dist[n]; } int main() { memset(h, -1, sizeof(h)); scanf(\"%d%d\", &amp;n, &amp;m); while (m--) { int x, y, c; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;c); add(x, y, c); } cout &lt;&lt; dijkstra() &lt;&lt; endl; return 0; } ps：不用continue不会影响后面的取值，因为有dis[j]&gt;distance+w[i]的判断，一定会更新成最小的那个，只不过就是把这个点的邻接点又加进去判断了而已，多了几次for循环，加上continue会减少这个判断，不加continue会超时，不会答案错误。","categories":[{"name":"算法","slug":"算法","permalink":"http://newbieqiu.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://newbieqiu.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://newbieqiu.top/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"Mybatis Plus笔记(1)","slug":"Mybatis-Plus笔记-1","date":"2022-04-25T09:56:51.000Z","updated":"2022-04-25T10:47:10.065Z","comments":true,"path":"2022/04/25/Mybatis-Plus笔记-1/","link":"","permalink":"http://newbieqiu.top/2022/04/25/Mybatis-Plus%E7%AC%94%E8%AE%B0-1/","excerpt":"","text":"初始化引入依赖(Springboot方式启动)&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 配置yml文件spring: # 配置数据源信息 datasource: # 配置数据源类型 type: com.zaxxer.hikari.HikariDataSource # 配置连接数据库信息 driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false username: root password: 123456 8.0加上这句在问号后面加上 serverTimezone=GMT%2B8&amp; 启动类在Spring Boot启动类中添加@MapperScan注解，扫描mapper包日志添加# 配置MyBatis日志 mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl 基本的CRUD操作批量删除@Test public void testDeleteBatchIds(){ //通过多个id批量删除 //DELETE FROM user WHERE id IN ( ? , ? , ? ) List&lt;Long&gt; idList = Arrays.asList(1L, 2L, 3L); int result = userMapper.deleteBatchIds(idList); System.out.println(\"受影响行数：\"+result); } 通过Map删除@Test public void testDeleteByMap(){ //根据map集合中所设置的条件删除记录 //DELETE FROM user WHERE name = ? AND age = ? Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"age\", 23); map.put(\"name\", \"张三\"); int result = userMapper.deleteByMap(map); System.out.println(\"受影响行数：\"+result); } 查询的map和批量查大同小异，这里不再一一赘述 。最后不要忘了 Mapper接口继承 BaseMapper 哦！！自定义接口在不改yaml文件的情况下默认把xml文件放在Mapper包下或者其子包下（或者可以在yaml文件下设置mapper-locations: classpath:/mapper/Usermapper.xml 记得在主加载类上加@Mapperscan 扫描 ！！！","categories":[],"tags":[{"name":"mybatisPlus","slug":"mybatisPlus","permalink":"http://newbieqiu.top/tags/mybatisPlus/"}]},{"title":"Mybatis 复习(一对多多对一)","slug":"Mybatis-复习-一对多多对一","date":"2022-04-24T09:44:33.000Z","updated":"2022-04-24T09:50:34.967Z","comments":true,"path":"2022/04/24/Mybatis-复习-一对多多对一/","link":"","permalink":"http://newbieqiu.top/2022/04/24/Mybatis-%E5%A4%8D%E4%B9%A0-%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%A4%9A%E5%AF%B9%E4%B8%80/","excerpt":"","text":"自定义映射resultMapresultMap处理字段和属性的映射关系 resultMap：设置自定义映射 属性： id：表示自定义映射的唯一标识，不能重复 type：查询的数据要映射的实体类的类型 子标签： id：设置主键的映射关系 result：设置普通字段的映射关系 子标签属性： property：设置映射关系中实体类中的属性名 column：设置映射关系中表中的字段名 若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射，即使字段名和属性名一致的属性也要映射，也就是全部属性都要列出来 &lt;resultMap id=\"empResultMap\" type=\"Emp\"&gt; &lt;id property=\"eid\" column=\"eid\"&gt;&lt;/id&gt; &lt;result property=\"empName\" column=\"emp_name\"&gt;&lt;/result&gt; &lt;result property=\"age\" column=\"age\"&gt;&lt;/result&gt; &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"email\" column=\"email\"&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;!--List&lt;Emp&gt; getAllEmp();--&gt; &lt;select id=\"getAllEmp\" resultMap=\"empResultMap\"&gt; select * from t_emp &lt;/select&gt; 若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用_），实体类中的属性名符合Java的规则（使用驼峰）。此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系 可以通过为字段起别名的方式，保证和实体类中的属性名保持一致 &lt;!--List&lt;Emp&gt; getAllEmp();--&gt; &lt;select id=\"getAllEmp\" resultType=\"Emp\"&gt; select eid,emp_name empName,age,sex,email from t_emp &lt;/select&gt; 可以在MyBatis的核心配置文件中的setting标签中，设置一个全局配置信息mapUnderscoreToCamelCase，可以在查询表中数据时，自动将_类型的字段名转换为驼峰，例如：字段名user_name，设置了mapUnderscoreToCamelCase，此时字段名就会转换为userName。核心配置文件详解 &lt;settings&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;/settings&gt; 多对一映射处理 查询员工信息以及员工所对应的部门信息 public class Emp { private Integer eid; private String empName; private Integer age; private String sex; private String email; private Dept dept; //...构造器、get、set方法等 } 级联方式处理映射关系&lt;resultMap id=\"empAndDeptResultMapOne\" type=\"Emp\"&gt; &lt;id property=\"eid\" column=\"eid\"&gt;&lt;/id&gt; &lt;result property=\"empName\" column=\"emp_name\"&gt;&lt;/result&gt; &lt;result property=\"age\" column=\"age\"&gt;&lt;/result&gt; &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"email\" column=\"email\"&gt;&lt;/result&gt; &lt;result property=\"dept.did\" column=\"did\"&gt;&lt;/result&gt; &lt;result property=\"dept.deptName\" column=\"dept_name\"&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;!--Emp getEmpAndDept(@Param(\"eid\")Integer eid);--&gt; &lt;select id=\"getEmpAndDept\" resultMap=\"empAndDeptResultMapOne\"&gt; select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #{eid} &lt;/select&gt; 使用association处理映射关系 association：处理多对一的映射关系 property：需要处理多对的映射关系的属性名 javaType：该属性的类型 &lt;resultMap id=\"empAndDeptResultMapTwo\" type=\"Emp\"&gt; &lt;id property=\"eid\" column=\"eid\"&gt;&lt;/id&gt; &lt;result property=\"empName\" column=\"emp_name\"&gt;&lt;/result&gt; &lt;result property=\"age\" column=\"age\"&gt;&lt;/result&gt; &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"email\" column=\"email\"&gt;&lt;/result&gt; &lt;association property=\"dept\" javaType=\"Dept\"&gt; &lt;id property=\"did\" column=\"did\"&gt;&lt;/id&gt; &lt;result property=\"deptName\" column=\"dept_name\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;!--Emp getEmpAndDept(@Param(\"eid\")Integer eid);--&gt; &lt;select id=\"getEmpAndDept\" resultMap=\"empAndDeptResultMapTwo\"&gt; select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #{eid} &lt;/select&gt; 分步查询1. 查询员工信息 select：设置分布查询的sql的唯一标识（namespace.SQLId或mapper接口的全类名.方法名） column：设置分步查询的条件 //EmpMapper里的方法 /** * 通过分步查询，员工及所对应的部门信息 * 分步查询第一步：查询员工信息 * @param * @return com.atguigu.mybatis.pojo.Emp * @date 2022/2/27 20:17 */ Emp getEmpAndDeptByStepOne(@Param(\"eid\") Integer eid); &lt;resultMap id=\"empAndDeptByStepResultMap\" type=\"Emp\"&gt; &lt;id property=\"eid\" column=\"eid\"&gt;&lt;/id&gt; &lt;result property=\"empName\" column=\"emp_name\"&gt;&lt;/result&gt; &lt;result property=\"age\" column=\"age\"&gt;&lt;/result&gt; &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"email\" column=\"email\"&gt;&lt;/result&gt; &lt;association property=\"dept\" select=\"com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo\" column=\"did\"&gt;&lt;/association&gt; &lt;/resultMap&gt; &lt;!--Emp getEmpAndDeptByStepOne(@Param(\"eid\") Integer eid);--&gt; &lt;select id=\"getEmpAndDeptByStepOne\" resultMap=\"empAndDeptByStepResultMap\"&gt; select * from t_emp where eid = #{eid} &lt;/select&gt; 2. 查询部门信息//DeptMapper里的方法 /** * 通过分步查询，员工及所对应的部门信息 * 分步查询第二步：通过did查询员工对应的部门信息 * @param * @return com.atguigu.mybatis.pojo.Emp * @date 2022/2/27 20:23 */ Dept getEmpAndDeptByStepTwo(@Param(\"did\") Integer did); &lt;!--此处的resultMap仅是处理字段和属性的映射关系--&gt; &lt;resultMap id=\"EmpAndDeptByStepTwoResultMap\" type=\"Dept\"&gt; &lt;id property=\"did\" column=\"did\"&gt;&lt;/id&gt; &lt;result property=\"deptName\" column=\"dept_name\"&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;!--Dept getEmpAndDeptByStepTwo(@Param(\"did\") Integer did);--&gt; &lt;select id=\"getEmpAndDeptByStepTwo\" resultMap=\"EmpAndDeptByStepTwoResultMap\"&gt; select * from t_dept where did = #{did} &lt;/select&gt; 一对多映射处理public class Dept { private Integer did; private String deptName; private List&lt;Emp&gt; emps; //...构造器、get、set方法等 } collection collection：用来处理一对多的映射关系 ofType：表示该属性对饮的集合中存储的数据的类型 &lt;resultMap id=\"DeptAndEmpResultMap\" type=\"Dept\"&gt; &lt;id property=\"did\" column=\"did\"&gt;&lt;/id&gt; &lt;result property=\"deptName\" column=\"dept_name\"&gt;&lt;/result&gt; &lt;collection property=\"emps\" ofType=\"Emp\"&gt; &lt;id property=\"eid\" column=\"eid\"&gt;&lt;/id&gt; &lt;result property=\"empName\" column=\"emp_name\"&gt;&lt;/result&gt; &lt;result property=\"age\" column=\"age\"&gt;&lt;/result&gt; &lt;result property=\"sex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"email\" column=\"email\"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!--Dept getDeptAndEmp(@Param(\"did\") Integer did);--&gt; &lt;select id=\"getDeptAndEmp\" resultMap=\"DeptAndEmpResultMap\"&gt; select * from t_dept left join t_emp on t_dept.did = t_emp.did where t_dept.did = #{did} &lt;/select&gt; 分步查询1. 查询部门信息/** * 通过分步查询，查询部门及对应的所有员工信息 * 分步查询第一步：查询部门信息 * @param did * @return com.atguigu.mybatis.pojo.Dept * @date 2022/2/27 22:04 */ Dept getDeptAndEmpByStepOne(@Param(\"did\") Integer did); &lt;resultMap id=\"DeptAndEmpByStepOneResultMap\" type=\"Dept\"&gt; &lt;id property=\"did\" column=\"did\"&gt;&lt;/id&gt; &lt;result property=\"deptName\" column=\"dept_name\"&gt;&lt;/result&gt; &lt;collection property=\"emps\" select=\"com.atguigu.mybatis.mapper.EmpMapper.getDeptAndEmpByStepTwo\" column=\"did\"&gt;&lt;/collection&gt; &lt;/resultMap&gt; &lt;!--Dept getDeptAndEmpByStepOne(@Param(\"did\") Integer did);--&gt; &lt;select id=\"getDeptAndEmpByStepOne\" resultMap=\"DeptAndEmpByStepOneResultMap\"&gt; select * from t_dept where did = #{did} &lt;/select&gt; 2. 根据部门id查询部门中的所有员工/** * 通过分步查询，查询部门及对应的所有员工信息 * 分步查询第二步：根据部门id查询部门中的所有员工 * @param did * @return java.util.List&lt;com.atguigu.mybatis.pojo.Emp&gt; * @date 2022/2/27 22:10 */ List&lt;Emp&gt; getDeptAndEmpByStepTwo(@Param(\"did\") Integer did); &lt;!--List&lt;Emp&gt; getDeptAndEmpByStepTwo(@Param(\"did\") Integer did);--&gt; &lt;select id=\"getDeptAndEmpByStepTwo\" resultType=\"Emp\"&gt; select * from t_emp where did = #{did} &lt;/select&gt;","categories":[],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://newbieqiu.top/tags/Mybatis/"}]},{"title":"Mybatis 笔记","slug":"Mybatis-笔记","date":"2022-04-24T07:11:32.000Z","updated":"2022-04-24T07:15:32.967Z","comments":true,"path":"2022/04/24/Mybatis-笔记/","link":"","permalink":"http://newbieqiu.top/2022/04/24/Mybatis-%E7%AC%94%E8%AE%B0/","excerpt":"","text":"MyBatis 笔记（基础配置）环境初始化依赖坐标 打包方式： jar &lt;dependencies&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.18&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; jdbc.propertiesdriver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/mybatis?userSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8 username=root password=1234 log4j.propertieslog4j.rootLogger=DEBUG,A1 log4j.appender.A1=org.apache.log4j.ConsoleAppender log4j.appender.A1.layout=org.apache.log4j.PatternLayout log4j.appender.A1.layout.ConversionPattern=[%t] [%c]-[%p] %m%n Mapper.xml 文件&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;!-- namespace:名称空间, 对应接口的全类名 --&gt; &lt;mapper namespace=\"org.hong.mapper.UserMapper\"&gt; &lt;!-- select: 配置查询 id: 唯一标识, 对应接口中的方法名 resultType: 返回值类型, 类的全类名, 如果返回值是集合写集合中泛型的类型 --&gt; &lt;select id=\"getAll\" resultType=\"org.hong.pojo.User\"&gt; select * from user &lt;/select&gt; &lt;/mapper&gt; mybatis 核心配置文件习惯上命名为mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。将来整合Spring之后，这个配置文件可以省略核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息核心配置文件存放的位置是src/main/resources目录下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//MyBatis.org//DTD Config 3.0//EN\" \"http://MyBatis.org/dtd/MyBatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;!--引入properties文件，此时就可以${属性名}的方式访问属性值--&gt; &lt;properties resource=\"jdbc.properties\"&gt;&lt;/properties&gt; &lt;settings&gt; &lt;!--将表中字段的下划线自动转换为驼峰--&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;!--开启延迟加载--&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;!-- typeAlias：设置某个具体的类型的别名 属性： type：需要设置别名的类型的全类名 alias：设置此类型的别名，且别名不区分大小写。若不设置此属性，该类型拥有默认的别名，即类名 --&gt; &lt;!--&lt;typeAlias type=\"com.atguigu.mybatis.bean.User\"&gt;&lt;/typeAlias&gt;--&gt; &lt;!--&lt;typeAlias type=\"com.atguigu.mybatis.bean.User\" alias=\"user\"&gt; &lt;/typeAlias&gt;--&gt; &lt;!--以包为单位，设置改包下所有的类型都拥有默认的别名，即类名且不区分大小写--&gt; &lt;package name=\"com.atguigu.mybatis.bean\"/&gt; &lt;/typeAliases&gt; &lt;!-- environments：设置多个连接数据库的环境 属性： default：设置默认使用的环境的id --&gt; &lt;environments default=\"mysql_test\"&gt; &lt;!-- environment：设置具体的连接数据库的环境信息 属性： id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境的id，表示默认使用的环境 --&gt; &lt;environment id=\"mysql_test\"&gt; &lt;!-- transactionManager：设置事务管理方式 属性： type：设置事务管理方式，type=\"JDBC|MANAGED\" type=\"JDBC\"：设置当前环境的事务管理都必须手动处理 type=\"MANAGED\"：设置事务被管理，例如spring中的AOP --&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!-- dataSource：设置数据源 属性： type：设置数据源的类型，type=\"POOLED|UNPOOLED|JNDI\" type=\"POOLED\"：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从缓存中直接获取，不需要重新创建 type=\"UNPOOLED\"：不使用数据库连接池，即每次使用连接都需要重新创建 type=\"JNDI\"：调用上下文中的数据源 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!--设置驱动类的全类名--&gt; &lt;property name=\"driver\" value=\"${jdbc.driver}\"/&gt; &lt;!--设置连接数据库的连接地址--&gt; &lt;property name=\"url\" value=\"${jdbc.url}\"/&gt; &lt;!--设置连接数据库的用户名--&gt; &lt;property name=\"username\" value=\"${jdbc.username}\"/&gt; &lt;!--设置连接数据库的密码--&gt; &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--引入映射文件--&gt; &lt;mappers&gt; &lt;!-- &lt;mapper resource=\"UserMapper.xml\"/&gt; --&gt; &lt;!-- 以包为单位，将包下所有的映射文件引入核心配置文件 注意： 1. 此方式必须保证mapper接口和mapper映射文件必须在相同的包下 2. mapper接口要和mapper映射文件的名字一致 --&gt; &lt;package name=\"Mappers.UserMapper\"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 把getSQLSession封装成工具类package org.hong.util; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; public class MyBatisUtil { private static SqlSessionFactory sqlSessionFactory; static { try { // 获取sqlSessionFactory对象 String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } // 既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。 // SqlSession 提供了在数据库执行 SQL 命令所需的所有方法 public static SqlSession getSqlSession(){ // openSession(): 此方式打开SQL会话, 事务是开启状态 // openSession(true): 此方式打开SQL会话, 事务是关闭状态 return sqlSessionFactory.openSession(); } public static SqlSessionFactory getSqlSessionFactory() { return sqlSessionFactory; } } 普通的CRUD创建mapper接口 MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要提供实现类 package Mappers; public interface UserMapper { int insertUser(); } 创建MyBatis的映射文件 对象：Java的实体类对象 关系：关系型数据库 映射：二者之间的对应关系 Java概念 数据库概念 类 表 属性 字段/列 对象 记录/行 映射文件的命名规则 表所对应的实体类的类名+Mapper.xml 例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml 因此一个映射文件对应一个实体类，对应一张表的操作 MyBatis映射文件用于编写SQL，访问以及操作表中的数据 MyBatis映射文件存放的位置是src/main/resources/mappers目录下 MyBatis中可以面向接口操作数据，要保证两个一致 mapper接口的全类名和映射文件的命名空间（namespace）保持一致 mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"zjiet.mapper.UserMapper\"&gt; &lt;!--int insertUser();--&gt; &lt;insert id=\"insertUser\"&gt; insert into user values (20, '张三', null , 2, , '176@qq.com') &lt;/insert&gt; &lt;/mapper&gt; 注意接口在java包里，xml在resources里面 且resources里的结构要与java里的结构保持一致.（即Mapper文件的相对位置） Test方法 public void test001(){ // 1.获取sqlSession对象 SqlSession sqlSession = MyBatisUtil.getSqlSession(); // 2.获取需要的mapper接口的代理对象 UserMapper mapper = sqlSession.getMapper(UserMapper.class); // 3.调用对应的方法执行操作 int save = mapper.insertUser(); System.out.println(save); // 4.提交事务 sqlSession.commit(); // 5.关闭sqlSession sqlSession.close(); }","categories":[],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://newbieqiu.top/tags/Mybatis/"}]}],"categories":[{"name":"大型项目","slug":"大型项目","permalink":"http://newbieqiu.top/categories/%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE/"},{"name":"SpringBoot","slug":"大型项目/SpringBoot","permalink":"http://newbieqiu.top/categories/%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE/SpringBoot/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://newbieqiu.top/categories/SpringBoot/"},{"name":"Builder","slug":"Builder","permalink":"http://newbieqiu.top/categories/Builder/"},{"name":"Swagger","slug":"大型项目/Swagger","permalink":"http://newbieqiu.top/categories/%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE/Swagger/"},{"name":"nginx","slug":"大型项目/nginx","permalink":"http://newbieqiu.top/categories/%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE/nginx/"},{"name":"项目结构","slug":"大型项目/项目结构","permalink":"http://newbieqiu.top/categories/%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/"},{"name":"数据库","slug":"数据库","permalink":"http://newbieqiu.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"数据库/mysql","permalink":"http://newbieqiu.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"},{"name":"前端","slug":"前端","permalink":"http://newbieqiu.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"算法","slug":"算法","permalink":"http://newbieqiu.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"英语","slug":"英语","permalink":"http://newbieqiu.top/categories/%E8%8B%B1%E8%AF%AD/"},{"name":"英语语法","slug":"英语/英语语法","permalink":"http://newbieqiu.top/categories/%E8%8B%B1%E8%AF%AD/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/"},{"name":"注解","slug":"注解","permalink":"http://newbieqiu.top/categories/%E6%B3%A8%E8%A7%A3/"},{"name":"Spring前置","slug":"注解/Spring前置","permalink":"http://newbieqiu.top/categories/%E6%B3%A8%E8%A7%A3/Spring%E5%89%8D%E7%BD%AE/"},{"name":"Spring源码前置","slug":"Spring源码前置","permalink":"http://newbieqiu.top/categories/Spring%E6%BA%90%E7%A0%81%E5%89%8D%E7%BD%AE/"},{"name":"设计模式","slug":"设计模式","permalink":"http://newbieqiu.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Spring源码前置","slug":"设计模式/Spring源码前置","permalink":"http://newbieqiu.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Spring%E6%BA%90%E7%A0%81%E5%89%8D%E7%BD%AE/"},{"name":"自研框架","slug":"自研框架","permalink":"http://newbieqiu.top/categories/%E8%87%AA%E7%A0%94%E6%A1%86%E6%9E%B6/"},{"name":"源码前置基础","slug":"自研框架/源码前置基础","permalink":"http://newbieqiu.top/categories/%E8%87%AA%E7%A0%94%E6%A1%86%E6%9E%B6/%E6%BA%90%E7%A0%81%E5%89%8D%E7%BD%AE%E5%9F%BA%E7%A1%80/"},{"name":"设计模式","slug":"自研框架/设计模式","permalink":"http://newbieqiu.top/categories/%E8%87%AA%E7%A0%94%E6%A1%86%E6%9E%B6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Java基础","slug":"Java基础","permalink":"http://newbieqiu.top/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"Spring源码","slug":"Spring源码","permalink":"http://newbieqiu.top/categories/Spring%E6%BA%90%E7%A0%81/"},{"name":"java基础","slug":"java基础","permalink":"http://newbieqiu.top/categories/java%E5%9F%BA%E7%A1%80/"},{"name":"axios","slug":"前端/axios","permalink":"http://newbieqiu.top/categories/%E5%89%8D%E7%AB%AF/axios/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://newbieqiu.top/categories/SpringCloud/"},{"name":"Eureka","slug":"SpringCloud/Eureka","permalink":"http://newbieqiu.top/categories/SpringCloud/Eureka/"},{"name":"Vue","slug":"前端/Vue","permalink":"http://newbieqiu.top/categories/%E5%89%8D%E7%AB%AF/Vue/"},{"name":"springboot","slug":"springboot","permalink":"http://newbieqiu.top/categories/springboot/"},{"name":"项目实战","slug":"springboot/项目实战","permalink":"http://newbieqiu.top/categories/springboot/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"name":"后端项目实战","slug":"后端项目实战","permalink":"http://newbieqiu.top/categories/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"name":"springboot","slug":"后端项目实战/springboot","permalink":"http://newbieqiu.top/categories/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/springboot/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"http://newbieqiu.top/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"构词法","slug":"英语/构词法","permalink":"http://newbieqiu.top/categories/%E8%8B%B1%E8%AF%AD/%E6%9E%84%E8%AF%8D%E6%B3%95/"},{"name":"构词法","slug":"构词法","permalink":"http://newbieqiu.top/categories/%E6%9E%84%E8%AF%8D%E6%B3%95/"},{"name":"英语","slug":"构词法/英语","permalink":"http://newbieqiu.top/categories/%E6%9E%84%E8%AF%8D%E6%B3%95/%E8%8B%B1%E8%AF%AD/"},{"name":"最短路","slug":"算法/最短路","permalink":"http://newbieqiu.top/categories/%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}],"tags":[{"name":"大型项目","slug":"大型项目","permalink":"http://newbieqiu.top/tags/%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://newbieqiu.top/tags/SpringBoot/"},{"name":"Builder","slug":"Builder","permalink":"http://newbieqiu.top/tags/Builder/"},{"name":"Swagger","slug":"Swagger","permalink":"http://newbieqiu.top/tags/Swagger/"},{"name":"nginx","slug":"nginx","permalink":"http://newbieqiu.top/tags/nginx/"},{"name":"项目结构","slug":"项目结构","permalink":"http://newbieqiu.top/tags/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/"},{"name":"数据库","slug":"数据库","permalink":"http://newbieqiu.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"mysql","permalink":"http://newbieqiu.top/tags/mysql/"},{"name":"html","slug":"html","permalink":"http://newbieqiu.top/tags/html/"},{"name":"css","slug":"css","permalink":"http://newbieqiu.top/tags/css/"},{"name":"算法","slug":"算法","permalink":"http://newbieqiu.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"英语","slug":"英语","permalink":"http://newbieqiu.top/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"注解","slug":"注解","permalink":"http://newbieqiu.top/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"Spring前置","slug":"Spring前置","permalink":"http://newbieqiu.top/tags/Spring%E5%89%8D%E7%BD%AE/"},{"name":"Spring源码前置","slug":"Spring源码前置","permalink":"http://newbieqiu.top/tags/Spring%E6%BA%90%E7%A0%81%E5%89%8D%E7%BD%AE/"},{"name":"设计模式","slug":"设计模式","permalink":"http://newbieqiu.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"自研框架","slug":"自研框架","permalink":"http://newbieqiu.top/tags/%E8%87%AA%E7%A0%94%E6%A1%86%E6%9E%B6/"},{"name":"源码前置基础","slug":"源码前置基础","permalink":"http://newbieqiu.top/tags/%E6%BA%90%E7%A0%81%E5%89%8D%E7%BD%AE%E5%9F%BA%E7%A1%80/"},{"name":"Java基础","slug":"Java基础","permalink":"http://newbieqiu.top/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"Spring源码","slug":"Spring源码","permalink":"http://newbieqiu.top/tags/Spring%E6%BA%90%E7%A0%81/"},{"name":"java基础","slug":"java基础","permalink":"http://newbieqiu.top/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"前端","slug":"前端","permalink":"http://newbieqiu.top/tags/%E5%89%8D%E7%AB%AF/"},{"name":"axios","slug":"axios","permalink":"http://newbieqiu.top/tags/axios/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://newbieqiu.top/tags/SpringCloud/"},{"name":"Eureka","slug":"Eureka","permalink":"http://newbieqiu.top/tags/Eureka/"},{"name":"Vue","slug":"Vue","permalink":"http://newbieqiu.top/tags/Vue/"},{"name":"springboot","slug":"springboot","permalink":"http://newbieqiu.top/tags/springboot/"},{"name":"项目实战","slug":"项目实战","permalink":"http://newbieqiu.top/tags/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"name":"后端项目实战","slug":"后端项目实战","permalink":"http://newbieqiu.top/tags/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"name":"动态规划","slug":"动态规划","permalink":"http://newbieqiu.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"构词法","slug":"构词法","permalink":"http://newbieqiu.top/tags/%E6%9E%84%E8%AF%8D%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://newbieqiu.top/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"mybatisPlus","slug":"mybatisPlus","permalink":"http://newbieqiu.top/tags/mybatisPlus/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://newbieqiu.top/tags/Mybatis/"}]}